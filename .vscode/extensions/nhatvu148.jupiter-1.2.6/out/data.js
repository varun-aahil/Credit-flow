"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.callTips = exports.map45 = exports.root4 = exports.map34 = exports.root3 = exports.map23 = exports.map12 = exports.root2 = exports.root1 = exports.psjGuiKeys = exports.psjUtilKeys = exports.libKey = void 0;
exports.libKey = [
    "random",
    " pipe",
    " open",
    " close",
    " write",
    " curdir",
    " mkdir",
    " chdir",
    " rmdir",
    " getcwd",
    " remove",
    " rename",
    " seek",
    " tell",
    " strftime",
    " argv",
    " today",
    " version",
    " date",
    " datetime",
    " sys",
    " re",
    " statistics",
    " system",
    " os",
    " and",
    " as",
    " assert",
    " break",
    " class",
    " continue",
    " def",
    " del",
    " elif",
    " else",
    " except",
    " exec",
    " abort",
    " finally",
    " for",
    " from",
    " global",
    " if",
    " import",
    " in",
    " is",
    " lambda",
    " not",
    " or",
    " pass",
    " print",
    " raise",
    " return",
    " try",
    " while",
    " with",
    " yield",
    " bool",
    " numpy",
    " array",
    " await",
    " async",
    " float",
    " str",
    " int",
    " format",
    " range",
    " split",
    " math",
    " strip",
    " rstrip",
    " lstrip",
    " join",
    " append",
    " len",
    " matplotlib",
    " replace",
    " find",
    " insert",
    " remove",
    " sort",
    " count",
    " clear",
    " __main__",
    " __init__",
    " itertools",
    " groupby",
    " shutil",
    " copyfile",
    " move",
    " False",
    " True",
    " None",
    " values",
    " sklearn",
    " pandas",
    "",
];
exports.psjUtilKeys = [
    "JPT",
    " Exec",
    " jpt",
    " dwg",
    " ELEMTYPE_PLOT",
    " LBC_NOLIN4",
    " LBC_T_CENTRIFUGAL_FORCE",
    " INST",
    " LBC_FORCE_VECTOR",
    " UpdateSelectors",
    " GetSelectedElemsCr",
    " AS_SOLIDELEM",
    " LBC_WELD",
    " CopyToClipBoard",
    " GetAllPartsInSubAssembly",
    " SHAPELINK",
    " Unit_ThermalExCoef",
    " DeSelectArrayCursor",
    " ABAQUSJOB",
    " GetAppPathInfo",
    " Unit_HeatFlux",
    " ELEMKIND_UNKNOWN",
    " x",
    " DTABLE_CONNECTION",
    " REF_SOLID",
    " CONNECT_MOMENT",
    " Unit_Modulus",
    " AS_CONTTACT",
    " TVector3d",
    " ConvertFromDocUnit",
    " Unit_StrainEnergy",
    " CONNECT_PROD",
    " AddNodeSelector",
    " RemoveAllLoadCases",
    " ADVCJOB",
    " FindSubAssemblyByID",
    " CheckLicense",
    " LBC_MAPPING_TEMP_LOAD",
    " PROPERTY_2D_SHELL",
    " isFloating",
    " DElem",
    " ELEMTYPE_HEX20",
    " LBC_INITSTRESS_GENERAL",
    " ABAQSTEPS_STRUCT_COUPLEDTD",
    " RemoveAllLoadsBCs",
    " colorMesh",
    " parent",
    " Unit_VolumeEnergyDensity",
    " FEM_FIELD_SCALAR",
    " LBC_G_PRESSURE",
    " GetEntitiesByAdjacent",
    " LBC_FORCE_QUADRATIC",
    " DTABLE_LBC_START",
    " Unit_AreaMomentInertia",
    " GetMaxMaterialID",
    " AddBodySelector",
    " Unit_Force",
    " CUSTOM_ATTR_DOUBLE",
    " GetAllByType",
    " Exec",
    " DeleteSubAssemblyRecursively",
    " AS_FACE",
    " DTABLE_UNKNOWN",
    " GetCurrentDocumentPath",
    " DGroup",
    " Unit_Length",
    " LBC_PRETENSION_ABAQUS",
    " AddVertexSelector",
    " CONTACT",
    " DTABLE_CONTACT",
    " REF_FACE",
    " ConvertFromMacroUnit",
    " VersionInfo",
    " CONNECT_WELD",
    " GetSelectedEdges",
    " CONTACT_NXNASTRAN",
    " PY_MACRO_ADDED",
    " LBC_SURFACE_LOADS",
    " ELEMTYPE_PRISM6",
    " ABAQSTEPS",
    " AddGroupSelector",
    " ATTRIBUTE_FXWELD",
    " GetSelectedNodes",
    " id",
    " masters",
    " Unit_Strain",
    " AddElementSelector",
    " LBC_TEMP_LOAD_GENERAL",
    " GroupVector",
    " LBC_GRAVITY",
    " ABAQSTEPS_STRUCT_DYNAMIC_EXPLICIT",
    " ADVCPROCESS_SSH",
    " DFace",
    " DTABLE_LBC_END",
    " GetMinIDEntity",
    " ATTRIBUTE_PS_BLENDSURFACE",
    " AddFacePointSelector",
    " GetAllLoadsBCs",
    " LBC_MAPPING_THERMAL_CONVECTION",
    " LBC_SUBMODEL_FORCED_FLUX",
    " isValid",
    " EdgeVector",
    " Unit_LinearDensity",
    " z",
    " type",
    " PROPERTY_2D_COMPOSITE_SHELL",
    " major",
    " ADVCPROCESS_CREEP",
    " DTABLE_COORDINATE",
    " IsDefaultInt",
    " Unit_Energy",
    " ELEMKIND_2D",
    " TEMP_PATH",
    " AS_ELEM1D",
    " LBC_DOFSET",
    " Show",
    " CUSTOM_ATTR_STRING",
    " LBC_MAPPING_FORCEDDISPLACEMENT",
    " ANSYSJOB",
    " LBC_TEMP_LOAD_ADVC_RESULT_REFERENCE",
    " LBC_MAPPING_HEATFLUX",
    " LBC_TEMP_LOAD",
    " ELEMTYPE_UNKNOWN",
    " ELEMTYPE_TRI6",
    " SelectDlgComboBox",
    " AddCoordinateSelector",
    " ELEMEDGE_GROUP",
    " ELEMTYPE_HEX8",
    " VERTEX",
    " PROPERTY_3D_WELDBEAD",
    " ELEMTYPE_TRI3",
    " LBC_MAPPING_FORCE",
    " ELEMTYPE_PRISM15",
    " Unit_ThermalConductivity",
    " LSDYNAJOB",
    " AddFaceSelector",
    " Unit_Time",
    " Hide",
    " RemoveEntitiesByID",
    " LBC_INSIDE_HEAT_GENERATION",
    " RemoveAllFieldTables",
    " GetJTDBVersion",
    " GetAllSelected",
    " name",
    " Unit_Mass",
    " DYANAMISJOB",
    " RemoveAllAbaqusStep",
    " DTABLE_SHAPE",
    " ELEMTYPE_QUAD8",
    " ADVCPROCESS_RESP_SPEC",
    " Unit_Volume",
    " SelectArrayCursor",
    " AS_EDGE",
    " GetSelectedParts",
    " ABAQSTEPS_THERMAL_TRANSIENT",
    " ELEMTYPE_MASS",
    " ABAQSTEPS_THERMAL_SS",
    " COORD",
    " ELEMKIND_3D",
    " GetEntitiesByID",
    " END",
    " ConvertValueToMacroUnit",
    " ELEMTYPE_TET4",
    " CONNECT_BUSH",
    " AddPyObserver",
    " ELEMTYPE_QUAD9",
    " DItemVector",
    " DItem",
    " UnitType",
    " children",
    " GetRedoCount",
    " InverseHideBodies",
    " GetLastCreatedCursor",
    " ADVCPROCESS_MODAL_FREQ_RESP",
    " ELEMTYPE_POINT",
    " CONNECT_CONM",
    " GetMaterialDBById",
    " nodes",
    " ElemKind",
    " BODYLINK",
    " LBC_CONTACT_CLEARANCE",
    " CONNECT_RBE2",
    " DTABLE_BODY",
    " ELEMTYPE_PRISM12",
    " RemoveAllByTableType",
    " GetOpnList",
    " ELEMKIND_0D",
    " LBC_MAPPING_TEMP_BOUNDARY",
    " CONTACT_ADVC",
    " DTABLE_LSDYNAJOB",
    " LBC_MAPPING_FORCED_TEMP",
    " ABAQSTEPS_STRUCT",
    " Unit_LinearMassMomentIntertia",
    " BodyVector",
    " slaves",
    " PROJECT",
    " PROPERTY_1D_ROD",
    " LBC_SUBMODEL_FORCED_DISP",
    " LBC_TEMP_LOAD_NASTRAN",
    " Unit_Pressure",
    " ELEMTYPE_TET10",
    " GetAllEdges",
    " DTABLE_ELEM",
    " CONNECT_GAP",
    " Apply",
    " ELEMTYPE_HEX18",
    " REF_ELEM",
    " y",
    " GetMaxIDEntity",
    " SOLID",
    " CONNECT_RBAR",
    " GetSelectedGroups",
    " Unit_SurfaceDensity",
    " typeID",
    " GetUndoCount",
    " GetMacroLog",
    " GetPythonAPILog",
    " Add1DElementSelector",
    " IsDefaultDouble",
    " LBC_MAPPING_PRESSURE",
    " SetDlgText",
    " ADVCPROCESS_DYNAMIC_EXPLICIT",
    " REF_SHAPELINK",
    " PROPERTY_1D_BAR",
    " ADVCPROCESS_FATIGUE",
    " PROPERTY_3D_COHESIVE",
    " ClearRedo",
    " GetAllNodes",
    " AS_BODY",
    " AS_MASS",
    " ABAQSTEPS_STRUCT_FREQUENCY",
    " targets",
    " ELEMTYPE_VIRTUAL",
    " LBC_FORCE",
    " WELDORDER",
    " ELEMTYPE_PYRAMID13",
    " LBC_SUBMODEL_FORCED_TEMP",
    " DTABLE_NODE",
    " DTABLE_DYNAMISJOB",
    " LBC_CONSTRAINT",
    " CONNECT_DAMPER",
    " ABAQSTEPS_THERMAL",
    " DTABLE_ANSYSJOB",
    " LBC_TEMP_INI",
    " SUP_GROUP",
    " LBC_TEMP_BOUNDARY",
    " GetCenterOfEntities",
    " DEdge",
    " FALSE_VAL",
    " ADVCPROCESS_TH",
    " RemoveAllContacts",
    " BEAM_PROP_ATTR",
    " ConvertValueToDocUnit",
    " ELEMTYPE_RBE",
    " AddConditionSelector",
    " REF_VERTEX",
    " elems",
    " Unit_Acceleration",
    " PushDlgButton",
    " Notify",
    " DTABLE_ABAQUSJOB",
    " DTABLE_FIELD_DATA",
    " DTABLE_LOCAL_SETTING",
    " SelectionListDlg",
    " DTableType",
    " LBC_CONCENTRATE_FLUX",
    " RemoveAllMeshSettings",
    " LBC_PRETENSION",
    " Unit_ConvectionCoef",
    " ADVCPROCESS_STATIC",
    " ENTITY_ATTR_CAD_INFO",
    " LBC_TEMP_LOAD_ADVC_FILE",
    " LBC_ENFORCED_ACCELERATION",
    " NASTRANJOB",
    " RemoveAllCoordinates",
    " RemovePyObserver",
    " DTABLE_ACTRANJOB",
    " Unit_Moment",
    " ADVCPROCESS_RAND_RESP",
    " edges",
    " Unit_RotateVelo",
    " LBC_THERMAL_CONVECTION",
    " PROPERTY_0D_MASS",
    " RemoveAllMaterials",
    " CONTACT_MSCNASTRAN",
    " Unit_TorsionalConst",
    " LBC_INITSTRESS_MAPPING",
    " Unit_RotateAcc",
    " SECTION_LIBRARY",
    " NASTRAN_POSTJOB",
    " GetEntitiesByAssociation",
    " AddEdgeSelector",
    " CreateSubAssembly",
    " GetAllFaces",
    " LBC_FORCE_SINE",
    " Create",
    " ElemVector",
    " vertexs",
    " CONN_PROP_ATTR",
    " AssociateType",
    " BARBODY",
    " CONNECT_MPC",
    " sub",
    " Unit_Density",
    " LBC_PRETENSION_NXN",
    " GetAllGroups",
    " LBC_NOLIN3",
    " QuitApplication",
    " ShowHideEntitiesByID",
    " GetMaterialOriginalXML",
    " GetSelectedPartsCr",
    " GetSelectedNodesCr",
    " USER_PROP",
    " ELEMTYPE_QUAD6",
    " DoubleVector",
    " ViewFitToModel",
    " LBC_PRESSURE_SINE",
    " EntityType",
    " DItemType",
    " Unit_Velocity",
    " REF_EDGE",
    " minor",
    " GetSelectedFacesCr",
    " BoolType",
    " Unit_Temperature",
    " LBC_PRESSURE_QUADRATIC",
    " AddBarBodySelector",
    " AS_GROUP",
    " Unit_Stress",
    " ClearUndo",
    " DTABLE_ADVCPROCESS",
    " AddEdgePointSelector",
    " APPDATA_PATH",
    " CONTACT_ABAQUS",
    " LBC_ENFORCED_DISP",
    " FindSubAssemblyByName",
    " FEM_FIELD_VECTOR",
    " ADVCPROCESS",
    " DTABLE_LOADCASE",
    " GetEntitiesByPosition",
    " NCS",
    " Unit_Area",
    " CONNECTION_ELEMENT",
    " Unit_Angle",
    " PROPERTY_1D_PLOT",
    " LBC_CS_CENTRIFUGAL_FORCE",
    " GetAllParts",
    " CONNECT_SPRING",
    " LBC_INIT_ANGULAR_VEL_ABAQUS",
    " RemoveWSProperties",
    " ELEMTYPE_LINE2",
    " ShowHideAllParts",
    " AS_ELEM",
    " DTABLE_ABAQSTEPS",
    " Unit_WarpCoef",
    " DeleteSubAssembly",
    " ConvertRGBToJPTColor",
    " ABAQSTEPS_STRUCT_DYNAMIC_COUPLEDTD",
    " GetProgramPath",
    " ReadJTDBVersion",
    " ELEMTYPE_LINE3",
    " AS_CONNECTION",
    " TRUE_VAL",
    " GetSharedFaces",
    " LBC_MAPPING_TEMP_INIT",
    " LBC_FORCE_ND",
    " PyNotificationType",
    " GetAllByTableTypeID",
    " CONNECT_CONNECTOR",
    " ACTRANJOB",
    " GetSelectedGroupsCr",
    " DNode",
    " pos",
    " Unit_Power",
    " DOC_PATH",
    " GetCountByType",
    " FEM_FIELD_TENSOR",
    " PY_DOCUMENT_SWITCHED",
    " ADVCPROCESS_DYNAMIC",
    " LBC_NOLIN1",
    " DBody",
    " DTABLE_ADVCJOB",
    " REF_BODYLINK",
    " ELEMTYPE_QUAD4",
    " DTABLE_PROPERTY",
    " kind",
    " ABAQSTEPS_STRUCT_STATICRISK",
    " DTABLE_MATERIAL",
    " Unit_DampingCoef",
    " ADVC2_POSTJOB",
    " StringVector",
    " SHELL_PROP_ATTR",
    " Unit_MomentInertia",
    " UNKNOWN",
    " RemoveAllSolverjob",
    " GetJPTTempPath",
    " LBC_ENFORCED_VELOCITY",
    " RemoveAllConnections",
    " REF_NODE",
    " SECTION_SKETCHER",
    " GetAllElems",
    " ADVCPROCESS_EIGEN",
    " key",
    " RemoveEntitiesByName",
    " faces",
    " transparency",
    " LBC_T_PRESSURE",
    " GetSharedElements",
    " Unit_Frequency",
    " LBC_DYNAMIC_INITIAL_CONDITION",
    " PROPERTY_1D_BEAM",
    " Cancel",
    " ABAQSTEPS_STRUCT_DYNAMIC",
    " GetSharedNodes",
    " Destroy",
    " ABAQSTEPS_STRUCT_STATIC",
    " SECTION_GENERAL",
    " NodeVector",
    " CONNECT_RBE3",
    " GetSelectedFaces",
    " PROPERTY_3D_SOLID",
    " Unit_ElectricalResistivity",
    " PrintAppPathInfo",
    " AddSolidElementSelector",
    " AddElementEdgeSelector",
    " REF_BODY",
    " Unit_RotateDampingCoef",
    " GetEntitiesByName",
    " color",
    " PROPERTY_3D_GASKET",
    " LBC_H_PRESSURE",
    " GetSelectedElems",
    " FaceVector",
    " BEAM_PROP_ATTR2",
    " LOADCASE",
    " Unit_HeatGeneration",
    " CONTACT_ANSYS",
    " PathType",
    " ELEMTYPE_PYRAMID5",
    " DCS",
    " GetSelectedEdgesCr",
    " MATERIAL",
    " ElemType",
    " CONTACT_TSSS",
    " ELEMKIND_1D",
    " LBC_MAPPING_TEMP_MARINE_ENGINE",
    " LBC_SURFACE_FLUX",
    " Unit_ThermalEnergy",
    " GetAllByTypeID",
    " LBC_RIGIDWALL",
    " info",
    " Unit_RotateStiff",
    " Unit_SpecificHeat",
    " build",
    " MsgOut",
    " DTABLE_GROUP",
    " BODY",
    " ELEMKIND_SP",
    " GetMaterialXML",
    " AS_NODE",
    " CUSTOM_ATTR_VECTOR",
    " LOCAL_SETTING",
    " DTABLE_NASTRANJOB",
    " Unit_Stiffness",
    " PROGRAM_PATH",
    " ClearPyObserver",
    " NODE",
    " EDGE",
    " FACE",
    " ELEM",
    " GROUP",
    " Debugger",
    " PrintPSJUtilityManual",
    " CastDItemToDBody",
    " CastDItemToDFace",
    " CastDItemToDElem",
    " CastDItemToDEdge",
    " CastDItemToDGroup",
    " CastDItemToDNode",
    " GetElemsByKind",
    " GetRandomJPTColor",
    " ConvertJPTColorToRGB",
    " ClearLog",
    " CastToDItem",
    " DItemToMacroTCursorPair",
    " ListDoubleToMacroVector",
    " DTVector3dToMacroVector",
    " DItemToMacroTCursor",
    " DItemListToMacroListTCursor",
    " DItemToMacroListTCursor",
    " MacroResultParser",
    " MacroListTCursorToListDItem",
    " MacroTCursorToDItem",
    " sizeVec",
    " clearVec",
    " addObj",
    " extendVec",
    " deleteObj",
    " isContainObj",
    " SetSelectMethod",
    " SELMTD_NONE",
    " SELMTD_BODY",
    " SELMTD_BAR_BODY",
    " SELMTD_FACE",
    " SELMTD_EDGE",
    " SELMTD_VERTEX",
    " SELMTD_SOLIDELEM",
    " SELMTD_ELEM",
    " SELMTD_ELEM1D",
    " SELMTD_ELEM_EDGE",
    " SELMTD_NODE",
    " SELMTD_CONDITION",
    " SELMTD_COORDINATE",
    " SELMTD_GROUP",
    " SELMTD_PROPERTY",
    " SELMTD_FACE_POINT",
    " SELMTD_EDGE_POINT",
    " SELMTD_VIEW_ITEM",
    " SELMTD_CONDITION_MPC",
    " SELMTD_CONDITION_RBE2",
    " SELMTD_CONDITION_RBE3",
    " SELMTD_CONDITION_RBAR",
    " SELMTD_CONDITION_SPRING",
    " SELMTD_CONDITION_MASS",
    " SELMTD_CONDITION_CONNECTOR",
    " SELMTD_CONDITION_PRESSURE",
    " SELMTD_CONDITION_FORCE",
    " SELMTD_CONDITION_ENFORCE",
    " SELMTD_CONDITION_CONSTRAIN",
    " SELMTD_CONDITION_TEMP",
    " SELMTD_SOLID_TET4",
    " SELMTD_SOLID_TET10",
    " SELMTD_SOLID_HEX8",
    " SELMTD_SOLID_HEX20",
    " SELMTD_SOLID_PENT6",
    " SELMTD_SOLID_PEN15",
    " SELMTD_SOLID_PYRD5",
    " SELMTD_SOLID_PYR13",
    " SELMTD_SHELL_TRI3",
    " SELMTD_SHELL_TRI6",
    " SELMTD_SHELL_QUAD4",
    " SELMTD_SHELL_QUAD8",
    " SelectMethodType",
    " DItemPair",
    " DItemPairVector",
    " MacroTCursorPairToDItemPair",
    " MacroListTCursorPairToListDItemPair",
    " MB_WARNING_YESNOCANCEL",
    " MB_WARNING_YESNO",
    " MB_WARNING_OK",
    " MB_WARNING_OKCANCEL",
    " MB_INFORMATION_YESNOCANCEL",
    " MB_INFORMATION_YESNO",
    " MB_INFORMATION_OK",
    " MB_INFORMATION_OKCANCEL",
    " MsgBoxType",
    " MessageBoxPSJ",
    " GetFirstDItem",
    " GetSecondDItem",
    "",
];
exports.psjGuiKeys = [
    "pyjdg",
    " dlg",
    " generate_window",
    " add_button",
    " add_textbox",
    " add_label",
    " add_imagectrl",
    " on_command",
    "add_combobox_option",
    " add_space",
    " add_combobox",
    " set_image_file",
    " add_textbox",
    " add_hlayout",
    " add_groupbox ",
    "add_vlayout",
    " do_modal",
    " JDGCreator",
    "",
];
exports.root1 = [
    "Export",
    "FileMenu",
    "HGTMufflerModeling",
    "ImportCAD",
    "ImportMesh",
    "Utility",
    "ACModeling",
    "Analysis",
    "Assemble",
    "Assembly",
    "BoundaryConditions",
    "Connections",
    "Designer",
    "EngReliability",
    "ExManifoldModeling",
    "Geometry",
    "Groups",
    "HexModeling",
    "Home",
    "MainWindow",
    "MeshCleanup",
    "MeshEdit",
    "Meshing",
    "MidPlane",
    "MidPlaneEdit",
    "MMCCarACTools",
    "MufflerHA",
    "MufflerT",
    "MuxWeld",
    "NSModeling",
    "OasisAWizard",
    "Post",
    "Properties",
    "SNOnePush",
    "StiffCalc",
    "SZOnepushReliability",
    "Test",
    "Tool",
    "Toolbar",
    "Tools",
];
exports.root2 = [
    "STL",
    "AddJTDB",
    "Save",
    "LoadDB",
    "CreateBeadWeld",
    "Spatial",
    "TechnoStarGeometry",
    "CreoDirect",
    "Elysium",
    "NastranBdf",
    "AbaqusINP",
    "LSDYNA",
    "ADVCADX",
    "Universal",
    "AnsysDat",
    "TSVPre",
    "FindEntities",
    "MeasureDistanceBy2Edges",
    "ACBoundary",
    "Create",
    "CloseHoleAuto",
    "Cut",
    "AbaqusStep",
    "ACTRAN",
    "Analysis",
    "Ansys",
    "Nastran",
    "Permas",
    "TSSolver",
    "TSSS",
    "Abaqus",
    "ExportAnsys",
    "ExportAbaqus",
    "ModifyLbcToStep",
    "ExportAdx",
    "ExportLsdyna",
    "NastranJob",
    "LSDYNAJob",
    "ADVC",
    "SeparateFaces",
    "Boolean",
    "AssembleFace",
    "FullLayer",
    "CylinderLayer",
    "SharedFace",
    "AssembleFaces",
    "GeneralLayer",
    "AddRib",
    "FindMatingFace",
    "AddBoss",
    "RightClick",
    "BoundaryTemperature",
    "Convection",
    "EnforcedLoads",
    "HeatFlux",
    "InitialElementalValue",
    "InitialTemperature",
    "LBCCopy",
    "Pressure",
    "Submodel",
    "TemperatureLoads",
    "LoadCase",
    "InsideHeatGeneration",
    "LbcContactConvert",
    "FieldData",
    "FixedConstraint",
    "DofSet",
    "BodyLoads",
    "Force",
    "InitialNodalValue",
    "Pretension",
    "MassElements",
    "BarBeam",
    "Gaps",
    "Plot",
    "CreateConnConm",
    "RBE3",
    "RigidWall",
    "Connector",
    "BoltMeshing_SplitOnly",
    "BoltMeshing_NotSplitOnly",
    "BoltConnections",
    "Contacts",
    "MPC",
    "RigidElements",
    "SpringsDampers",
    "LBC",
    "Load",
    "FindContact",
    "ContactMerge",
    "Material",
    "SubModelBC",
    "SZ",
    "Bar",
    "BodyCut",
    "BreakEntity",
    "DeleteEntity",
    "Edge",
    "Extract",
    "ExtractSurfaces",
    "Face",
    "FindFeature",
    "MergeEntities",
    "Part",
    "ShowAdjacent",
    "Transform",
    "CADTrim",
    "CreateBar",
    "StitchEdge",
    "LogoRemoval",
    "ShellAsm",
    "SquareUpFillet",
    "MakeFillet",
    "MakeFacePlanar",
    "FCircleAdjustVertex",
    "AdjustHalfCylinder",
    "FCircVertexAdjust",
    "RemoveRibBoss",
    "AdvancedShellAssembly",
    "Sweep",
    "SolidElemInterface",
    "BallHexa",
    "BoxMesh",
    "AutoSweep",
    "Circular",
    "FaceToFace",
    "Layer",
    "Linear",
    "FromMidPlane",
    "Curve",
    "ImportCAD",
    "ImportMesh",
    "Export",
    "ToImage",
    "Find",
    "RectangularCapture",
    "CopyToClipboard",
    "FullScreen",
    "Synchronize",
    "Element",
    "CorrectModel",
    "CloseHoles",
    "CloseGap",
    "AutoCheck",
    "ManualCheck",
    "ChangeTopology",
    "Cleanup",
    "Manual2D",
    "Manual3D",
    "CreateElement",
    "CreateNode",
    "MoveNode",
    "ElementConvert",
    "Deform",
    "MirrorCopy",
    "DeleteNode",
    "FaceImprint",
    "AdjustOrientation",
    "OneNode",
    "SeparateNodes",
    "RefineQuality",
    "Import",
    "RemoveSolidMesh",
    "MeshEditCMPMeshCopy",
    "MeshEditMorphingRibThickness",
    "MergeNodes",
    "MeshCopy",
    "RibThickness",
    "ChangePattern",
    "SurfaceMesh",
    "SolidMesh",
    "CADProjection",
    "LocalMeshing",
    "LocalSetting",
    "Templates",
    "BarMeshing",
    "GridMesh",
    "SolidMeshing",
    "SurfaceMeshing",
    "SetAttib",
    "LocalRemesh",
    "LocalSettings",
    "AdjustThickness",
    "FaceCross",
    "CreateThickProps",
    "FindMidPlane",
    "ExtendFace",
    "Manual",
    "AddItems",
    "ACModelCreationTools",
    "ClearanceElement",
    "CreateEdge",
    "CreateEdgeClassic",
    "CopyMeshCount",
    "SpecialModeling",
    "CreateWeld",
    "DefineSequence",
    "MeshingPass",
    "Prop3DWeldBead",
    "NSModeling_Close_Hole",
    "ImportResults",
    "ElemRelatedInfo",
    "Section",
    "Cohesive",
    "Gasket",
    "Shell",
    "PropertyTable",
    "Beam",
    "Rod",
    "Property1DBeamSimple",
    "Solid",
    "Section1D",
    "Composite",
    "BAR",
    "ThicknessDistribution",
    "RigidBody",
    "DropTest",
    "CADImport",
    "AutoSweepClosedLoopShaped",
    "Assembly",
    "MeshEdit",
    "AlignMidNode",
    "Connection",
    "MeshQuality",
    "Muffler",
    "ZGeometryTest",
    "FindFeatureFillet",
    "FindFacesInPart",
    "CreateElementForWelding",
    "Connections",
    "Coordinates",
    "Group",
    "ImprintEdges",
    "ElementCS",
    "Measure",
    "Undo",
    "Redo",
    "BySelection",
    "TotalLoad",
    "NodeCS",
    "NodeCSGroup",
    "DisplacementCS",
    "GroupByDCS",
    "Renumber",
    "RenumberByConnection",
    "RenumberByFile",
    "ModelInfo",
];
exports.map12 = {
    Export: ["STL"],
    FileMenu: ["AddJTDB", "Save", "LoadDB"],
    HGTMufflerModeling: ["CreateBeadWeld"],
    ImportCAD: ["Spatial", "TechnoStarGeometry", "CreoDirect", "Elysium"],
    ImportMesh: [
        "NastranBdf",
        "AbaqusINP",
        "LSDYNA",
        "ADVCADX",
        "Universal",
        "AnsysDat",
        "TSVPre",
    ],
    Utility: ["FindEntities", "MeasureDistanceBy2Edges"],
    ACModeling: ["ACBoundary", "Create", "CloseHoleAuto", "Cut"],
    Analysis: [
        "AbaqusStep",
        "ACTRAN",
        "Analysis",
        "Ansys",
        "Nastran",
        "Permas",
        "TSSolver",
        "TSSS",
        "Abaqus",
        "ExportAnsys",
        "ExportAbaqus",
        "ModifyLbcToStep",
        "ExportAdx",
        "ExportLsdyna",
        "NastranJob",
        "LSDYNAJob",
        "ADVC",
    ],
    Assemble: [
        "SeparateFaces",
        "Boolean",
        "AssembleFace",
        "FullLayer",
        "CylinderLayer",
        "SharedFace",
        "AssembleFaces",
        "GeneralLayer",
        "AddRib",
        "FindMatingFace",
        "AddBoss",
    ],
    Assembly: ["RightClick"],
    BoundaryConditions: [
        "BoundaryTemperature",
        "Convection",
        "EnforcedLoads",
        "HeatFlux",
        "InitialElementalValue",
        "InitialTemperature",
        "LBCCopy",
        "Pressure",
        "Submodel",
        "TemperatureLoads",
        "LoadCase",
        "InsideHeatGeneration",
        "LbcContactConvert",
        "FieldData",
        "FixedConstraint",
        "DofSet",
        "BodyLoads",
        "Force",
        "InitialNodalValue",
    ],
    Connections: [
        "Pretension",
        "MassElements",
        "BarBeam",
        "Gaps",
        "Plot",
        "CreateConnConm",
        "RBE3",
        "RigidWall",
        "Connector",
        "BoltMeshing_SplitOnly",
        "BoltMeshing_NotSplitOnly",
        "BoltConnections",
        "Contacts",
        "MPC",
        "RigidElements",
        "SpringsDampers",
    ],
    Designer: ["LBC", "Load", "FindContact", "ContactMerge", "Material"],
    EngReliability: ["SubModelBC"],
    ExManifoldModeling: ["SZ"],
    Geometry: [
        "Bar",
        "BodyCut",
        "BreakEntity",
        "DeleteEntity",
        "Edge",
        "Extract",
        "ExtractSurfaces",
        "Face",
        "FindFeature",
        "MergeEntities",
        "Part",
        "ShowAdjacent",
        "Transform",
        "CADTrim",
        "CreateBar",
        "StitchEdge",
        "LogoRemoval",
        "ShellAsm",
        "SquareUpFillet",
        "MakeFillet",
        "MakeFacePlanar",
        "FCircleAdjustVertex",
        "AdjustHalfCylinder",
        "FCircVertexAdjust",
        "RemoveRibBoss",
        "AdvancedShellAssembly",
    ],
    Groups: ["RightClick"],
    HexModeling: [
        "Sweep",
        "SolidElemInterface",
        "BallHexa",
        "BoxMesh",
        "AutoSweep",
        "Circular",
        "FaceToFace",
        "Layer",
        "Linear",
        "FromMidPlane",
        "Curve",
    ],
    Home: [
        "ImportCAD",
        "ImportMesh",
        "Export",
        "ToImage",
        "Find",
        "RectangularCapture",
        "CopyToClipboard",
        "FullScreen",
        "Synchronize",
    ],
    MainWindow: ["RightClick"],
    MeshCleanup: [
        "Element",
        "Face",
        "CorrectModel",
        "CloseHoles",
        "CloseGap",
        "AutoCheck",
        "ManualCheck",
        "ChangeTopology",
        "Cleanup",
        "Manual2D",
        "Manual3D",
    ],
    MeshEdit: [
        "CreateElement",
        "CreateNode",
        "MoveNode",
        "Face",
        "ElementConvert",
        "Deform",
        "MirrorCopy",
        "DeleteNode",
        "FaceImprint",
        "AdjustOrientation",
        "OneNode",
        "SeparateNodes",
        "RefineQuality",
        "Import",
        "RemoveSolidMesh",
        "MeshEditCMPMeshCopy",
        "MeshEditMorphingRibThickness",
        "MergeNodes",
        "MeshCopy",
        "RibThickness",
        "ChangePattern",
        "SurfaceMesh",
        "SolidMesh",
    ],
    Meshing: [
        "CADProjection",
        "LocalMeshing",
        "LocalSetting",
        "Templates",
        "BarMeshing",
        "GridMesh",
        "SolidMeshing",
        "SurfaceMeshing",
        "SetAttib",
        "LocalRemesh",
        "LocalSettings",
    ],
    MidPlane: [
        "AdjustThickness",
        "FaceCross",
        "CreateThickProps",
        "FindMidPlane",
    ],
    MidPlaneEdit: ["Edge", "ExtendFace", "Face", "Manual", "AddItems"],
    MMCCarACTools: ["ACModelCreationTools", "ClearanceElement"],
    MufflerHA: ["CreateEdge", "CreateEdgeClassic", "CopyMeshCount"],
    MufflerT: ["SpecialModeling"],
    MuxWeld: ["CreateWeld", "DefineSequence", "MeshingPass", "Prop3DWeldBead"],
    NSModeling: ["NSModeling_Close_Hole"],
    OasisAWizard: ["LocalMeshing"],
    Post: ["ImportResults"],
    Properties: [
        "ElemRelatedInfo",
        "Material",
        "Section",
        "Cohesive",
        "Gasket",
        "Shell",
        "PropertyTable",
        "Beam",
        "Rod",
        "Property1DBeamSimple",
        "Solid",
        "Section1D",
        "Composite",
        "BAR",
        "ThicknessDistribution",
        "RigidBody",
    ],
    SNOnePush: ["DropTest", "CADImport", "AutoSweepClosedLoopShaped"],
    StiffCalc: ["Force"],
    SZOnepushReliability: ["Assembly", "MeshEdit", "AlignMidNode"],
    Test: [
        "Connection",
        "MeshQuality",
        "Muffler",
        "ZGeometryTest",
        "FindFeatureFillet",
        "FindFacesInPart",
        "CreateElementForWelding",
    ],
    Tool: [
        "Connections",
        "Coordinates",
        "Group",
        "ImprintEdges",
        "ElementCS",
        "Measure",
        "MeshQuality",
    ],
    Toolbar: ["Undo", "Redo"],
    Tools: [
        "BySelection",
        "Group",
        "TotalLoad",
        "NodeCS",
        "NodeCSGroup",
        "DisplacementCS",
        "Connections",
        "GroupByDCS",
        "Renumber",
        "RenumberByConnection",
        "RenumberByFile",
        "ModelInfo",
        "Section",
        "Measure",
    ],
};
exports.map23 = {
    STL: [null],
    AddJTDB: [null],
    Save: [null],
    LoadDB: [null],
    CreateBeadWeld: [null],
    Spatial: [null],
    TechnoStarGeometry: [null],
    CreoDirect: [null],
    Elysium: [null],
    NastranBdf: [null],
    AbaqusINP: [null],
    LSDYNA: [null],
    ADVCADX: [null],
    Universal: [null],
    AnsysDat: [null],
    TSVPre: [null],
    FindEntities: [null],
    MeasureDistanceBy2Edges: [null],
    ACBoundary: ["Method1"],
    Create: ["Convex"],
    CloseHoleAuto: [null],
    Cut: [null],
    AbaqusStep: [
        "DynamicStep",
        "TransientStep",
        "DynamicCoupledTDExplicitStep",
        "CoupledTDStep",
        "DynamicExplicitStep",
        "ModalStep",
        "StaticRiskStep",
        "SteadyStateStep",
    ],
    ACTRAN: ["ExportBdf", "Run", "CreateEdat"],
    Analysis: ["Abaqus", "AbaqusSteadyStateStep", "AbaqusStaticRiskStep"],
    Ansys: [
        "HeadTransferSteady",
        "LinearStatic",
        "NormalModes",
        "Harmonic",
        "Steady",
    ],
    Nastran: [
        "ModalTransientResponse",
        "LinearBuckling",
        "Transient",
        "SteadyState",
        "ModalFrequencyResponse",
        "LinearStatic",
        "NormalModes",
    ],
    Permas: ["Job"],
    TSSolver: [
        "ExportDynamisBdf",
        "Job",
        "LinearBucking",
        "LinearStatic",
        "NonlinearStatic",
        "NormalModes",
        "NonlinearFrequency",
        "ModalTransientResponse",
        "TransientHeatTransfer",
        "ModalFrequencyResponse",
        "SteadyStateHeatTransfer",
    ],
    TSSS: [
        "TransientHeatTransfer",
        "LinearStatic",
        "NonlinearStatic",
        "NormalModes",
        "LinearBuckling",
        "ModalFrequencyResponse",
        "SteadyStateHeatTransfer",
    ],
    Abaqus: [null],
    ExportAnsys: [null],
    ExportAbaqus: [null],
    ModifyLbcToStep: [null],
    ExportAdx: [null],
    ExportLsdyna: [null],
    NastranJob: [null],
    LSDYNAJob: [null],
    ADVC: ["MakeProcess", "Structure", "HeatTransfer"],
    SeparateFaces: ["AllSharedNodes", "Shell", "Solid"],
    Boolean: [null],
    AssembleFace: [null],
    FullLayer: [null],
    CylinderLayer: [null],
    SharedFace: [null],
    AssembleFaces: [null],
    GeneralLayer: [null],
    AddRib: [null],
    FindMatingFace: [null],
    AddBoss: [null],
    RightClick: [
        "AddToReference",
        "Suppress",
        "UnSuppress",
        "RestoreOriginalPart",
        "Rename",
        "ChangeEntityColor",
        "AddSubAssembly",
        "ChangeBodyColor",
        "ChangeMeshLineColor",
        "PropertyGroup",
        "DeleteGroup",
        "CopyGroup",
        "AddSupGroup",
        "CreateMatGroup",
        "MergeFaces",
        "SelectAllParts",
        "AssociatedPick",
        "FlipElement",
    ],
    BoundaryTemperature: ["Constant", "SurfaceMapping"],
    Convection: ["Constant", "SurfaceMapping"],
    EnforcedLoads: ["Acceleration", "Velocity", "Displacement"],
    HeatFlux: ["SurfaceFlux", "SurfaceMapping", "ConcentrateFlux"],
    InitialElementalValue: ["InitialStress"],
    InitialTemperature: ["WholeMapping", "Constant", "ADVC", "NastranPunch"],
    LBCCopy: [
        "PropertiesCopyTranslate",
        "PropertiesCopyRotate",
        "PropertiesCopyMirror",
        "ConnectionCopyTranslate",
        "ConnectionCopyRotate",
        "ConnectionCopyMirror",
        "GroupCopyTranslate",
        "GroupCopyRotate",
        "GroupCopyMirror",
        "LBCCopyTranslate",
        "LBCCopyRotate",
        "LBCCopyMirror",
        null,
    ],
    Pressure: [
        "SurfaceLoads",
        "By2Nodes",
        "General",
        "Quadratic",
        "FunctionLoadToCylinder_Sine",
        "SerfaceMapping",
        "Hydrostatic",
        "SurfaceMapping",
    ],
    Submodel: ["SubmodelForcedFlux", "ForcedTempertature", "ForcedDisplacement"],
    TemperatureLoads: [
        "Constant",
        "ADVCFile",
        "NastranPunch",
        "WholeMapping",
        "LbcInitialTemperature",
    ],
    LoadCase: [null],
    InsideHeatGeneration: [null],
    LbcContactConvert: [null],
    FieldData: [null],
    FixedConstraint: [null],
    DofSet: [null],
    BodyLoads: ["CentrifugalForce", "Gravity"],
    Force: [
        "FunctionLoadCylinder",
        "NonlinearForce",
        "General",
        "FunctionLoadToCylinder_Sine",
        "ForceNormalDirection",
        "FunctionLoadToCylinder_Quadratic",
        null,
    ],
    InitialNodalValue: [
        "InitialAngularVelocity",
        "Displacement",
        "Velocity",
        "RotationAngle",
    ],
    Pretension: ["General", "Abaqus", "Advc"],
    MassElements: [null],
    BarBeam: [null],
    Gaps: [null, "TwoNodes", "TwoEdges", "TwoFaces"],
    Plot: [null],
    CreateConnConm: [null],
    RBE3: [null],
    RigidWall: [null],
    Connector: [null],
    BoltMeshing_SplitOnly: [null],
    BoltMeshing_NotSplitOnly: [null],
    BoltConnections: ["Edge", "Face"],
    Contacts: [
        "Abaqus",
        "ADVC",
        "Ansys",
        "MSCNastran",
        "NXNastran",
        "TSSolver",
        "TSSS",
        "CheckPattern",
        "ExportCheckReport",
    ],
    MPC: ["Equation", "General"],
    RigidElements: ["RBar", "RBE2", "RBE3"],
    SpringsDampers: ["Damper", "Bush", "Spring"],
    LBC: ["Moment", "TemperatureLoad"],
    Load: ["Moment"],
    FindContact: [null],
    ContactMerge: [null],
    Material: [null, "add", "modify", "delete"],
    SubModelBC: [null],
    SZ: ["WeldLine2"],
    Bar: ["TwoNodes", "Arc", "Spline"],
    BodyCut: ["XXYYOnOnePoint", "BySurface", "By3Points"],
    BreakEntity: ["StlPart", "Face", "Edge", "Part"],
    DeleteEntity: ["Part", "Edge", "Face", "Vertex"],
    Edge: [
        "Line",
        "Spline",
        "PlanarLine",
        "Circle",
        "PerpendicularLineOfEdge",
        "ExtendLine",
        "ElementEdges",
        "Angle",
        "NodeShortestPath",
        "OffsetLine",
        "Intersection_Line",
        "Projection_Line",
        "SplineFreeEdges",
        "ClosedLine",
        "PerpendicularCylinderLine",
        "IntersectionLine",
        "ProjectLine",
        "PerpendicularLineToEdge",
        "Nodes",
    ],
    Extract: ["FindFeatureFillet"],
    ExtractSurfaces: ["ExtractRefSurface", "ExtractSurfaces", null],
    Face: [
        "CreateFaceByElem",
        "FourEdges",
        "FromMesh",
        "CreateFaceFromEdges",
        "CreateSmoothFace",
        "Edges",
        "Elements",
        null,
        "FaceExtendtoFace",
        "FaceExtendToIntersection",
        "EdgesToEdges",
    ],
    FindFeature: ["DelCircChamfer", "Fillet", "Faces", "Edges"],
    MergeEntities: [
        "Faces",
        "TinyFacesMerge",
        "CBarParts",
        "Edges",
        "Parts",
        "PartFaces",
    ],
    Part: [
        "Cube",
        "Wedge",
        "Sphere",
        "Torus",
        "Elems",
        "Cylinder",
        "Tube",
        "Trapezoid",
        "Cone",
    ],
    ShowAdjacent: ["Faces", "Elements"],
    Transform: [
        "Rotation",
        "Scaling",
        "Mirror",
        "Position",
        "Translation",
        "MatingFace",
        "CylinderFace",
    ],
    CADTrim: [null],
    CreateBar: [null],
    StitchEdge: [null],
    LogoRemoval: [null],
    ShellAsm: [null],
    SquareUpFillet: [null],
    MakeFillet: [null],
    MakeFacePlanar: [null],
    FCircleAdjustVertex: [null],
    AdjustHalfCylinder: [null],
    FCircVertexAdjust: [null],
    RemoveRibBoss: [null],
    AdvancedShellAssembly: [null],
    Sweep: ["Circular", "FaceToFace", "Layer", "Linear", "Curve", "FromMidPlane"],
    SolidElemInterface: [null],
    BallHexa: [null],
    BoxMesh: [null],
    AutoSweep: [null],
    Circular: [null],
    FaceToFace: [null],
    Layer: [null],
    Linear: [null],
    FromMidPlane: [null],
    Curve: [null],
    ImportCAD: [
        "Elysium",
        "Spatial",
        "Parasolid",
        "STL",
        "VRML",
        "ProECreoDirect",
    ],
    ImportMesh: [
        "ADVCADX",
        "AnsysDat",
        "NastranBdf",
        "AbaqusINP",
        "LSDYNA",
        "Universal",
    ],
    Export: [null],
    ToImage: [null],
    Find: [null],
    RectangularCapture: [null],
    CopyToClipboard: [null],
    FullScreen: [null],
    Synchronize: [null],
    Element: ["SolidElement", "SurfaceElement"],
    CorrectModel: [null],
    CloseHoles: [null],
    CloseGap: [null],
    AutoCheck: [null],
    ManualCheck: [null, "Tri"],
    ChangeTopology: ["Element"],
    Cleanup: ["CloseGap"],
    Manual2D: [
        "MergeElement",
        "SplitElement",
        "Equivalence",
        "DeleteElement",
        "Split",
        "Swap",
        "Collapse",
        "CreateElement",
        "RemeshElement",
    ],
    Manual3D: [
        "Collapse",
        "DeleteNode",
        "Swap",
        "Equivalence",
        "Split",
        "CreateHex",
        "CreatePenta",
        "CreateTetra",
    ],
    CreateElement: ["Hex", "Penta", "Tet", "Tri3", "Quad4", null],
    CreateNode: [
        "CircleCenter",
        "SphereCenter",
        "Absolute",
        "Import",
        "Point",
        "Between2Nodes",
        "Between3Nodes",
        "ProjectToPlane",
        "CreateNodeNodeOffset",
        "CenterOfCylinder",
        "CenterOfSphere",
        "vecOffset",
        "CenterOfGravity",
        "ProjectToLine",
        "IntersectionNode",
    ],
    MoveNode: [
        "Point",
        "ProjectToLine",
        "ProjectToPlaneElem",
        "Equalize",
        "StraightenMidNodes",
        "NormalOffset",
        "CoincidentNodes",
        "AlongCylinder",
        "ProjectToPlane_3Nodes",
        "MoveNodeOffset",
        "Absolute",
        "RefineQuality",
        "StraightenMidnodes",
        "vecOffset",
        "Laplacian",
        "AlongEdge",
        "AlongDirection",
        "CADFollows",
        "Scale",
    ],
    ElementConvert: [null],
    Deform: [null],
    MirrorCopy: [null],
    DeleteNode: [null],
    FaceImprint: [null],
    AdjustOrientation: [null],
    OneNode: [null],
    SeparateNodes: [null],
    RefineQuality: [null],
    Import: [null],
    RemoveSolidMesh: [null],
    MeshEditCMPMeshCopy: [null],
    MeshEditMorphingRibThickness: [null],
    MergeNodes: [null],
    MeshCopy: [null],
    RibThickness: [null],
    ChangePattern: [null],
    SurfaceMesh: [null],
    SolidMesh: [null],
    CADProjection: ["Part", "Face", "FaceToFace", "NodeToFace", "NodeToEdge"],
    LocalMeshing: ["FilletMapping", "SelectFillet", "FilletMapMeshing"],
    LocalSetting: ["SearchTargetFaces"],
    Templates: ["TemplateCopy"],
    BarMeshing: [null],
    GridMesh: [null],
    SolidMeshing: [null],
    SurfaceMeshing: [null],
    SetAttib: [null],
    LocalRemesh: ["Solid", "Surfase"],
    LocalSettings: ["Edge", "Face", "FaceElement", "Model", "Part", "Points"],
    AdjustThickness: [null],
    FaceCross: [null],
    CreateThickProps: [null],
    FindMidPlane: [null],
    ExtendFace: ["CylinderFace", "PlanarFace"],
    Manual: ["vecOffset", "MidByPair"],
    AddItems: ["Edge", "Face"],
    ACModelCreationTools: ["MeshedFace"],
    ClearanceElement: ["Connect", "Edit"],
    CreateEdge: ["PerpendicularLineToEdge"],
    CreateEdgeClassic: ["ProjectLine"],
    CopyMeshCount: [null],
    SpecialModeling: ["Rod"],
    CreateWeld: ["Auto"],
    DefineSequence: ["Single"],
    MeshingPass: [null],
    Prop3DWeldBead: [null],
    NSModeling_Close_Hole: [null],
    ImportResults: [
        "ImportOp2Mesh",
        "NastranOp2PostJob",
        "ImportTsdbMesh",
        "HDF5Mesh",
        "ADVC",
        "ADVC2PostJob",
        "NastranHDF5",
    ],
    ElemRelatedInfo: ["Shell", "Conn", "Rod", "Beam", "Bar", "Gap", "Bush"],
    Section: [
        "Import",
        "SectionDeleteMulti",
        "Modify_General",
        "Modify_Library",
        "Modify_Sketcher",
        "Export",
        "Delete",
        "Add_General",
        "Add_Library",
        "Add_Sketcher",
        null,
    ],
    Cohesive: [null],
    Gasket: [null],
    Shell: [null],
    PropertyTable: [null],
    Beam: [null],
    Rod: [null],
    Property1DBeamSimple: [null],
    Solid: [null],
    Section1D: [null],
    Composite: [null],
    BAR: [null],
    ThicknessDistribution: [null],
    RigidBody: [null],
    DropTest: ["CalcTimestep", "UpdateFloor", "DropRotation", null],
    CADImport: [null],
    AutoSweepClosedLoopShaped: [null],
    Assembly: ["CreateWeld", "ContactSurface"],
    MeshEdit: ["FilletMapping"],
    AlignMidNode: [null],
    Connection: ["RRod"],
    MeshQuality: ["MeshQualityCheck", "Manual"],
    Muffler: ["ProjectLineForWeld"],
    ZGeometryTest: ["IntersectionCheck", "ShellAssy"],
    FindFeatureFillet: [null],
    FindFacesInPart: [null],
    CreateElementForWelding: [null],
    Connections: ["Contact", "Spring", "RBE3", "Mass", null],
    Coordinates: [
        "CylinderFace",
        "ThreeNode",
        "Align",
        "vecOffset",
        "Rotate",
        "AttachCircle",
        "AttachNode",
        "Face",
    ],
    Group: ["CreateGroup", "DeleteGroupEntity", null],
    ImprintEdges: ["Line", "ClosedLine", "ClosedLine2"],
    ElementCS: [null],
    Measure: ["Angle", "Distance", "Mass", "Radius", "Volume", "Area"],
    Undo: [null],
    Redo: [null],
    BySelection: ["SelectionOrder", "Position", "OriginalID"],
    TotalLoad: ["LBC", "Model", "Node", "Part", "Face"],
    NodeCS: [null],
    NodeCSGroup: [null],
    DisplacementCS: [null],
    GroupByDCS: [null],
    Renumber: [null],
    RenumberByConnection: [null],
    RenumberByFile: [null],
    ModelInfo: [null],
};
exports.root3 = [
    "Method1",
    "Convex",
    "DynamicStep",
    "TransientStep",
    "DynamicCoupledTDExplicitStep",
    "CoupledTDStep",
    "DynamicExplicitStep",
    "ModalStep",
    "StaticRiskStep",
    "SteadyStateStep",
    "ExportBdf",
    "Run",
    "CreateEdat",
    "Abaqus",
    "AbaqusSteadyStateStep",
    "AbaqusStaticRiskStep",
    "HeadTransferSteady",
    "LinearStatic",
    "NormalModes",
    "Harmonic",
    "Steady",
    "ModalTransientResponse",
    "LinearBuckling",
    "Transient",
    "SteadyState",
    "ModalFrequencyResponse",
    "Job",
    "ExportDynamisBdf",
    "LinearBucking",
    "NonlinearStatic",
    "NonlinearFrequency",
    "TransientHeatTransfer",
    "SteadyStateHeatTransfer",
    "MakeProcess",
    "Structure",
    "HeatTransfer",
    "AllSharedNodes",
    "Shell",
    "Solid",
    "AddToReference",
    "Suppress",
    "UnSuppress",
    "RestoreOriginalPart",
    "Rename",
    "ChangeEntityColor",
    "AddSubAssembly",
    "ChangeBodyColor",
    "ChangeMeshLineColor",
    "Constant",
    "SurfaceMapping",
    "Acceleration",
    "Velocity",
    "Displacement",
    "SurfaceFlux",
    "ConcentrateFlux",
    "InitialStress",
    "WholeMapping",
    "ADVC",
    "NastranPunch",
    "PropertiesCopyTranslate",
    "PropertiesCopyRotate",
    "PropertiesCopyMirror",
    "ConnectionCopyTranslate",
    "ConnectionCopyRotate",
    "ConnectionCopyMirror",
    "GroupCopyTranslate",
    "GroupCopyRotate",
    "GroupCopyMirror",
    "LBCCopyTranslate",
    "LBCCopyRotate",
    "LBCCopyMirror",
    "SurfaceLoads",
    "By2Nodes",
    "General",
    "Quadratic",
    "FunctionLoadToCylinder_Sine",
    "SerfaceMapping",
    "Hydrostatic",
    "SubmodelForcedFlux",
    "ForcedTempertature",
    "ForcedDisplacement",
    "ADVCFile",
    "LbcInitialTemperature",
    "CentrifugalForce",
    "Gravity",
    "FunctionLoadCylinder",
    "NonlinearForce",
    "ForceNormalDirection",
    "FunctionLoadToCylinder_Quadratic",
    "InitialAngularVelocity",
    "RotationAngle",
    "Advc",
    "Edge",
    "Face",
    "Ansys",
    "MSCNastran",
    "NXNastran",
    "TSSolver",
    "TSSS",
    "CheckPattern",
    "ExportCheckReport",
    "TwoNodes",
    "TwoEdges",
    "TwoFaces",
    "Equation",
    "RBar",
    "RBE2",
    "RBE3",
    "Damper",
    "Bush",
    "Spring",
    "Moment",
    "TemperatureLoad",
    "WeldLine2",
    "Arc",
    "Spline",
    "XXYYOnOnePoint",
    "BySurface",
    "By3Points",
    "StlPart",
    "Part",
    "Vertex",
    "Line",
    "PlanarLine",
    "Circle",
    "PerpendicularLineOfEdge",
    "ExtendLine",
    "ElementEdges",
    "Angle",
    "NodeShortestPath",
    "OffsetLine",
    "Intersection_Line",
    "Projection_Line",
    "SplineFreeEdges",
    "ClosedLine",
    "PerpendicularCylinderLine",
    "IntersectionLine",
    "ProjectLine",
    "PerpendicularLineToEdge",
    "FindFeatureFillet",
    "ExtractRefSurface",
    "ExtractSurfaces",
    "CreateFaceByElem",
    "FourEdges",
    "FromMesh",
    "CreateFaceFromEdges",
    "CreateSmoothFace",
    "Edges",
    "Elements",
    "DelCircChamfer",
    "Fillet",
    "Faces",
    "TinyFacesMerge",
    "CBarParts",
    "Parts",
    "PartFaces",
    "Cube",
    "Wedge",
    "Sphere",
    "Torus",
    "Elems",
    "Cylinder",
    "Tube",
    "Trapezoid",
    "Cone",
    "Rotation",
    "Scaling",
    "Mirror",
    "Position",
    "Translation",
    "MatingFace",
    "CylinderFace",
    "PropertyGroup",
    "DeleteGroup",
    "CopyGroup",
    "AddSupGroup",
    "CreateMatGroup",
    "Circular",
    "FaceToFace",
    "Layer",
    "Linear",
    "Curve",
    "FromMidPlane",
    "Elysium",
    "Spatial",
    "Parasolid",
    "STL",
    "VRML",
    "ProECreoDirect",
    "ADVCADX",
    "AnsysDat",
    "NastranBdf",
    "AbaqusINP",
    "LSDYNA",
    "Universal",
    "MergeFaces",
    "SelectAllParts",
    "AssociatedPick",
    "FlipElement",
    "SolidElement",
    "SurfaceElement",
    "Element",
    "CloseGap",
    "MergeElement",
    "SplitElement",
    "Equivalence",
    "DeleteElement",
    "Split",
    "Swap",
    "Collapse",
    "CreateElement",
    "RemeshElement",
    "DeleteNode",
    "CreateHex",
    "CreatePenta",
    "CreateTetra",
    "Tri",
    "Hex",
    "Penta",
    "Tet",
    "Tri3",
    "Quad4",
    "CircleCenter",
    "SphereCenter",
    "Absolute",
    "Import",
    "Point",
    "Between2Nodes",
    "Between3Nodes",
    "ProjectToPlane",
    "CreateNodeNodeOffset",
    "CenterOfCylinder",
    "CenterOfSphere",
    "vecOffset",
    "CenterOfGravity",
    "ProjectToLine",
    "IntersectionNode",
    "ProjectToPlaneElem",
    "Equalize",
    "StraightenMidNodes",
    "NormalOffset",
    "CoincidentNodes",
    "AlongCylinder",
    "ProjectToPlane_3Nodes",
    "MoveNodeOffset",
    "RefineQuality",
    "StraightenMidnodes",
    "Laplacian",
    "AlongEdge",
    "AlongDirection",
    "CADFollows",
    "Scale",
    "NodeToFace",
    "NodeToEdge",
    "FilletMapping",
    "SelectFillet",
    "SearchTargetFaces",
    "TemplateCopy",
    "Surfase",
    "FaceElement",
    "Model",
    "Points",
    "Nodes",
    "PlanarFace",
    "FaceExtendtoFace",
    "FaceExtendToIntersection",
    "EdgesToEdges",
    "MidByPair",
    "MeshedFace",
    "Connect",
    "Edit",
    "Rod",
    "Auto",
    "Single",
    "FilletMapMeshing",
    "ImportOp2Mesh",
    "NastranOp2PostJob",
    "ImportTsdbMesh",
    "HDF5Mesh",
    "ADVC2PostJob",
    "NastranHDF5",
    "Conn",
    "Beam",
    "Bar",
    "Gap",
    "add",
    "modify",
    "delete",
    "SectionDeleteMulti",
    "Modify_General",
    "Modify_Library",
    "Modify_Sketcher",
    "Export",
    "Delete",
    "Add_General",
    "Add_Library",
    "Add_Sketcher",
    "CalcTimestep",
    "UpdateFloor",
    "DropRotation",
    "CreateWeld",
    "ContactSurface",
    "RRod",
    "MeshQualityCheck",
    "ProjectLineForWeld",
    "IntersectionCheck",
    "ShellAssy",
    "Contact",
    "Mass",
    "ThreeNode",
    "Align",
    "Rotate",
    "AttachCircle",
    "AttachNode",
    "CreateGroup",
    "DeleteGroupEntity",
    "ClosedLine2",
    "Distance",
    "Radius",
    "Volume",
    "Manual",
    "SelectionOrder",
    "OriginalID",
    "LBC",
    "Node",
    "Area",
];
exports.map34 = {
    undefined: [null],
    Method1: [null],
    Convex: [null],
    DynamicStep: [null],
    TransientStep: [null],
    DynamicCoupledTDExplicitStep: [null],
    CoupledTDStep: [null],
    DynamicExplicitStep: [null],
    ModalStep: [null],
    StaticRiskStep: [null],
    SteadyStateStep: [null],
    ExportBdf: [null],
    Run: [null],
    CreateEdat: [null],
    Abaqus: [
        null,
        "ContactTable",
        "ManualGroup",
        "ManualFace",
        "ContactGroupByMatrix",
        "ContactShareFace",
    ],
    AbaqusSteadyStateStep: [null],
    AbaqusStaticRiskStep: [null],
    HeadTransferSteady: [null],
    LinearStatic: [null],
    NormalModes: [null],
    Harmonic: [null],
    Steady: [null],
    ModalTransientResponse: [null],
    LinearBuckling: [null],
    Transient: [null],
    SteadyState: [null],
    ModalFrequencyResponse: [null],
    Job: [null],
    ExportDynamisBdf: [null],
    LinearBucking: [null],
    NonlinearStatic: [null],
    NonlinearFrequency: [null],
    TransientHeatTransfer: [null],
    SteadyStateHeatTransfer: [null],
    MakeProcess: [
        "Static",
        "Creep",
        "Dynamic",
        "EigenValue",
        "DynamicExplicit",
        "ModalFreqResp",
        "ResponseSpectrum",
        "SteadyState",
        "Transient",
        "Fatigue",
        "RandomResponse",
    ],
    Structure: [null],
    HeatTransfer: [null],
    AllSharedNodes: [null],
    Shell: [null],
    Solid: [null],
    AddToReference: [null],
    Suppress: [null],
    UnSuppress: [null],
    RestoreOriginalPart: [null],
    Rename: [null],
    ChangeEntityColor: [null],
    AddSubAssembly: [null],
    ChangeBodyColor: [null],
    ChangeMeshLineColor: [null],
    Constant: [null],
    SurfaceMapping: [null],
    Acceleration: [null],
    Velocity: [null],
    Displacement: [null],
    SurfaceFlux: [null],
    ConcentrateFlux: [null],
    InitialStress: [null],
    WholeMapping: [null],
    ADVC: [
        null,
        "ContactClearance",
        "ManualGroup",
        "ManualFace",
        "Contact",
        "ContactShareFace",
        "ContactTable",
        "ContactGroupByMatrix",
    ],
    NastranPunch: [null],
    PropertiesCopyTranslate: [null],
    PropertiesCopyRotate: [null],
    PropertiesCopyMirror: [null],
    ConnectionCopyTranslate: [null],
    ConnectionCopyRotate: [null],
    ConnectionCopyMirror: [null],
    GroupCopyTranslate: [null],
    GroupCopyRotate: [null],
    GroupCopyMirror: [null],
    LBCCopyTranslate: [null],
    LBCCopyRotate: [null],
    LBCCopyMirror: [null],
    SurfaceLoads: [null],
    By2Nodes: [null],
    General: [
        null,
        "NodeToNode",
        "NodeToEdges",
        "NodeToFaces",
        "TwoEdges",
        "FacesToFaces",
        "NodesToNodes",
        "TwoFaces",
        "NodeToAny",
        "NodesWithTolerance",
    ],
    Quadratic: [null],
    FunctionLoadToCylinder_Sine: [null],
    SerfaceMapping: [null],
    Hydrostatic: [null],
    SubmodelForcedFlux: [null],
    ForcedTempertature: [null],
    ForcedDisplacement: [null],
    ADVCFile: [null],
    LbcInitialTemperature: [null],
    CentrifugalForce: ["CoordinateSystems", "TwoPositions"],
    Gravity: [null],
    FunctionLoadCylinder: ["Quadratic", "Sine", "Vector"],
    NonlinearForce: ["NOLIN3", "NOLIN4", "NOLIN1"],
    ForceNormalDirection: [null],
    FunctionLoadToCylinder_Quadratic: [null],
    InitialAngularVelocity: ["Abaqus", "General"],
    RotationAngle: [null],
    Advc: [null],
    Edge: [
        "TypeC",
        "TypeB",
        "TypeD",
        "TypeA",
        null,
        "ProjectEdgeToFace",
        "FaceTwoFace",
    ],
    Face: ["TypeC", "TypeB", "TypeA", null, "EFExtendFreeEdge", "EFProject"],
    Ansys: [
        "ManualGroup",
        "ManualFace",
        "ContactGroupByMatrix",
        "ContactShareFace",
        "ContactTable",
        null,
    ],
    MSCNastran: [
        "ManualGroup",
        "ContactGroupByMatrix",
        "ManualFace",
        "ContactShareFace",
        "ContactTable",
    ],
    NXNastran: [
        "ManualFace",
        "ContactShareFace",
        "ContactTable",
        "ManualGroup",
        "ContactGroupByMatrix",
        null,
    ],
    TSSolver: ["ManualFace", "Auto", "ManualGroup"],
    TSSS: ["ManualFace", "ManualGroup", "ContactTable"],
    CheckPattern: [null],
    ExportCheckReport: [null],
    TwoNodes: [null],
    TwoEdges: [null],
    TwoFaces: [null],
    Equation: ["MultiNodes", "TwoFace", "SemiAuto"],
    RBar: ["OneToOne", "OneToMany", "OneToOneNodesWithTolerance", null],
    RBE2: [
        "OneToMany",
        "OneToOne",
        "OneToOneNodesWithTolerance",
        "ToCenter",
        "ToCircleCenter",
        null,
    ],
    RBE3: ["OneToMany", "OneToOne", "ToCenter", "ToCircleCenter", null],
    Damper: ["AnyEntities11DoFS"],
    Bush: [null, "TwoNodes", "AnyEntities", "OnetoOne"],
    Spring: ["GroundedSpring", "Nodeswithtolerance", "OneToOne", null],
    Moment: [null],
    TemperatureLoad: [null],
    WeldLine2: [null],
    Arc: [null],
    Spline: [null],
    XXYYOnOnePoint: [null],
    BySurface: [null],
    By3Points: [null],
    StlPart: [null],
    Part: [null],
    Vertex: [null],
    Line: [null],
    PlanarLine: [null],
    Circle: [null],
    PerpendicularLineOfEdge: [null],
    ExtendLine: [null],
    ElementEdges: [null],
    Angle: [
        null,
        "ProjectedNode",
        "TwoNodesAxis",
        "By2Axis",
        "ThreeNodes",
        "TwoElemEdges",
        "TwoAxis",
        "TwoEdges",
    ],
    NodeShortestPath: [null],
    OffsetLine: [null],
    Intersection_Line: [null],
    Projection_Line: [null],
    SplineFreeEdges: [null],
    ClosedLine: [null],
    PerpendicularCylinderLine: [null],
    IntersectionLine: [null],
    ProjectLine: [null],
    PerpendicularLineToEdge: [null],
    FindFeatureFillet: [null],
    ExtractRefSurface: [null],
    ExtractSurfaces: [null],
    CreateFaceByElem: [null],
    FourEdges: [null],
    FromMesh: [null],
    CreateFaceFromEdges: [null],
    CreateSmoothFace: [null],
    Edges: [null],
    Elements: [null],
    DelCircChamfer: [null],
    Fillet: [null],
    Faces: [null],
    TinyFacesMerge: [null],
    CBarParts: [null],
    Parts: [null],
    PartFaces: [null],
    Cube: [null],
    Wedge: [null],
    Sphere: [null],
    Torus: [null],
    Elems: [null],
    Cylinder: [null],
    Tube: [null],
    Trapezoid: [null],
    Cone: [null],
    Rotation: [null],
    Scaling: [null],
    Mirror: [null],
    Position: [null],
    Translation: [null],
    MatingFace: [null],
    CylinderFace: [null],
    PropertyGroup: [null],
    DeleteGroup: [null],
    CopyGroup: [null],
    AddSupGroup: [null],
    CreateMatGroup: [null],
    Circular: [null],
    FaceToFace: [null],
    Layer: [null],
    Linear: [null],
    Curve: [null],
    FromMidPlane: [null],
    Elysium: [null],
    Spatial: [null],
    Parasolid: [null],
    STL: [null],
    VRML: [null],
    ProECreoDirect: [null],
    ADVCADX: [null],
    AnsysDat: [null],
    NastranBdf: [null],
    AbaqusINP: [null],
    LSDYNA: [null],
    Universal: [null],
    MergeFaces: [null],
    SelectAllParts: [null],
    AssociatedPick: [null],
    FlipElement: [null],
    SolidElement: [null],
    SurfaceElement: [null],
    Element: ["SurfaceElement"],
    CloseGap: [null],
    MergeElement: ["TwoQuadsToQuad", "TwoTrisToQuad"],
    SplitElement: [
        "QuadTo4Quads",
        "QuadToTrans4Quads",
        "QuadToTrans3Quads",
        "QuadTo2Quads1Tri",
        "QuadTo3Tris",
        "QuadTo2Quads",
        "QuadTo2Tris",
        "QuadToQuadTri",
        "QuadTo4Tris",
        null,
    ],
    Equivalence: [null],
    DeleteElement: [null],
    Split: [null],
    Swap: [null],
    Collapse: [null, "CenterFaceCollapse", "HalfEdgeCollapse", "EdgeCollapse"],
    CreateElement: [null],
    RemeshElement: [null],
    DeleteNode: [null],
    CreateHex: [null],
    CreatePenta: [null],
    CreateTetra: [null],
    Tri: [null],
    Hex: [null],
    Penta: [null],
    Tet: [null],
    Tri3: [null],
    Quad4: [null],
    CircleCenter: [null],
    SphereCenter: [null],
    Absolute: [null],
    Import: [null],
    Point: [null],
    Between2Nodes: [null],
    Between3Nodes: [null],
    ProjectToPlane: [null],
    CreateNodeNodeOffset: [null],
    CenterOfCylinder: [null],
    CenterOfSphere: [null],
    vecOffset: [null],
    CenterOfGravity: [null],
    ProjectToLine: [null],
    IntersectionNode: [null],
    ProjectToPlaneElem: [null],
    Equalize: [null],
    StraightenMidNodes: [null],
    NormalOffset: [null],
    CoincidentNodes: [null],
    AlongCylinder: [null],
    ProjectToPlane_3Nodes: [null],
    MoveNodeOffset: [null],
    RefineQuality: [null],
    StraightenMidnodes: [null],
    Laplacian: [null],
    AlongEdge: [null],
    AlongDirection: [null],
    CADFollows: [null],
    Scale: [null],
    NodeToFace: [null],
    NodeToEdge: [null],
    FilletMapping: [null],
    SelectFillet: [null],
    SearchTargetFaces: [null],
    TemplateCopy: [null],
    Surfase: [null],
    FaceElement: [null],
    Model: [null],
    Points: [null],
    Nodes: [null],
    PlanarFace: [null],
    FaceExtendtoFace: [null],
    FaceExtendToIntersection: [null],
    EdgesToEdges: [null],
    MidByPair: [null],
    MeshedFace: [null],
    Connect: [null],
    Edit: [null],
    Rod: ["Rod", null],
    Auto: [null],
    Single: [null],
    FilletMapMeshing: [null],
    ImportOp2Mesh: [null],
    NastranOp2PostJob: [null],
    ImportTsdbMesh: [null],
    HDF5Mesh: [null],
    ADVC2PostJob: [null],
    NastranHDF5: [null],
    Conn: [null],
    Beam: [null],
    Bar: [null],
    Gap: [null],
    add: [null],
    modify: [null],
    delete: [null],
    SectionDeleteMulti: [null],
    Modify_General: [null],
    Modify_Library: [null],
    Modify_Sketcher: [null],
    Export: [null],
    Delete: [null],
    Add_General: [null],
    Add_Library: [null],
    Add_Sketcher: [null],
    CalcTimestep: [null],
    UpdateFloor: [null],
    DropRotation: [null],
    CreateWeld: [null],
    ContactSurface: [null],
    RRod: [null],
    MeshQualityCheck: [null],
    ProjectLineForWeld: [null],
    IntersectionCheck: [null],
    ShellAssy: [null],
    Contact: [null],
    Mass: [null, "ByMaterial", "Property", "Material"],
    ThreeNode: [null],
    Align: [null],
    Rotate: [null],
    AttachCircle: [null],
    AttachNode: [null],
    CreateGroup: [null],
    DeleteGroupEntity: [null],
    ClosedLine2: [null],
    Distance: [
        "Edge",
        "EdgeNode",
        "TwoPoints",
        "LineNode",
        "Plane3NodesToNode",
        "TwoEdges",
        "PlaneElemToNode",
        "TwoNodes",
        "FaceNode",
    ],
    Radius: ["ByThreeNodes", "MeasureRadiusBy3Nodes", "Edge", "ThreeNodes"],
    Volume: [null],
    Manual: ["CleanTetCollapse", "CleaningVolumeMesh"],
    SelectionOrder: [null],
    OriginalID: [null],
    LBC: [null],
    Node: [null],
    Area: ["Element", "Face", "Body"],
};
exports.root4 = [
    "Static",
    "Creep",
    "Dynamic",
    "EigenValue",
    "DynamicExplicit",
    "ModalFreqResp",
    "ResponseSpectrum",
    "SteadyState",
    "Transient",
    "Fatigue",
    "RandomResponse",
    "CoordinateSystems",
    "TwoPositions",
    "Quadratic",
    "Sine",
    "Vector",
    "NOLIN3",
    "NOLIN4",
    "NOLIN1",
    "Abaqus",
    "General",
    "TypeC",
    "TypeB",
    "TypeD",
    "TypeA",
    "ContactTable",
    "ManualGroup",
    "ManualFace",
    "ContactGroupByMatrix",
    "ContactShareFace",
    "ContactClearance",
    "Contact",
    "Auto",
    "MultiNodes",
    "TwoFace",
    "SemiAuto",
    "NodeToNode",
    "NodeToEdges",
    "NodeToFaces",
    "TwoEdges",
    "FacesToFaces",
    "NodesToNodes",
    "TwoFaces",
    "NodeToAny",
    "NodesWithTolerance",
    "OneToOne",
    "OneToMany",
    "OneToOneNodesWithTolerance",
    "ToCenter",
    "ToCircleCenter",
    "AnyEntities11DoFS",
    "TwoNodes",
    "AnyEntities",
    "OnetoOne",
    "GroundedSpring",
    "Nodeswithtolerance",
    "SurfaceElement",
    "TwoQuadsToQuad",
    "TwoTrisToQuad",
    "QuadTo4Quads",
    "QuadToTrans4Quads",
    "QuadToTrans3Quads",
    "QuadTo2Quads1Tri",
    "QuadTo3Tris",
    "QuadTo2Quads",
    "QuadTo2Tris",
    "QuadToQuadTri",
    "QuadTo4Tris",
    "CenterFaceCollapse",
    "HalfEdgeCollapse",
    "EdgeCollapse",
    "ProjectEdgeToFace",
    "FaceTwoFace",
    "EFExtendFreeEdge",
    "EFProject",
    "Rod",
    "ProjectedNode",
    "TwoNodesAxis",
    "By2Axis",
    "Edge",
    "EdgeNode",
    "TwoPoints",
    "LineNode",
    "Plane3NodesToNode",
    "PlaneElemToNode",
    "FaceNode",
    "ByMaterial",
    "ByThreeNodes",
    "MeasureRadiusBy3Nodes",
    "CleanTetCollapse",
    "CleaningVolumeMesh",
    "ThreeNodes",
    "TwoElemEdges",
    "TwoAxis",
    "Element",
    "Face",
    "Body",
    "Property",
    "Material",
];
exports.map45 = {
    undefined: [null],
    Static: [null],
    Creep: [null],
    Dynamic: [null],
    EigenValue: [null],
    DynamicExplicit: [null],
    ModalFreqResp: [null],
    ResponseSpectrum: [null],
    SteadyState: [null],
    Transient: [null],
    Fatigue: [null],
    RandomResponse: [null],
    CoordinateSystems: [null],
    TwoPositions: [null],
    Quadratic: [null],
    Sine: [null],
    Vector: [null],
    NOLIN3: [null],
    NOLIN4: [null],
    NOLIN1: [null],
    Abaqus: [null],
    General: [null],
    TypeC: [null],
    TypeB: [null],
    TypeD: [null],
    TypeA: [null],
    ContactTable: [null],
    ManualGroup: [null],
    ManualFace: [null],
    ContactGroupByMatrix: [null],
    ContactShareFace: [null],
    ContactClearance: [null],
    Contact: [null],
    Auto: [null],
    MultiNodes: [null],
    TwoFace: [null],
    SemiAuto: [null],
    NodeToNode: [null],
    NodeToEdges: [null],
    NodeToFaces: [null],
    TwoEdges: [null],
    FacesToFaces: [null],
    NodesToNodes: [null],
    TwoFaces: [null],
    NodeToAny: [null],
    NodesWithTolerance: [null],
    OneToOne: [null, "sameDoFs", "differentDoFs"],
    OneToMany: [null],
    OneToOneNodesWithTolerance: [null],
    ToCenter: [null],
    ToCircleCenter: [null],
    AnyEntities11DoFS: [null],
    TwoNodes: [null],
    AnyEntities: [null],
    OnetoOne: [null],
    GroundedSpring: [null],
    Nodeswithtolerance: ["sameDoFs", "differentDoFs"],
    SurfaceElement: [null],
    TwoQuadsToQuad: [null],
    TwoTrisToQuad: [null],
    QuadTo4Quads: [null],
    QuadToTrans4Quads: [null],
    QuadToTrans3Quads: [null],
    QuadTo2Quads1Tri: [null],
    QuadTo3Tris: [null],
    QuadTo2Quads: [null],
    QuadTo2Tris: [null],
    QuadToQuadTri: [null],
    QuadTo4Tris: [null],
    CenterFaceCollapse: [null],
    HalfEdgeCollapse: [null],
    EdgeCollapse: [null],
    ProjectEdgeToFace: [null],
    FaceTwoFace: [null],
    EFExtendFreeEdge: [null],
    EFProject: [null],
    Rod: [null],
    ProjectedNode: [null],
    TwoNodesAxis: [null],
    By2Axis: [null],
    Edge: [null],
    EdgeNode: [null],
    TwoPoints: [null],
    LineNode: [null],
    Plane3NodesToNode: [null],
    PlaneElemToNode: [null],
    FaceNode: [null],
    ByMaterial: [null],
    ByThreeNodes: [null],
    MeasureRadiusBy3Nodes: [null],
    CleanTetCollapse: [null],
    CleaningVolumeMesh: [null],
    ThreeNodes: [null],
    TwoElemEdges: [null],
    TwoAxis: [null],
    Element: [null],
    Face: [null],
    Body: [null],
    Property: [null],
    Material: [null],
};
exports.callTips = {
    "FileMenu.AddJTDB": {
        prefix: "AddJTDB",
        text: "*Name:* FileMenu.AddJTDB  \n*Desc:* add jtdb into model  \n *Arg1:* strFileName (String)  \n *Arg2:* strMethod (String)  \n *Arg3:* strTargetModel (String)  \n *Arg4:* strOption (String)  \n *Arg5:* iInputNode (Integer)  \n *Arg6:* iInputElem (Integer)  \n *Arg7:* iInputPart (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "FileMenu.Save": {
        prefix: "Save",
        text: "*Name:* FileMenu.Save  \n*Desc:* Save file JTDB  \n *Arg1:* strFileName (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "FileMenu.Open": {
        prefix: "Open",
        text: "*Name:* FileMenu.Open  \n*Desc:* Load JTDB file  \n *Arg1:* strFileName (String)  \n *Arg2:* bUseTmpTable (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Utility.FindEntities": {
        prefix: "FindEntities",
        text: "*Name:* Utility.FindEntities  \n*Desc:* Search entity by ID, Name ...etc  \n *Arg1:* strTarget (String)  \n *Arg2:* strFindType (String)  \n *Arg3:* bFindMatch (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* crEdgeFirst (Cursor)  \n *Arg2:* crEdgeLast (Cursor)  \n *Arg3:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "ACModeling.ACBoundary.FirstMethod": {
        prefix: "FirstMethod",
        text: "*Name:* ACModeling.ACBoundary.FirstMethod  \n*Desc:* Unknown Description  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* bIsMergePart (Boolean)  \n *Arg3:* bIsRenumber (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "ACModeling.Create.Convex": {
        prefix: "Convex",
        text: "*Name:* ACModeling.Create.Convex  \n*Desc:* Create Convex In Boundary  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* dMeshSize (Double)  \n *Arg3:* dOffset (Double)  \n *Arg4:* dRadius (Double)  \n *Arg5:* iDAxisGround (Integer)  \n *Arg6:* dScale (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "ACModeling.CloseHoleAuto": {
        prefix: "CloseHoleAuto",
        text: "*Name:* ACModeling.CloseHoleAuto  \n*Desc:* ACModeling CloseHoleAuto  \n *Arg1:* crlClosedHoleParts (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "ACModeling.Cut": {
        prefix: "Cut",
        text: "*Name:* ACModeling.Cut  \n*Desc:* cut for ACModeling  \n *Arg1:* crlPart (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.AbaqusStep.DynamicStep": {
        prefix: "DynamicStep",
        text: "*Name:* Analysis.AbaqusStep.DynamicStep  \n*Desc:* Unknown Description  \n *Arg1:* abaqusDynamic (ABAQUS_DYNAMIC)  \n *Arg2:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.AbaqusStep.TransientStep": {
        prefix: "TransientStep",
        text: "*Name:* Analysis.AbaqusStep.TransientStep  \n*Desc:*   \n *Arg1:* strName (String)  \n *Arg2:* strDesp (String)  \n *Arg3:* iEnableAutomatic (Integer)  \n *Arg4:* iMaxInc (Integer)  \n *Arg5:* dInitSize (Double)  \n *Arg6:* dMinSize (Double)  \n *Arg7:* dMaxSize (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.AbaqusStep.CoupledTDStep": {
        prefix: "CoupledTDStep",
        text: "*Name:* Analysis.AbaqusStep.CoupledTDStep  \n*Desc:* create abaqus step of coupled Temp-Displacement  \n *Arg1:* strName (String)  \n *Arg2:* strDesp (String)  \n *Arg3:* iEnableAutomatic (Integer)  \n *Arg4:* iMaxInc (Integer)  \n *Arg5:* dInitSize (Double)  \n *Arg6:* dMinSize (Double)  \n *Arg7:* dMaxSize (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.AbaqusStep.DynamicExplicitStep": {
        prefix: "DynamicExplicitStep",
        text: "*Name:* Analysis.AbaqusStep.DynamicExplicitStep  \n*Desc:* create abaqus step of dynamic explicit  \n *Arg1:* strName (String)  \n *Arg2:* strDesp (String)  \n *Arg3:* iEnableAutomatic (Integer)  \n *Arg4:* iIncrmtEstimator (Integer)  \n *Arg5:* abaqusPair1 (ABAQUS_PAIR1)  \n *Arg6:* dTimeScalfactor (Double)  \n *Arg7:* abaqusPair2 (ABAQUS_PAIR2)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.AbaqusStep.ModalStep": {
        prefix: "ModalStep",
        text: "*Name:* Analysis.AbaqusStep.ModalStep  \n*Desc:*   \n *Arg1:* strName (String)  \n *Arg2:* strDesp (String)  \n *Arg3:* iEigenSolver (Integer)  \n *Arg4:* iNFreqRequestbchecked (Integer)  \n *Arg5:* ilNFreqRequestTList (Integer List)  \n *Arg6:* iFreqShiftbchecked (Integer)  \n *Arg7:* ilFreqShiftTList (Integer List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.AbaqusStep.StaticRiskStep": {
        prefix: "StaticRiskStep",
        text: "*Name:* Analysis.AbaqusStep.StaticRiskStep  \n*Desc:* Abaqus Static Risk Step  \n *Arg1:* strName (String)  \n *Arg2:* strDesp (String)  \n *Arg3:* iEnableAutomatic (Integer)  \n *Arg4:* iMaxInc (Integer)  \n *Arg5:* dInitSize (Double)  \n *Arg6:* dMinSize (Double)  \n *Arg7:* dMaxSize (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.AbaqusStep.SteadyStateStep": {
        prefix: "SteadyStateStep",
        text: "*Name:* Analysis.AbaqusStep.SteadyStateStep  \n*Desc:* Abaqus Steady State Step  \n *Arg1:* strName (String)  \n *Arg2:* strDesp (String)  \n *Arg3:* iEnableAutomatic (Integer)  \n *Arg4:* iMaxInc (Integer)  \n *Arg5:* iNitSize (Integer)  \n *Arg6:* dMinSize (Double)  \n *Arg7:* dMaxSize (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ACTRAN.ExportBdf": {
        prefix: "ExportBdf",
        text: "*Name:* Analysis.ACTRAN.ExportBdf  \n*Desc:*   \n *Arg1:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ACTRAN.Run": {
        prefix: "Run",
        text: "*Name:* Analysis.ACTRAN.Run  \n*Desc:* Unknown Description  \n *Arg1:* actranAnalysis (ACTRAN_ANALYSIS)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ACTRAN.CreateEdat": {
        prefix: "CreateEdat",
        text: "*Name:* Analysis.ACTRAN.CreateEdat  \n*Desc:* Unknown Description  \n *Arg1:* actranAnalysis (ACTRAN_ANALYSIS)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Analysis.Abaqus": {
        prefix: "Abaqus",
        text: "*Name:* Analysis.Analysis.Abaqus  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* bRBE2toMPC (Boolean)  \n *Arg3:* bRenameProcess (Boolean)  \n *Arg4:* iCodeType (Integer)  \n *Arg5:* iSurfDefType (Integer)  \n *Arg6:* iUnit (Integer)  \n *Arg7:* iWriteType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Ansys.HeadTransferSteady": {
        prefix: "HeadTransferSteady",
        text: "*Name:* Analysis.Ansys.HeadTransferSteady  \n*Desc:* Set parameters  \n *Arg1:* strName (String)  \n *Arg2:* iJobdataAnatype (Integer)  \n *Arg3:* iJobdataSoltype (Integer)  \n *Arg4:* strJobdataJobname (String)  \n *Arg5:* strJobdataJobdescription (String)  \n *Arg6:* bBasicdataBoutputdisplacements (Boolean)  \n *Arg7:* bBasicdataBoutputreactionload (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Ansys.LinearStatic": {
        prefix: "LinearStatic",
        text: "*Name:* Analysis.Ansys.LinearStatic  \n*Desc:* Create and export Ansys job for Linear Static Structural  \n *Arg1:* strJobName (String)  \n *Arg2:* iJobdataAnatype (Integer)  \n *Arg3:* iJobdataSoltype (Integer)  \n *Arg4:* strJobdataJobname (String)  \n *Arg5:* strJobdataJobdescription (String)  \n *Arg6:* bBasicdataBoutputdisplacements (Boolean)  \n *Arg7:* bBasicdataBoutputreactionload (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Ansys.NormalModes": {
        prefix: "NormalModes",
        text: "*Name:* Analysis.Ansys.NormalModes  \n*Desc:* Create and export Ansys job for Normal Modes Structural  \n *Arg1:* strJobName (String)  \n *Arg2:* iJobdataAnatype (Integer)  \n *Arg3:* iJobdataSoltype (Integer)  \n *Arg4:* strJobdataJobname (String)  \n *Arg5:* strJobdataJobdescription (String)  \n *Arg6:* bBasicdataBoutputdisplacements (Boolean)  \n *Arg7:* bBasicdataBoutputreactionload (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Ansys.Harmonic": {
        prefix: "Harmonic",
        text: "*Name:* Analysis.Ansys.Harmonic  \n*Desc:* Create and export Ansys job for Harmonic Structural  \n *Arg1:* strJobName (String)  \n *Arg2:* iJobdataAnatype (Integer)  \n *Arg3:* iJobdataSoltype (Integer)  \n *Arg4:* strJobdataJobname (String)  \n *Arg5:* strJobdataJobdescription (String)  \n *Arg6:* bBasicdataBoutputdisplacements (Boolean)  \n *Arg7:* bBasicdataBoutputreactionload (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Ansys.Steady": {
        prefix: "Steady",
        text: "*Name:* Analysis.Ansys.Steady  \n*Desc:* Create and export Ansys job for Steady Heat Transfer  \n *Arg1:* strJobName (String)  \n *Arg2:* iJobdataAnatype (Integer)  \n *Arg3:* iJobdataSoltype (Integer)  \n *Arg4:* strJobdataJobname (String)  \n *Arg5:* strJobdataJobdescription (String)  \n *Arg6:* bBasicdataBoutputdisplacements (Boolean)  \n *Arg7:* bBasicdataBoutputreactionload (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Nastran.ModalTransientResponse": {
        prefix: "ModalTransientResponse",
        text: "*Name:* Analysis.Nastran.ModalTransientResponse  \n*Desc:* Export Nastran Modal Transient Response  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* bDummyPropAutoAssign (Boolean)  \n *Arg6:* iDummyPropMaterialID (Integer)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Nastran.LinearBuckling": {
        prefix: "LinearBuckling",
        text: "*Name:* Analysis.Nastran.LinearBuckling  \n*Desc:* Export Nastran Linear Buckling  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* bDummyPropAutoAssign (Boolean)  \n *Arg6:* iDummyPropMaterialID (Integer)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Nastran.Transient": {
        prefix: "Transient",
        text: "*Name:* Analysis.Nastran.Transient  \n*Desc:* Export Nastran Transient  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* bDummyPropAutoAssign (Boolean)  \n *Arg6:* iDummyPropMaterialID (Integer)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Nastran.SteadyState": {
        prefix: "SteadyState",
        text: "*Name:* Analysis.Nastran.SteadyState  \n*Desc:* Export Nastran Steady State  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* bDummyPropAutoAssign (Boolean)  \n *Arg6:* iDummyPropMaterialID (Integer)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Nastran.ModalFrequencyResponse": {
        prefix: "ModalFrequencyResponse",
        text: "*Name:* Analysis.Nastran.ModalFrequencyResponse  \n*Desc:* Export Nastran Modal Frequency Response  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* bDummyPropAutoAssign (Boolean)  \n *Arg6:* iDummyPropMaterialID (Integer)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Nastran.LinearStatic": {
        prefix: "LinearStatic",
        text: "*Name:* Analysis.Nastran.LinearStatic  \n*Desc:* Export Nastran Linear Static  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* bDummyPropAutoAssign (Boolean)  \n *Arg6:* iDummyPropMaterialID (Integer)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Nastran.NormalModes": {
        prefix: "NormalModes",
        text: "*Name:* Analysis.Nastran.NormalModes  \n*Desc:* Export Nastran Normal Modes  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* bDummyPropAutoAssign (Boolean)  \n *Arg6:* iDummyPropMaterialID (Integer)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Permas.Job": {
        prefix: "Job",
        text: "*Name:* Analysis.Permas.Job  \n*Desc:* permas output  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* iType (Integer)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* crlTarget (Cursor List)  \n *Arg6:* bElStress (Boolean)  \n *Arg7:* bElStressMis (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.ExportDynamisBdf": {
        prefix: "ExportDynamisBdf",
        text: "*Name:* Analysis.TSSolver.ExportDynamisBdf  \n*Desc:*   \n *Arg1:* strPath (String)  \n *Arg2:* crJob (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.Job": {
        prefix: "Job",
        text: "*Name:* Analysis.TSSolver.Job  \n*Desc:* Create TS-Solver Job  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.LinearBucking": {
        prefix: "LinearBucking",
        text: "*Name:* Analysis.TSSolver.LinearBucking  \n*Desc:* Export TS-Solver Linear Bucking  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.LinearStatic": {
        prefix: "LinearStatic",
        text: "*Name:* Analysis.TSSolver.LinearStatic  \n*Desc:* Export TS-Solver Linear Static  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.NonlinearStatic": {
        prefix: "NonlinearStatic",
        text: "*Name:* Analysis.TSSolver.NonlinearStatic  \n*Desc:* Export TS-Solver Nonlinear Static  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.NormalModes": {
        prefix: "NormalModes",
        text: "*Name:* Analysis.TSSolver.NormalModes  \n*Desc:* Export TS-Solver Normal Modes  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.NonlinearFrequency": {
        prefix: "NonlinearFrequency",
        text: "*Name:* Analysis.TSSolver.NonlinearFrequency  \n*Desc:* Export TS-Solver Nonlinear Frequency  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.ModalTransientResponse": {
        prefix: "ModalTransientResponse",
        text: "*Name:* Analysis.TSSolver.ModalTransientResponse  \n*Desc:* Export TS-Solver Modal Transient Response  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.TransientHeatTransfer": {
        prefix: "TransientHeatTransfer",
        text: "*Name:* Analysis.TSSolver.TransientHeatTransfer  \n*Desc:* Export TS-Solver Transient Heat Transfer  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.ModalFrequencyResponse": {
        prefix: "ModalFrequencyResponse",
        text: "*Name:* Analysis.TSSolver.ModalFrequencyResponse  \n*Desc:* Export TS-Solver Modal Frequency Response  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSolver.SteadyStateHeatTransfer": {
        prefix: "SteadyStateHeatTransfer",
        text: "*Name:* Analysis.TSSolver.SteadyStateHeatTransfer  \n*Desc:* Export TS-Solver Steady State Heat Transfer  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSS.TransientHeatTransfer": {
        prefix: "TransientHeatTransfer",
        text: "*Name:* Analysis.TSSS.TransientHeatTransfer  \n*Desc:* Export TS-SS Transient Heat Transfer  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* iRadialReturn (Integer)  \n *Arg6:* listNastranNonlinear (NASTRAN_NONLINEAR List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSS.LinearStatic": {
        prefix: "LinearStatic",
        text: "*Name:* Analysis.TSSS.LinearStatic  \n*Desc:* Export TS-SS Linear Static  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* iRadialReturn (Integer)  \n *Arg6:* listNastranNonlinear (NASTRAN_NONLINEAR List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSS.NonlinearStatic": {
        prefix: "NonlinearStatic",
        text: "*Name:* Analysis.TSSS.NonlinearStatic  \n*Desc:* Export TS-SS Nonlinear Static  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* iRadialReturn (Integer)  \n *Arg6:* listNastranNonlinear (NASTRAN_NONLINEAR List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSS.NormalModes": {
        prefix: "NormalModes",
        text: "*Name:* Analysis.TSSS.NormalModes  \n*Desc:* Export TS-SS Normal Modes  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* iRadialReturn (Integer)  \n *Arg6:* listNastranNonlinear (NASTRAN_NONLINEAR List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSS.LinearBuckling": {
        prefix: "LinearBuckling",
        text: "*Name:* Analysis.TSSS.LinearBuckling  \n*Desc:* Export TS-SS Linear Buckling  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* iRadialReturn (Integer)  \n *Arg6:* listNastranNonlinear (NASTRAN_NONLINEAR List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSS.ModalFrequencyResponse": {
        prefix: "ModalFrequencyResponse",
        text: "*Name:* Analysis.TSSS.ModalFrequencyResponse  \n*Desc:* Export TS-SS Modal Frequency Response  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* iRadialReturn (Integer)  \n *Arg6:* listNastranNonlinear (NASTRAN_NONLINEAR List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.TSSS.SteadyStateHeatTransfer": {
        prefix: "SteadyStateHeatTransfer",
        text: "*Name:* Analysis.TSSS.SteadyStateHeatTransfer  \n*Desc:* Export TS-SS Steady State Heat Transfer  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* iRadialReturn (Integer)  \n *Arg6:* listNastranNonlinear (NASTRAN_NONLINEAR List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.Abaqus": {
        prefix: "Abaqus",
        text: "*Name:* Analysis.Abaqus  \n*Desc:* abaqus exporting  \n *Arg1:* strName (String)  \n *Arg2:* bRBE2toMPC (Boolean)  \n *Arg3:* bRenameProcess (Boolean)  \n *Arg4:* iCodeType (Integer)  \n *Arg5:* iSurfDefType (Integer)  \n *Arg6:* iUnit (Integer)  \n *Arg7:* iWriteType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ExportAnsys": {
        prefix: "ExportAnsys",
        text: "*Name:* Analysis.ExportAnsys  \n*Desc:* Find faces in part by typical description  \n *Arg1:* strName (String)  \n *Arg2:* crAnsysJob (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ExportAbaqus": {
        prefix: "ExportAbaqus",
        text: "*Name:* Analysis.ExportAbaqus  \n*Desc:* export inp file  \n *Arg1:* crAbaJob (Cursor)  \n *Arg2:* crlSelectPart (Cursor List)  \n *Arg3:* strInpPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ModifyLbcToStep": {
        prefix: "ModifyLbcToStep",
        text: "*Name:* Analysis.ModifyLbcToStep  \n*Desc:* Abaqus analysis output data setting  \n *Arg1:* listAbaqusLbcStepInfo (ABAQUS_LBC_STEP_INFO List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ExportAdx": {
        prefix: "ExportAdx",
        text: "*Name:* Analysis.ExportAdx  \n*Desc:* export adx file  \n *Arg1:* crJob (Cursor)  \n *Arg2:* strPath (String)  \n *Arg3:* iNumType (Integer)  \n *Arg4:* iUiWidth (Integer)  \n *Arg5:* iUiPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ExportLsdyna": {
        prefix: "ExportLsdyna",
        text: "*Name:* Analysis.ExportLsdyna  \n*Desc:* Analysis LSDYNA ExportLsdyna  \n *Arg1:* strPath (String)  \n *Arg2:* crJob (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.NastranJob": {
        prefix: "NastranJob",
        text: "*Name:* Analysis.NastranJob  \n*Desc:* Create nastran Job  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* nastranAnalysis (NASTRAN_ANALYSIS)  \n *Arg5:* bDummyPropAutoAssign (Boolean)  \n *Arg6:* iDummyPropMaterialID (Integer)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.LSDYNAJob": {
        prefix: "LSDYNAJob",
        text: "*Name:* Analysis.LSDYNAJob  \n*Desc:* Create analysis LSDYNA job  \n *Arg1:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.Static": {
        prefix: "Static",
        text: "*Name:* Analysis.ADVC.MakeProcess.Static  \n*Desc:* create static process  \n *Arg1:* strName (String)  \n *Arg2:* iGeomNonlinear (Integer)  \n *Arg3:* advcStructTimeStep (ADVC_STRUCT_TIME_STEP)  \n *Arg4:* bConvergence (Boolean)  \n *Arg5:* advcConvergence (ADVC_CONVERGENCE)  \n *Arg6:* bContact (Boolean)  \n *Arg7:* advcContactIter (ADVC_CONTACT_ITER)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.Creep": {
        prefix: "Creep",
        text: "*Name:* Analysis.ADVC.MakeProcess.Creep  \n*Desc:* create creep process  \n *Arg1:* strName (String)  \n *Arg2:* iGeomNonlinear (Integer)  \n *Arg3:* advcStructTimeStep (ADVC_STRUCT_TIME_STEP)  \n *Arg4:* bConvergence (Boolean)  \n *Arg5:* advcConvergence (ADVC_CONVERGENCE)  \n *Arg6:* bContact (Boolean)  \n *Arg7:* advcContactIter (ADVC_CONTACT_ITER)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.Dynamic": {
        prefix: "Dynamic",
        text: "*Name:* Analysis.ADVC.MakeProcess.Dynamic  \n*Desc:* create dynamic process  \n *Arg1:* strName (String)  \n *Arg2:* iGeomNonlinear (Integer)  \n *Arg3:* advcStructTimeStep (ADVC_STRUCT_TIME_STEP)  \n *Arg4:* bConvergence (Boolean)  \n *Arg5:* advcConvergence (ADVC_CONVERGENCE)  \n *Arg6:* bContact (Boolean)  \n *Arg7:* advcContactIter (ADVC_CONTACT_ITER)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.EigenValue": {
        prefix: "EigenValue",
        text: "*Name:* Analysis.ADVC.MakeProcess.EigenValue  \n*Desc:* create advc eigen value process  \n *Arg1:* strName (String)  \n *Arg2:* bEigenValue (Boolean)  \n *Arg3:* iNumberOfModes (Integer)  \n *Arg4:* iEigenvecNorm (Integer)  \n *Arg5:* dShift (Double)  \n *Arg6:* dCgcgpiTol (Double)  \n *Arg7:* dCgcgpiEigTol (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.DynamicExplicit": {
        prefix: "DynamicExplicit",
        text: "*Name:* Analysis.ADVC.MakeProcess.DynamicExplicit  \n*Desc:* create dynamic explicit process.  \n *Arg1:* strName (String)  \n *Arg2:* iGeomNonlinear (Integer)  \n *Arg3:* advcStructTimeStep (ADVC_STRUCT_TIME_STEP)  \n *Arg4:* bConvergence (Boolean)  \n *Arg5:* advcConvergence (ADVC_CONVERGENCE)  \n *Arg6:* bContact (Boolean)  \n *Arg7:* advcContactIter (ADVC_CONTACT_ITER)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.ModalFreqResp": {
        prefix: "ModalFreqResp",
        text: "*Name:* Analysis.ADVC.MakeProcess.ModalFreqResp  \n*Desc:* create modal frequency response process of ADVC  \n *Arg1:* strName (String)  \n *Arg2:* strRefEigenDir (String)  \n *Arg3:* dRefLowFreq (Double)  \n *Arg4:* dRefHighFreq (Double)  \n *Arg5:* crModalDampingRatio (Cursor)  \n *Arg6:* crExcitationFreq (Cursor)  \n *Arg7:* bAutoFreqInterval (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.ResponseSpectrum": {
        prefix: "ResponseSpectrum",
        text: "*Name:* Analysis.ADVC.MakeProcess.ResponseSpectrum  \n*Desc:* create advc response spectrum process  \n *Arg1:* strName (String)  \n *Arg2:* strRefEigenDir (String)  \n *Arg3:* dRefLowFreq (Double)  \n *Arg4:* dRefHighFreq (Double)  \n *Arg5:* iPropMethod (Integer)  \n *Arg6:* iSpttype (Integer)  \n *Arg7:* dSptFactor0 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.SteadyState": {
        prefix: "SteadyState",
        text: "*Name:* Analysis.ADVC.MakeProcess.SteadyState  \n*Desc:* create advc heat transfer steady state process  \n *Arg1:* strName (String)  \n *Arg2:* iEndType (Integer)  \n *Arg3:* dMaxTime (Double)  \n *Arg4:* iFixedOrAuto (Integer)  \n *Arg5:* dMaxChange (Double)  \n *Arg6:* dInitDt (Double)  \n *Arg7:* iDefineMaxDt (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.Transient": {
        prefix: "Transient",
        text: "*Name:* Analysis.ADVC.MakeProcess.Transient  \n*Desc:* create advc heat transfer transient process  \n *Arg1:* strName (String)  \n *Arg2:* iEndType (Integer)  \n *Arg3:* dMaxTime (Double)  \n *Arg4:* dSteadyRate (Double)  \n *Arg5:* iFixedOrAuto (Integer)  \n *Arg6:* dMaxChange (Double)  \n *Arg7:* dInitDt (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.Fatigue": {
        prefix: "Fatigue",
        text: "*Name:* Analysis.ADVC.MakeProcess.Fatigue  \n*Desc:* create advc fatigue process  \n *Arg1:* strName (String)  \n *Arg2:* bFatigue (Boolean)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iStressAxis (Integer)  \n *Arg5:* iSafetyType (Integer)  \n *Arg6:* dSearchResolution (Double)  \n *Arg7:* dSafetyMax (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.MakeProcess.RandomResponse": {
        prefix: "RandomResponse",
        text: "*Name:* Analysis.ADVC.MakeProcess.RandomResponse  \n*Desc:* create advc random response process  \n *Arg1:* strName (String)  \n *Arg2:* strRefEigenDir (String)  \n *Arg3:* dRefLowFreq (Double)  \n *Arg4:* dRefHighFreq (Double)  \n *Arg5:* crModalDampingRatio (Cursor)  \n *Arg6:* crExcitationFreq (Cursor)  \n *Arg7:* bAutoFreqInterval (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.Structure": {
        prefix: "Structure",
        text: "*Name:* Analysis.ADVC.Structure  \n*Desc:* create advc job  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* iEJobType (Integer)  \n *Arg4:* crlProcessSequence (Cursor List)  \n *Arg5:* crlElemLocationGroup (Cursor List)  \n *Arg6:* crlNodeLocationGroup (Cursor List)  \n *Arg7:* bWriteGroup (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Analysis.ADVC.HeatTransfer": {
        prefix: "HeatTransfer",
        text: "*Name:* Analysis.ADVC.HeatTransfer  \n*Desc:* create advc job  \n *Arg1:* strName (String)  \n *Arg2:* strDescription (String)  \n *Arg3:* iEJobType (Integer)  \n *Arg4:* crlProcessSequence (Cursor List)  \n *Arg5:* crlElemLocationGroup (Cursor List)  \n *Arg6:* crlNodeLocationGroup (Cursor List)  \n *Arg7:* bWriteGroup (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.SeparateFaces.AllSharedNodes": {
        prefix: "AllSharedNodes",
        text: "*Name:* Assemble.SeparateFaces.AllSharedNodes  \n*Desc:* create by all shared nodes  \n *Arg1:*  ()  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.SeparateFaces.Shell": {
        prefix: "Shell",
        text: "*Name:* Assemble.SeparateFaces.Shell  \n*Desc:* Separate Faces for Shell  \n *Arg1:* iType (Integer)  \n *Arg2:* crlEntity (Cursor List)  \n *Arg3:* bCreateGroup (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.SeparateFaces.Solid": {
        prefix: "Solid",
        text: "*Name:* Assemble.SeparateFaces.Solid  \n*Desc:*   \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* bCreateGroup (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.Boolean": {
        prefix: "Boolean",
        text: "*Name:* Assemble.Boolean  \n*Desc:* Make Boolean between Parts  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iBooleanType (Integer)  \n *Arg3:* dToleranceAlignment (Double)  \n *Arg4:* bLeaveOriginalBodies (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.AssembleFace": {
        prefix: "AssembleFace",
        text: "*Name:* Assemble.AssembleFace  \n*Desc:* create assemble face  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* dTolerance (Double)  \n *Arg4:* iFitEdge (Integer)  \n *Arg5:* iMeshSetting (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.FullLayer": {
        prefix: "FullLayer",
        text: "*Name:* Assemble.FullLayer  \n*Desc:* assemble full layer  \n *Arg1:* crPart (Cursor)  \n *Arg2:* dLayerWidth (Double)  \n *Arg3:* iLayer (Integer)  \n *Arg4:* bUsePyramid (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.CylinderLayer": {
        prefix: "CylinderLayer",
        text: "*Name:* Assemble.CylinderLayer  \n*Desc:* Assemble cylinder layer  \n *Arg1:* crFace (Cursor)  \n *Arg2:* crNode (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.SharedFace": {
        prefix: "SharedFace",
        text: "*Name:* Assemble.SharedFace  \n*Desc:* Create assemble shared face  \n *Arg1:*  ()  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.AssembleFaces": {
        prefix: "AssembleFaces",
        text: "*Name:* Assemble.AssembleFaces  \n*Desc:* Assemble AssembleFaces  \n *Arg1:* ilPairFaceToMakeShareFace (Integer List)  \n *Arg2:* dTolerance (Double)  \n *Arg3:* iTypeConnectPos (Integer)  \n *Arg4:* bUseSnapInput (Boolean)  \n *Arg5:* dSnapTolerance (Double)  \n *Arg6:* bFitEdge (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.GeneralLayer": {
        prefix: "GeneralLayer",
        text: "*Name:* Assemble.GeneralLayer  \n*Desc:*   \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dWidth (Double)  \n *Arg3:* iLayer (Integer)  \n *Arg4:* bSeparatePart (Boolean)  \n *Arg5:* bForceStitchToSide (Boolean)  \n *Arg6:* bSmoothingEdge (Boolean)  \n *Arg7:* bNoImprint (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.AddRib": {
        prefix: "AddRib",
        text: "*Name:* Assemble.AddRib  \n*Desc:* create Rib  \n *Arg1:* crPart (Cursor)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* veclPoints (Vector List)  \n *Arg4:* dWidth (Double)  \n *Arg5:* dDepth (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.FindMatingFace": {
        prefix: "FindMatingFace",
        text: "*Name:* Assemble.FindMatingFace  \n*Desc:* Find Mating Face For Assemble Faces  \n *Arg1:* crlMasterFaces (Cursor List)  \n *Arg2:* crlSlaveFaces (Cursor List)  \n *Arg3:* crlPart (Cursor List)  \n *Arg4:* dTolerance (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assemble.AddBoss": {
        prefix: "AddBoss",
        text: "*Name:* Assemble.AddBoss  \n*Desc:*   \n *Arg1:* crPart (Cursor)  \n *Arg2:* iType (Integer)  \n *Arg3:* bMerge (Boolean)  \n *Arg4:* posOrgCenter (Position)  \n *Arg5:* vecOrgDirection (Vector)  \n *Arg6:* crCoord (Cursor)  \n *Arg7:* iAxis (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assembly.RightClick.AddToReference": {
        prefix: "AddToReference",
        text: "*Name:* Assembly.RightClick.AddToReference  \n*Desc:* Add Reference to Body  \n *Arg1:* crSrcPart (Cursor)  \n *Arg2:* crDestPart (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assembly.RightClick.Suppress": {
        prefix: "Suppress",
        text: "*Name:* Assembly.RightClick.Suppress  \n*Desc:* Suppress/ Unsuppress part on Tree Assembly  \n *Arg1:* crlPart (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assembly.RightClick.UnSuppress": {
        prefix: "UnSuppress",
        text: "*Name:* Assembly.RightClick.UnSuppress  \n*Desc:* Unknown Description  \n *Arg1:* crlPart (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assembly.RightClick.RestoreOriginalPart": {
        prefix: "RestoreOriginalPart",
        text: "*Name:* Assembly.RightClick.RestoreOriginalPart  \n*Desc:* Restore body  \n *Arg1:* crlBodies (Cursor List)  \n *Arg2:* bKeepShareFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assembly.RightClick.Rename": {
        prefix: "Rename",
        text: "*Name:* Assembly.RightClick.Rename  \n*Desc:* Rename item  \n *Arg1:* strNewName (String)  \n *Arg2:* crItem (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assembly.RightClick.ChangeEntityColor": {
        prefix: "ChangeEntityColor",
        text: "*Name:* Assembly.RightClick.ChangeEntityColor  \n*Desc:* Unknown Description  \n *Arg1:* crlEntity (Cursor List)  \n *Arg2:* iColor (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assembly.RightClick.AddSubAssembly": {
        prefix: "AddSubAssembly",
        text: "*Name:* Assembly.RightClick.AddSubAssembly  \n*Desc:* Add sub assembly  \n *Arg1:* crInst (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assembly.RightClick.ChangeBodyColor": {
        prefix: "ChangeBodyColor",
        text: "*Name:* Assembly.RightClick.ChangeBodyColor  \n*Desc:* Change Body Color  \n *Arg1:* listPartColorPair (PART_COLOR_PAIR List)  \n *Arg2:* bResetFaceColor (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Assembly.RightClick.ChangeMeshLineColor": {
        prefix: "ChangeMeshLineColor",
        text: "*Name:* Assembly.RightClick.ChangeMeshLineColor  \n*Desc:* Change Entity color  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* iColor (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.BoundaryTemperature.Constant": {
        prefix: "Constant",
        text: "*Name:* BoundaryConditions.BoundaryTemperature.Constant  \n*Desc:* Create boundary temperature  \n *Arg1:* strName (String)  \n *Arg2:* dFTemp (Double)  \n *Arg3:* crTable (Cursor)  \n *Arg4:* crlTarget (Cursor List)  \n *Arg5:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.BoundaryTemperature.SurfaceMapping": {
        prefix: "SurfaceMapping",
        text: "*Name:* BoundaryConditions.BoundaryTemperature.SurfaceMapping  \n*Desc:* Create mapping boundary temperature  \n *Arg1:* strName (String)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* iMAPPos (Integer)  \n *Arg4:* iViewCp (Integer)  \n *Arg5:* iCp (Integer)  \n *Arg6:* iSrcType (Integer)  \n *Arg7:* iMappedCpIndexArr0 (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Convection.Constant": {
        prefix: "Constant",
        text: "*Name:* BoundaryConditions.Convection.Constant  \n*Desc:* Create lbc of convection  \n *Arg1:* strName (String)  \n *Arg2:* dExtTemp (Double)  \n *Arg3:* crTableTimeTemp (Cursor)  \n *Arg4:* dDcoef (Double)  \n *Arg5:* crTableTimeCoeff (Cursor)  \n *Arg6:* crTableTempCoeff (Cursor)  \n *Arg7:* crlTarget (Cursor List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Convection.SurfaceMapping": {
        prefix: "SurfaceMapping",
        text: "*Name:* BoundaryConditions.Convection.SurfaceMapping  \n*Desc:* Create lbc of convection Surface Mapping  \n *Arg1:* strName (String)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* iPos (Integer)  \n *Arg4:* iViewCp (Integer)  \n *Arg5:* iCp (Integer)  \n *Arg6:* iSrcType (Integer)  \n *Arg7:* iMappedCpIndex0 (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.EnforcedLoads.Acceleration": {
        prefix: "Acceleration",
        text: "*Name:* BoundaryConditions.EnforcedLoads.Acceleration  \n*Desc:* Set enforced acceleration  \n *Arg1:* strName (String)  \n *Arg2:* iDwDof (Integer)  \n *Arg3:* dFVel1 (Double)  \n *Arg4:* dFVel2 (Double)  \n *Arg5:* dFVel3 (Double)  \n *Arg6:* dFVel4 (Double)  \n *Arg7:* dFVel5 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.EnforcedLoads.Velocity": {
        prefix: "Velocity",
        text: "*Name:* BoundaryConditions.EnforcedLoads.Velocity  \n*Desc:* create enforced velocity  \n *Arg1:* strName (String)  \n *Arg2:* iDwDof (Integer)  \n *Arg3:* dFVel0 (Double)  \n *Arg4:* dFVel1 (Double)  \n *Arg5:* dFVel2 (Double)  \n *Arg6:* dFVel3 (Double)  \n *Arg7:* dFVel4 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.EnforcedLoads.Displacement": {
        prefix: "Displacement",
        text: "*Name:* BoundaryConditions.EnforcedLoads.Displacement  \n*Desc:* create enforced displacement  \n *Arg1:* strName (String)  \n *Arg2:* iDwDof (Integer)  \n *Arg3:* dFDisp0 (Double)  \n *Arg4:* dFDisp1 (Double)  \n *Arg5:* dFDisp2 (Double)  \n *Arg6:* dFDisp3 (Double)  \n *Arg7:* dFDisp4 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.HeatFlux.SurfaceFlux": {
        prefix: "SurfaceFlux",
        text: "*Name:* BoundaryConditions.HeatFlux.SurfaceFlux  \n*Desc:* create surface flux  \n *Arg1:* strName (String)  \n *Arg2:* dFflux (Double)  \n *Arg3:* iDistributionMethod (Integer)  \n *Arg4:* crTable (Cursor)  \n *Arg5:* crlTarget (Cursor List)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.HeatFlux.SurfaceMapping": {
        prefix: "SurfaceMapping",
        text: "*Name:* BoundaryConditions.HeatFlux.SurfaceMapping  \n*Desc:* Create mapping heat flux  \n *Arg1:* strName (String)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* iMAPPos (Integer)  \n *Arg4:* iViewCp (Integer)  \n *Arg5:* iCp (Integer)  \n *Arg6:* iSrcType (Integer)  \n *Arg7:* iMappedCpIndexArr0 (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.HeatFlux.ConcentrateFlux": {
        prefix: "ConcentrateFlux",
        text: "*Name:* BoundaryConditions.HeatFlux.ConcentrateFlux  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* lbcConcentrateFluxData (LBC_CONCENTRATE_FLUX_DATA)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialElementalValue.InitialStress": {
        prefix: "InitialStress",
        text: "*Name:* BoundaryConditions.InitialElementalValue.InitialStress  \n*Desc:* create mapping stress  \n *Arg1:* strName (String)  \n *Arg2:* iDimension (Integer)  \n *Arg3:* iElemCs (Integer)  \n *Arg4:* dSXX (Double)  \n *Arg5:* dSYY (Double)  \n *Arg6:* dSXY (Double)  \n *Arg7:* crTable (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialTemperature.WholeMapping": {
        prefix: "WholeMapping",
        text: "*Name:* BoundaryConditions.InitialTemperature.WholeMapping  \n*Desc:* Create initial temperature whole mapping  \n *Arg1:* strName (String)  \n *Arg2:* iMapSourceType (Integer)  \n *Arg3:* strPath (String)  \n *Arg4:* iMappingMethod (Integer)  \n *Arg5:* iIsubcase (Integer)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialTemperature.Constant": {
        prefix: "Constant",
        text: "*Name:* BoundaryConditions.InitialTemperature.Constant  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* strFilePathName (String)  \n *Arg3:* bUseDefault (Boolean)  \n *Arg4:* crTable (Cursor)  \n *Arg5:* crlTarget (Cursor List)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialTemperature.ADVC": {
        prefix: "ADVC",
        text: "*Name:* BoundaryConditions.InitialTemperature.ADVC  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* strFilePathName (String)  \n *Arg3:* bUseDefault (Boolean)  \n *Arg4:* crTable (Cursor)  \n *Arg5:* crlTarget (Cursor List)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialTemperature.NastranPunch": {
        prefix: "NastranPunch",
        text: "*Name:* BoundaryConditions.InitialTemperature.NastranPunch  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* strFilePathName (String)  \n *Arg3:* bUseDefault (Boolean)  \n *Arg4:* crTable (Cursor)  \n *Arg5:* crlTarget (Cursor List)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.PropertiesCopyTranslate": {
        prefix: "PropertiesCopyTranslate",
        text: "*Name:* BoundaryConditions.LBCCopy.PropertiesCopyTranslate  \n*Desc:* Copy property translate  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* posVecTrans (Position)  \n *Arg4:* dMagnitude (Double)  \n *Arg5:* dTrandataDoffset (Double)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.PropertiesCopyRotate": {
        prefix: "PropertiesCopyRotate",
        text: "*Name:* BoundaryConditions.LBCCopy.PropertiesCopyRotate  \n*Desc:* Copy property rotate  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* posAxis (Position)  \n *Arg4:* posCenter (Position)  \n *Arg5:* dAngle (Double)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.PropertiesCopyMirror": {
        prefix: "PropertiesCopyMirror",
        text: "*Name:* BoundaryConditions.LBCCopy.PropertiesCopyMirror  \n*Desc:* Copy property mirror  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* poslPoints (Position List)  \n *Arg4:* dOffset (Double)  \n *Arg5:* dTol (Double)  \n *Arg6:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.ConnectionCopyTranslate": {
        prefix: "ConnectionCopyTranslate",
        text: "*Name:* BoundaryConditions.LBCCopy.ConnectionCopyTranslate  \n*Desc:* Copy connection translate  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* posVecTrans (Position)  \n *Arg4:* dMagnitude (Double)  \n *Arg5:* dTrandataDoffset (Double)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.ConnectionCopyRotate": {
        prefix: "ConnectionCopyRotate",
        text: "*Name:* BoundaryConditions.LBCCopy.ConnectionCopyRotate  \n*Desc:* Copy Connection rotate  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* posAxis (Position)  \n *Arg4:* posCenter (Position)  \n *Arg5:* dAngle (Double)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.ConnectionCopyMirror": {
        prefix: "ConnectionCopyMirror",
        text: "*Name:* BoundaryConditions.LBCCopy.ConnectionCopyMirror  \n*Desc:* Copy Connection mirror  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* poslPoints (Position List)  \n *Arg4:* dOffset (Double)  \n *Arg5:* dTol (Double)  \n *Arg6:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.GroupCopyTranslate": {
        prefix: "GroupCopyTranslate",
        text: "*Name:* BoundaryConditions.LBCCopy.GroupCopyTranslate  \n*Desc:* Copy group translate  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* posVecTrans (Position)  \n *Arg4:* dMagnitude (Double)  \n *Arg5:* dTrandataDoffset (Double)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.GroupCopyRotate": {
        prefix: "GroupCopyRotate",
        text: "*Name:* BoundaryConditions.LBCCopy.GroupCopyRotate  \n*Desc:* Copy Group rotate  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* posAxis (Position)  \n *Arg4:* posCenter (Position)  \n *Arg5:* dAngle (Double)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.GroupCopyMirror": {
        prefix: "GroupCopyMirror",
        text: "*Name:* BoundaryConditions.LBCCopy.GroupCopyMirror  \n*Desc:* Copy Group mirror  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* poslPoints (Position List)  \n *Arg4:* dOffset (Double)  \n *Arg5:* dTol (Double)  \n *Arg6:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.LBCCopyTranslate": {
        prefix: "LBCCopyTranslate",
        text: "*Name:* BoundaryConditions.LBCCopy.LBCCopyTranslate  \n*Desc:* Copy LBC translate  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* posVecTrans (Position)  \n *Arg4:* dMagnitude (Double)  \n *Arg5:* dTrandataDoffset (Double)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.LBCCopyRotate": {
        prefix: "LBCCopyRotate",
        text: "*Name:* BoundaryConditions.LBCCopy.LBCCopyRotate  \n*Desc:* Copy LBC rotate  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* posAxis (Position)  \n *Arg4:* posCenter (Position)  \n *Arg5:* dAngle (Double)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopy.LBCCopyMirror": {
        prefix: "LBCCopyMirror",
        text: "*Name:* BoundaryConditions.LBCCopy.LBCCopyMirror  \n*Desc:* Copy LBC mirror  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* poslPoints (Position List)  \n *Arg4:* dOffset (Double)  \n *Arg5:* dTol (Double)  \n *Arg6:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Pressure.SurfaceLoads": {
        prefix: "SurfaceLoads",
        text: "*Name:* BoundaryConditions.Pressure.SurfaceLoads  \n*Desc:* create distrubited pressure  \n *Arg1:* strName (String)  \n *Arg2:* dlPressure (Double List)  \n *Arg3:* iArrowdir (Integer)  \n *Arg4:* crCoordinate (Cursor)  \n *Arg5:* crlTargetFace (Cursor List)  \n *Arg6:* crEditCur (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Create lbc of 2nodes pressure  \n *Arg1:* strName (String)  \n *Arg2:* crNodeA (Cursor)  \n *Arg3:* dPressureA (Double)  \n *Arg4:* iNodeAUnit (Integer)  \n *Arg5:* crNodeB (Cursor)  \n *Arg6:* dPressureB (Double)  \n *Arg7:* iNodeBUnit (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Pressure.General": {
        prefix: "General",
        text: "*Name:* BoundaryConditions.Pressure.General  \n*Desc:* Create general pressure boundary condition  \n *Arg1:* strName (String)  \n *Arg2:* dFpressure (Double)  \n *Arg3:* iIdistribute (Integer)  \n *Arg4:* crTable (Cursor)  \n *Arg5:* dDphase (Double)  \n *Arg6:* dDdelay (Double)  \n *Arg7:* crPhaseTable (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Pressure.Quadratic": {
        prefix: "Quadratic",
        text: "*Name:* BoundaryConditions.Pressure.Quadratic  \n*Desc:* Create Pressure quadratic  \n *Arg1:* strName (String)  \n *Arg2:* dA (Double)  \n *Arg3:* dB (Double)  \n *Arg4:* crCoordinate (Cursor)  \n *Arg5:* dAngleRange (Double)  \n *Arg6:* iPressureDirectionMode (Integer)  \n *Arg7:* dlPressureDirection (Double List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Pressure.FunctionLoadToCylinderSine": {
        prefix: "FunctionLoadToCylinderSine",
        text: "*Name:* BoundaryConditions.Pressure.FunctionLoadToCylinderSine  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* dA (Double)  \n *Arg3:* crCoordinate (Cursor)  \n *Arg4:* dAngleRange (Double)  \n *Arg5:* bDistributionAxis (Boolean)  \n *Arg6:* iPressureDirectionMode (Integer)  \n *Arg7:* bIsTotalForceAdjustment (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Pressure.Hydrostatic": {
        prefix: "Hydrostatic",
        text: "*Name:* BoundaryConditions.Pressure.Hydrostatic  \n*Desc:* Boundary Conditions HPressure  \n *Arg1:* strName (String)  \n *Arg2:* dFHPressure (Double)  \n *Arg3:* dFDensity (Double)  \n *Arg4:* iDensityUnit (Integer)  \n *Arg5:* dFGravity (Double)  \n *Arg6:* iGravityUnit (Integer)  \n *Arg7:* iGravityDir (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Pressure.SurfaceMapping": {
        prefix: "SurfaceMapping",
        text: "*Name:* BoundaryConditions.Pressure.SurfaceMapping  \n*Desc:* Create mapping pressure  \n *Arg1:* strName (String)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* iMAPPos (Integer)  \n *Arg4:* iViewCp (Integer)  \n *Arg5:* iCp (Integer)  \n *Arg6:* iSrcType (Integer)  \n *Arg7:* iMappedCpIndexArr (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Submodel.SubmodelForcedFlux": {
        prefix: "SubmodelForcedFlux",
        text: "*Name:* BoundaryConditions.Submodel.SubmodelForcedFlux  \n*Desc:* create submodel forced flux  \n *Arg1:* strName (String)  \n *Arg2:* iSolver (Integer)  \n *Arg3:* strFilePathName (String)  \n *Arg4:* iProcessNo (Integer)  \n *Arg5:* iReferType (Integer)  \n *Arg6:* dExtensionRange (Double)  \n *Arg7:* dExtensionTol (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Submodel.ForcedTempertature": {
        prefix: "ForcedTempertature",
        text: "*Name:* BoundaryConditions.Submodel.ForcedTempertature  \n*Desc:* create sub model forced temperature  \n *Arg1:* strName (String)  \n *Arg2:* iSolver (Integer)  \n *Arg3:* strFilePathName (String)  \n *Arg4:* iProcessNo (Integer)  \n *Arg5:* iReferType (Integer)  \n *Arg6:* dExtensionRange (Double)  \n *Arg7:* dExtensionTol (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Submodel.ForcedDisplacement": {
        prefix: "ForcedDisplacement",
        text: "*Name:* BoundaryConditions.Submodel.ForcedDisplacement  \n*Desc:* Boundary Conditions Lbc Submodel Forced Disp  \n *Arg1:* strName (String)  \n *Arg2:* iSolver (Integer)  \n *Arg3:* strFilePathName (String)  \n *Arg4:* iProcessNo (Integer)  \n *Arg5:* bTranslationX (Boolean)  \n *Arg6:* bTranslationY (Boolean)  \n *Arg7:* bTranslationZ (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.TemperatureLoads.Constant": {
        prefix: "Constant",
        text: "*Name:* BoundaryConditions.TemperatureLoads.Constant  \n*Desc:* create temperature load constant  \n *Arg1:* strName (String)  \n *Arg2:* dTemperature (Double)  \n *Arg3:* crTable (Cursor)  \n *Arg4:* crlTarget (Cursor List)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* bUseDefaultTemp (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.TemperatureLoads.ADVCFile": {
        prefix: "ADVCFile",
        text: "*Name:* BoundaryConditions.TemperatureLoads.ADVCFile  \n*Desc:* create temperature load by advc file  \n *Arg1:* strName (String)  \n *Arg2:* strFilePathName (String)  \n *Arg3:* crTable (Cursor)  \n *Arg4:* crlTarget (Cursor List)  \n *Arg5:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.TemperatureLoads.NastranPunch": {
        prefix: "NastranPunch",
        text: "*Name:* BoundaryConditions.TemperatureLoads.NastranPunch  \n*Desc:* create temperature load of nastran punch  \n *Arg1:* strName (String)  \n *Arg2:* strFilePathName (String)  \n *Arg3:* crTable (Cursor)  \n *Arg4:* crlTarget (Cursor List)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* bUseAsMaterialReferenceTemp (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.TemperatureLoads.WholeMapping": {
        prefix: "WholeMapping",
        text: "*Name:* BoundaryConditions.TemperatureLoads.WholeMapping  \n*Desc:* Create mapping pressure  \n *Arg1:* strName (String)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* iMAPPos (Integer)  \n *Arg4:* iViewCp (Integer)  \n *Arg5:* iCp (Integer)  \n *Arg6:* iSrcType (Integer)  \n *Arg7:* iMappedCpIndexArr0 (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.TemperatureLoads.LbcInitialTemperature": {
        prefix: "LbcInitialTemperature",
        text: "*Name:* BoundaryConditions.TemperatureLoads.LbcInitialTemperature  \n*Desc:* Boundary Conditions Lbc Initial Temperature  \n *Arg1:* strName (String)  \n *Arg2:* iType (Integer)  \n *Arg3:* dFTemp (Double)  \n *Arg4:* strFilePathName (String)  \n *Arg5:* bUseDefault (Boolean)  \n *Arg6:* crTable (Cursor)  \n *Arg7:* crlTarget (Cursor List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LoadCase": {
        prefix: "LoadCase",
        text: "*Name:* BoundaryConditions.LoadCase  \n*Desc:* create load case  \n *Arg1:* strName (String)  \n *Arg2:* dFactor (Double)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* iExportId (Integer)  \n *Arg5:* dlTargetFactor (Double List)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InsideHeatGeneration": {
        prefix: "InsideHeatGeneration",
        text: "*Name:* BoundaryConditions.InsideHeatGeneration  \n*Desc:* Create lbc of inside heat generation  \n *Arg1:* strName (String)  \n *Arg2:* dInsideFlux (Double)  \n *Arg3:* crTable (Cursor)  \n *Arg4:* crlTarget (Cursor List)  \n *Arg5:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LBCCopyMisc": {
        prefix: "LBCCopyMisc",
        text: "*Name:* BoundaryConditions.LBCCopyMisc  \n*Desc:* Unknown Description  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iMatchMethod (Integer)  \n *Arg3:* dlTransVec (Double List)  \n *Arg4:* dTransMag (Double)  \n *Arg5:* dTransOffset (Double)  \n *Arg6:* dTransTol (Double)  \n *Arg7:* crTranscrCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.LbcContactConvert": {
        prefix: "LbcContactConvert",
        text: "*Name:* BoundaryConditions.LbcContactConvert  \n*Desc:* BoundaryConditions LbcContactConvert  \n *Arg1:* iConvertTo (Integer)  \n *Arg2:* iTieConvType (Integer)  \n *Arg3:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.FieldData": {
        prefix: "FieldData",
        text: "*Name:* BoundaryConditions.FieldData  \n*Desc:* create field data table  \n *Arg1:* strName (String)  \n *Arg2:* iType (Integer)  \n *Arg3:* ilSheet (Integer List)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* bAbaqusAmp (Boolean)  \n *Arg6:* iAmpType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.FixedConstraint": {
        prefix: "FixedConstraint",
        text: "*Name:* BoundaryConditions.FixedConstraint  \n*Desc:* create FixedConstraint  \n *Arg1:* strName (String)  \n *Arg2:* iDwDof (Integer)  \n *Arg3:* crCurCoord (Cursor)  \n *Arg4:* iType (Integer)  \n *Arg5:* iUsetType (Integer)  \n *Arg6:* crTable (Cursor)  \n *Arg7:* bAbaqusFixed (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.DofSet": {
        prefix: "DofSet",
        text: "*Name:* BoundaryConditions.DofSet  \n*Desc:* Lbc Dof Set  \n *Arg1:* strName (String)  \n *Arg2:* iDwDof (Integer)  \n *Arg3:* crCurCoord (Cursor)  \n *Arg4:* crTable (Cursor)  \n *Arg5:* crlTarget (Cursor List)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.BodyLoads.CentrifugalForce.CoordinateSystems": {
        prefix: "CoordinateSystems",
        text: "*Name:* BoundaryConditions.BodyLoads.CentrifugalForce.CoordinateSystems  \n*Desc:* create centrifugal force by coordinate system  \n *Arg1:* strName (String)  \n *Arg2:* dFVelocity (Double)  \n *Arg3:* dFAcceleration (Double)  \n *Arg4:* iAxisDirection (Integer)  \n *Arg5:* iVelocityUnit (Integer)  \n *Arg6:* iAccelerationUnit (Integer)  \n *Arg7:* crCurCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.BodyLoads.CentrifugalForce.TwoPositions": {
        prefix: "TwoPositions",
        text: "*Name:* BoundaryConditions.BodyLoads.CentrifugalForce.TwoPositions  \n*Desc:* create centrifugal force  \n *Arg1:* strName (String)  \n *Arg2:* dFBasePoint1 (Double)  \n *Arg3:* dFBasePoint2 (Double)  \n *Arg4:* dFBasePoint3 (Double)  \n *Arg5:* dFTipPoint1 (Double)  \n *Arg6:* dFTipPoint2 (Double)  \n *Arg7:* dFTipPoint3 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.BodyLoads.Gravity": {
        prefix: "Gravity",
        text: "*Name:* BoundaryConditions.BodyLoads.Gravity  \n*Desc:* create gravity  \n *Arg1:* strName (String)  \n *Arg2:* dlGravity (Double List)  \n *Arg3:* crCurCoord (Cursor)  \n *Arg4:* crlTarget (Cursor List)  \n *Arg5:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Force.FunctionLoadCylinder.Quadratic": {
        prefix: "Quadratic",
        text: "*Name:* BoundaryConditions.Force.FunctionLoadCylinder.Quadratic  \n*Desc:* Create Force (Quadratic) y = a*x^2 + b  \n *Arg1:* strName (String)  \n *Arg2:* dFTotalForce (Double)  \n *Arg3:* dA (Double)  \n *Arg4:* dB (Double)  \n *Arg5:* crCoord (Cursor)  \n *Arg6:* iAngleBase (Integer)  \n *Arg7:* dAngleRange (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Force.FunctionLoadCylinder.Sine": {
        prefix: "Sine",
        text: "*Name:* BoundaryConditions.Force.FunctionLoadCylinder.Sine  \n*Desc:* Define the force load on selected entity based on the distribution of the sine function.  \n *Arg1:* strName (String)  \n *Arg2:* dFTotalForce (Double)  \n *Arg3:* dA (Double)  \n *Arg4:* crCoord (Cursor)  \n *Arg5:* iAngleBase (Integer)  \n *Arg6:* dAngleRange (Double)  \n *Arg7:* iEnArrowDir (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Force.FunctionLoadCylinder.Vector": {
        prefix: "Vector",
        text: "*Name:* BoundaryConditions.Force.FunctionLoadCylinder.Vector  \n*Desc:* Define the force load on selected entity based on the distribution of the vector function.  \n *Arg1:* strName (String)  \n *Arg2:* dFTotalForce (Double)  \n *Arg3:* dA (Double)  \n *Arg4:* dX (Double)  \n *Arg5:* dY (Double)  \n *Arg6:* crCoord (Cursor)  \n *Arg7:* iEnDirection (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* create nonlinear force NOLIN3  \n *Arg1:* strName (String)  \n *Arg2:* dForceScale (Double)  \n *Arg3:* dMomentScale (Double)  \n *Arg4:* dForcePowerA (Double)  \n *Arg5:* dMomentPowerA (Double)  \n *Arg6:* iForcDir (Integer)  \n *Arg7:* iForceDepends (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* create NOLIN4 nonlinear force  \n *Arg1:* strName (String)  \n *Arg2:* dForceScale (Double)  \n *Arg3:* dMomentScale (Double)  \n *Arg4:* dForcePowerA (Double)  \n *Arg5:* dMomentPowerA (Double)  \n *Arg6:* iForcDir (Integer)  \n *Arg7:* iForceDepends (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Create Nonlinear Force of NOLIN1(Table)  \n *Arg1:* strName (String)  \n *Arg2:* dForceScale (Double)  \n *Arg3:* dMomentScale (Double)  \n *Arg4:* iForcDir (Integer)  \n *Arg5:* iForceDepends (Integer)  \n *Arg6:* iMomentDir (Integer)  \n *Arg7:* iMomentDepends (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Force.General": {
        prefix: "General",
        text: "*Name:* BoundaryConditions.Force.General  \n*Desc:* create force general  \n *Arg1:* strName (String)  \n *Arg2:* DFLT_DBL (DFLT_DBL)  \n *Arg3:* DFLT_DBL] (DFLT_DBL])  \n *Arg4:* vecForce (Vector)  \n *Arg5:* DFLT_DBL (DFLT_DBL)  \n *Arg6:* DFLT_DBL] (DFLT_DBL])  \n *Arg7:* vecMoment (Vector)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.Force.ForceNormalDirection": {
        prefix: "ForceNormalDirection",
        text: "*Name:* BoundaryConditions.Force.ForceNormalDirection  \n*Desc:* Create Force (normal direction)  \n *Arg1:* strName (String)  \n *Arg2:* DFLT_DBL (DFLT_DBL)  \n *Arg3:* DFLT_DBL] (DFLT_DBL])  \n *Arg4:* vecForce (Vector)  \n *Arg5:* iEnArrowDir (Integer)  \n *Arg6:* iDistributionMethod (Integer)  \n *Arg7:* crCurCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialNodalValue.InitialAngularVelocity.Abaqus": {
        prefix: "Abaqus",
        text: "*Name:* BoundaryConditions.InitialNodalValue.InitialAngularVelocity.Abaqus  \n*Desc:* Create lbc of initial angular velocity for abaqus  \n *Arg1:* strName (String)  \n *Arg2:* dVelocity (Double)  \n *Arg3:* strFirstCoord (String)  \n *Arg4:* strSecondCoord (String)  \n *Arg5:* crlTarget (Cursor List)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialNodalValue.InitialAngularVelocity.General": {
        prefix: "General",
        text: "*Name:* BoundaryConditions.InitialNodalValue.InitialAngularVelocity.General  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* stData (ST_DATA)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialNodalValue.Displacement": {
        prefix: "Displacement",
        text: "*Name:* BoundaryConditions.InitialNodalValue.Displacement  \n*Desc:* Create Initial Dynamic  \n *Arg1:* strName (String)  \n *Arg2:* iType (Integer)  \n *Arg3:* vecInit (Vector)  \n *Arg4:* bSelNode (Boolean)  \n *Arg5:* crNodeSet (Cursor)  \n *Arg6:* crTable (Cursor)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialNodalValue.Velocity": {
        prefix: "Velocity",
        text: "*Name:* BoundaryConditions.InitialNodalValue.Velocity  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* stData (ST_DATA)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "BoundaryConditions.InitialNodalValue.RotationAngle": {
        prefix: "RotationAngle",
        text: "*Name:* BoundaryConditions.InitialNodalValue.RotationAngle  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* stData (ST_DATA)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Pretension.General": {
        prefix: "General",
        text: "*Name:* Connections.Pretension.General  \n*Desc:* Pretension general  \n *Arg1:* strName (String)  \n *Arg2:* iDir (Integer)  \n *Arg3:* dValue (Double)  \n *Arg4:* bFixLength (Boolean)  \n *Arg5:* crTable (Cursor)  \n *Arg6:* crCoord (Cursor)  \n *Arg7:* iLocalUnit (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Pretension.Abaqus": {
        prefix: "Abaqus",
        text: "*Name:* Connections.Pretension.Abaqus  \n*Desc:* Create Pretension Abaqus  \n *Arg1:* strName (String)  \n *Arg2:* bFixedLenght (Boolean)  \n *Arg3:* crTable (Cursor)  \n *Arg4:* dValue (Double)  \n *Arg5:* iLocalUnit (Integer)  \n *Arg6:* strNormal (String)  \n *Arg7:* dlNodePos (Double List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Pretension.Advc": {
        prefix: "Advc",
        text: "*Name:* Connections.Pretension.Advc  \n*Desc:* Create ADVC pretension  \n *Arg1:* strName (String)  \n *Arg2:* bFixedLength (Boolean)  \n *Arg3:* crEnforcedVelocity (Cursor)  \n *Arg4:* dDvalue (Double)  \n *Arg5:* iDirUpdateType (Integer)  \n *Arg6:* dlVnormal (Double List)  \n *Arg7:* dlCtrolNodePos (Double List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MassElements": {
        prefix: "MassElements",
        text: "*Name:* Connections.MassElements  \n*Desc:* Connection new mass  \n *Arg1:* strName (String)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* dMass (Double)  \n *Arg4:* iDof (Integer)  \n *Arg5:* bDesigner (Boolean)  \n *Arg6:* crCoordinate (Cursor)  \n *Arg7:* dOffset0 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BarBeam": {
        prefix: "BarBeam",
        text: "*Name:* Connections.BarBeam  \n*Desc:* create Connections Bar or Beam  \n *Arg1:* strName (String)  \n *Arg2:* iEType (Integer)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* crProp (Cursor)  \n *Arg5:* dlOrient (Double List)  \n *Arg6:* crlMasterTarget (Cursor List)  \n *Arg7:* crlSlaveTarget (Cursor List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.GapsDetail": {
        prefix: "GapsDetail",
        text: "*Name:* Connections.GapsDetail  \n*Desc:* Unknown Description  \n *Arg1:* crlMaster (Cursor List)  \n *Arg2:* crlSlave (Cursor List)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iOriMode (Integer)  \n *Arg5:* crCoord (Cursor)  \n *Arg6:* strName (String)  \n *Arg7:* dU0 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Plot": {
        prefix: "Plot",
        text: "*Name:* Connections.Plot  \n*Desc:* Create 1D plot connection  \n *Arg1:* strName (String)  \n *Arg2:* iPID (Integer)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.CreateConnConm": {
        prefix: "CreateConnConm",
        text: "*Name:* Connections.CreateConnConm  \n*Desc:*   \n *Arg1:* strName (String)  \n *Arg2:* iEType (Integer)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iCoordSys (Integer)  \n *Arg5:* iConmId (Integer)  \n *Arg6:* crMatCoord (Cursor)  \n *Arg7:* dMass (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* listRbe3TermConnection (RBE3TERM_CONNECTION List)  \n *Arg5:* iTypeRBE3 (Integer)  \n *Arg6:* strName (String)  \n *Arg7:* crCoordSys (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidWall": {
        prefix: "RigidWall",
        text: "*Name:* Connections.RigidWall  \n*Desc:*   \n *Arg1:* strName (String)  \n *Arg2:* iObject (Integer)  \n *Arg3:* iType (Integer)  \n *Arg4:* iMotion (Integer)  \n *Arg5:* iFriction (Integer)  \n *Arg6:* iOrtho (Integer)  \n *Arg7:* iForces (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Connector": {
        prefix: "Connector",
        text: "*Name:* Connections.Connector  \n*Desc:* create Connector  \n *Arg1:* strName (String)  \n *Arg2:* iMethod (Integer)  \n *Arg3:* iConnectType (Integer)  \n *Arg4:* iRefNode (Integer)  \n *Arg5:* iElemCs (Integer)  \n *Arg6:* crLocalCS (Cursor)  \n *Arg7:* crlElasticity (Cursor List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BoltMeshingSplitOnly": {
        prefix: "BoltMeshingSplitOnly",
        text: "*Name:* Connections.BoltMeshingSplitOnly  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* iPartcutparamImethod (Integer)  \n *Arg3:* dPartcutparamDoffset (Double)  \n *Arg4:* iPartcutparamBshareface (Integer)  \n *Arg5:* iPartcutparamBseparateface (Integer)  \n *Arg6:* iPartcutparamBsplitonly (Integer)  \n *Arg7:* iPartcutparamBmakesectionface (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BoltMeshingNotSplitOnly": {
        prefix: "BoltMeshingNotSplitOnly",
        text: "*Name:* Connections.BoltMeshingNotSplitOnly  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* iPartcutparamImethod (Integer)  \n *Arg3:* dPartcutparamDoffset (Double)  \n *Arg4:* iPartcutparamBshareface (Integer)  \n *Arg5:* iPartcutparamBseparateface (Integer)  \n *Arg6:* iPartcutparamBsplitonly (Integer)  \n *Arg7:* iPartcutparamBmakesectionface (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BoltConnections.Edge.TypeC": {
        prefix: "TypeC",
        text: "*Name:* Connections.BoltConnections.Edge.TypeC  \n*Desc:* create bolt connections by TypeC edge.  \n *Arg1:* crlEdgeCur1 (Cursor List)  \n *Arg2:* crlEdgeCur2 (Cursor List)  \n *Arg3:* strRbeName (String)  \n *Arg4:* dPlaneTol (Double)  \n *Arg5:* dMaxBoltHeight (Double)  \n *Arg6:* iConnectionType (Integer)  \n *Arg7:* iCoincidentNodes (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BoltConnections.Edge.TypeB": {
        prefix: "TypeB",
        text: "*Name:* Connections.BoltConnections.Edge.TypeB  \n*Desc:*   \n *Arg1:* crlEdgeCur1 (Cursor List)  \n *Arg2:* crlEdgeCur2 (Cursor List)  \n *Arg3:* strRbeName (String)  \n *Arg4:* strBarName (String)  \n *Arg5:* iShaftType (Integer)  \n *Arg6:* crCurBarProperty (Cursor)  \n *Arg7:* dPlaneTol (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BoltConnections.Edge.TypeD": {
        prefix: "TypeD",
        text: "*Name:* Connections.BoltConnections.Edge.TypeD  \n*Desc:* create bolt connection typeD  \n *Arg1:* crlEdgeCur1 (Cursor List)  \n *Arg2:* crlEdgeCur2 (Cursor List)  \n *Arg3:* strMpcName (String)  \n *Arg4:* dConnRadius (Double)  \n *Arg5:* dPlaneTol (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BoltConnections.Edge.TypeA": {
        prefix: "TypeA",
        text: "*Name:* Connections.BoltConnections.Edge.TypeA  \n*Desc:* Create Lbc TypeA Bolt Edge method  \n *Arg1:* crlEdgeCur1 (Cursor List)  \n *Arg2:* crlEdgeCur2 (Cursor List)  \n *Arg3:* strRbeName (String)  \n *Arg4:* strBarName (String)  \n *Arg5:* iShaftType (Integer)  \n *Arg6:* crCurBarProperty (Cursor)  \n *Arg7:* dPlaneTol (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BoltConnections.Face.TypeC": {
        prefix: "TypeC",
        text: "*Name:* Connections.BoltConnections.Face.TypeC  \n*Desc:* Create Lbc TypeC Bolt Face method  \n *Arg1:* crlFaceCur1 (Cursor List)  \n *Arg2:* crlFaceCur2 (Cursor List)  \n *Arg3:* strRbeName (String)  \n *Arg4:* dPlaneTol (Double)  \n *Arg5:* dMaxBoltHeight (Double)  \n *Arg6:* dMaxDiameter (Double)  \n *Arg7:* dMinDiameter (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BoltConnections.Face.TypeB": {
        prefix: "TypeB",
        text: "*Name:* Connections.BoltConnections.Face.TypeB  \n*Desc:* Create Lbc TypeB Bolt Face method  \n *Arg1:* crlFaceCur1 (Cursor List)  \n *Arg2:* crlFaceCur2 (Cursor List)  \n *Arg3:* strRbeName (String)  \n *Arg4:* strBarName (String)  \n *Arg5:* iShaftType (Integer)  \n *Arg6:* crCurBarProperty (Cursor)  \n *Arg7:* dPlaneTol (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.BoltConnections.Face.TypeA": {
        prefix: "TypeA",
        text: "*Name:* Connections.BoltConnections.Face.TypeA  \n*Desc:*   \n *Arg1:* crlFaceCur1 (Cursor List)  \n *Arg2:* crlFaceCur2 (Cursor List)  \n *Arg3:* strRbeName (String)  \n *Arg4:* strBarName (String)  \n *Arg5:* iShaftType (Integer)  \n *Arg6:* crCurBarProperty (Cursor)  \n *Arg7:* dPlaneTol (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Abaqus.ContactTable": {
        prefix: "ContactTable",
        text: "*Name:* Connections.Contacts.Abaqus.ContactTable  \n*Desc:* Create LBC contact abaqus manual face  \n *Arg1:* strName (String)  \n *Arg2:* iContactMethod (Integer)  \n *Arg3:* iContactType (Integer)  \n *Arg4:* iAlg (Integer)  \n *Arg5:* dAdjustVal (Double)  \n *Arg6:* dExtensionZone (Double)  \n *Arg7:* dMaxPenetration (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Abaqus.ManualGroup": {
        prefix: "ManualGroup",
        text: "*Name:* Connections.Contacts.Abaqus.ManualGroup  \n*Desc:* Create LBC contact abaqus manual group  \n *Arg1:* strName (String)  \n *Arg2:* iContactMethod (Integer)  \n *Arg3:* iContactType (Integer)  \n *Arg4:* iAlg (Integer)  \n *Arg5:* dAdjustVal (Double)  \n *Arg6:* dExtensionZone (Double)  \n *Arg7:* dMaxPenetration (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Abaqus.ManualFace": {
        prefix: "ManualFace",
        text: "*Name:* Connections.Contacts.Abaqus.ManualFace  \n*Desc:* Create LBC contact abaqus manual face  \n *Arg1:* strName (String)  \n *Arg2:* iContactMethod (Integer)  \n *Arg3:* iContactType (Integer)  \n *Arg4:* iAlg (Integer)  \n *Arg5:* dAdjustVal (Double)  \n *Arg6:* dExtensionZone (Double)  \n *Arg7:* dMaxPenetration (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Abaqus.ContactGroupByMatrix": {
        prefix: "ContactGroupByMatrix",
        text: "*Name:* Connections.Contacts.Abaqus.ContactGroupByMatrix  \n*Desc:* Create LBC contact abaqus group by matrix  \n *Arg1:* strName (String)  \n *Arg2:* iContactMethod (Integer)  \n *Arg3:* iContactType (Integer)  \n *Arg4:* iAlg (Integer)  \n *Arg5:* dAdjustVal (Double)  \n *Arg6:* dExtensionZone (Double)  \n *Arg7:* dMaxPenetration (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Abaqus.ContactShareFace": {
        prefix: "ContactShareFace",
        text: "*Name:* Connections.Contacts.Abaqus.ContactShareFace  \n*Desc:* Create LBC contact abaqus manual group  \n *Arg1:* strName (String)  \n *Arg2:* iContactMethod (Integer)  \n *Arg3:* iContactType (Integer)  \n *Arg4:* iAlg (Integer)  \n *Arg5:* dAdjustVal (Double)  \n *Arg6:* dExtensionZone (Double)  \n *Arg7:* dMaxPenetration (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.ADVC.ContactClearance": {
        prefix: "ContactClearance",
        text: "*Name:* Connections.Contacts.ADVC.ContactClearance  \n*Desc:* contact clearance for ADVC contact  \n *Arg1:* strName (String)  \n *Arg2:* dClearanceVal (Double)  \n *Arg3:* iLocalUnit (Integer)  \n *Arg4:* iSolverType (Integer)  \n *Arg5:* crlTarget (Cursor List)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.ADVC.ManualGroup": {
        prefix: "ManualGroup",
        text: "*Name:* Connections.Contacts.ADVC.ManualGroup  \n*Desc:* create ADVC contact Manual Group  \n *Arg1:* strName (String)  \n *Arg2:* iContactType (Integer)  \n *Arg3:* iSlidingType (Integer)  \n *Arg4:* iInitialState (Integer)  \n *Arg5:* dInitialStateTol (Double)  \n *Arg6:* dKineticFrictionCoef (Double)  \n *Arg7:* dExponentialCoef (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.ADVC.ManualFace": {
        prefix: "ManualFace",
        text: "*Name:* Connections.Contacts.ADVC.ManualFace  \n*Desc:* create ADVC contact by manual face  \n *Arg1:* crlFaceMaster (Cursor List)  \n *Arg2:* crlFaceSlave (Cursor List)  \n *Arg3:* strName (String)  \n *Arg4:* iContactType (Integer)  \n *Arg5:* iSlidingType (Integer)  \n *Arg6:* iInitialState (Integer)  \n *Arg7:* dInitialStateTol (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.ADVC.ContactShareFace": {
        prefix: "ContactShareFace",
        text: "*Name:* Connections.Contacts.ADVC.ContactShareFace  \n*Desc:* create ADVC Contact Share Face  \n *Arg1:* crlShareFace (Cursor List)  \n *Arg2:* strName (String)  \n *Arg3:* iContactType (Integer)  \n *Arg4:* iSlidingType (Integer)  \n *Arg5:* iInitialState (Integer)  \n *Arg6:* dInitialStateTol (Double)  \n *Arg7:* dKineticFrictionCoef (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.ADVC.ContactTable": {
        prefix: "ContactTable",
        text: "*Name:* Connections.Contacts.ADVC.ContactTable  \n*Desc:* create ADVC Contact Table  \n *Arg1:* strName (String)  \n *Arg2:* iContactType (Integer)  \n *Arg3:* iSlidingType (Integer)  \n *Arg4:* iInitialState (Integer)  \n *Arg5:* dInitialStateTol (Double)  \n *Arg6:* dKineticFrictionCoef (Double)  \n *Arg7:* dExponentialCoef (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.ADVC.ContactGroupByMatrix": {
        prefix: "ContactGroupByMatrix",
        text: "*Name:* Connections.Contacts.ADVC.ContactGroupByMatrix  \n*Desc:* create ADVC contact Group By Matrix  \n *Arg1:* strName (String)  \n *Arg2:* iContactType (Integer)  \n *Arg3:* iSlidingType (Integer)  \n *Arg4:* iInitialState (Integer)  \n *Arg5:* dInitialStateTol (Double)  \n *Arg6:* dKineticFrictionCoef (Double)  \n *Arg7:* dExponentialCoef (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Ansys.ManualGroup": {
        prefix: "ManualGroup",
        text: "*Name:* Connections.Contacts.Ansys.ManualGroup  \n*Desc:* create contact ansys Manual Group  \n *Arg1:* strName (String)  \n *Arg2:* iMethod (Integer)  \n *Arg3:* iType (Integer)  \n *Arg4:* iContactAlgorithm (Integer)  \n *Arg5:* ansysContact (ANSYS_CONTACT)  \n *Arg6:* crplTarget (Cursor Pair List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Ansys.ManualFace": {
        prefix: "ManualFace",
        text: "*Name:* Connections.Contacts.Ansys.ManualFace  \n*Desc:* create contacts of Ansys Manual Face  \n *Arg1:* crlFaceMaster (Cursor List)  \n *Arg2:* crlFaceSlave (Cursor List)  \n *Arg3:* strName (String)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iType (Integer)  \n *Arg6:* iContactAlgorithm (Integer)  \n *Arg7:* ansysContact (ANSYS_CONTACT)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Ansys.ContactGroupByMatrix": {
        prefix: "ContactGroupByMatrix",
        text: "*Name:* Connections.Contacts.Ansys.ContactGroupByMatrix  \n*Desc:* create contact ansys Group By Matrix  \n *Arg1:* strName (String)  \n *Arg2:* iMethod (Integer)  \n *Arg3:* iType (Integer)  \n *Arg4:* iContactAlgorithm (Integer)  \n *Arg5:* ansysContact (ANSYS_CONTACT)  \n *Arg6:* crplTarget (Cursor Pair List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Ansys.ContactShareFace": {
        prefix: "ContactShareFace",
        text: "*Name:* Connections.Contacts.Ansys.ContactShareFace  \n*Desc:* create contact ansys Share Face  \n *Arg1:* crlShareFace (Cursor List)  \n *Arg2:* strName (String)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iType (Integer)  \n *Arg5:* iContactAlgorithm (Integer)  \n *Arg6:* ansysContact (ANSYS_CONTACT)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.Ansys.ContactTable": {
        prefix: "ContactTable",
        text: "*Name:* Connections.Contacts.Ansys.ContactTable  \n*Desc:* create contact ansys Contact Table  \n *Arg1:* strName (String)  \n *Arg2:* iMethod (Integer)  \n *Arg3:* iType (Integer)  \n *Arg4:* iContactAlgorithm (Integer)  \n *Arg5:* ansysContact (ANSYS_CONTACT)  \n *Arg6:* crplTarget (Cursor Pair List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.MSCNastran.ManualGroup": {
        prefix: "ManualGroup",
        text: "*Name:* Connections.Contacts.MSCNastran.ManualGroup  \n*Desc:* create contacts of MSC Nastran  \n *Arg1:* strName (String)  \n *Arg2:* nastranContact (NASTRAN_CONTACT)  \n *Arg3:* crplTarget (Cursor Pair List)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* iColor (Integer)  \n *Arg6:* iMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.MSCNastran.ContactGroupByMatrix": {
        prefix: "ContactGroupByMatrix",
        text: "*Name:* Connections.Contacts.MSCNastran.ContactGroupByMatrix  \n*Desc:* create contacts of MSC Nastran Contact Group By Matrix  \n *Arg1:* strName (String)  \n *Arg2:* nastranContact (NASTRAN_CONTACT)  \n *Arg3:* crplTarget (Cursor Pair List)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* iColor (Integer)  \n *Arg6:* iMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.MSCNastran.ManualFace": {
        prefix: "ManualFace",
        text: "*Name:* Connections.Contacts.MSCNastran.ManualFace  \n*Desc:* create contacts of MSC Nastran Manual Face  \n *Arg1:* crlFaceMaster (Cursor List)  \n *Arg2:* crlFaceSlave (Cursor List)  \n *Arg3:* strName (String)  \n *Arg4:* nastranContact (NASTRAN_CONTACT)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* iColor (Integer)  \n *Arg7:* iMethod (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.MSCNastran.ContactShareFace": {
        prefix: "ContactShareFace",
        text: "*Name:* Connections.Contacts.MSCNastran.ContactShareFace  \n*Desc:* create contacts of MSC Nastran Contact Share Face  \n *Arg1:* crlShareFace (Cursor List)  \n *Arg2:* strName (String)  \n *Arg3:* nastranContact (NASTRAN_CONTACT)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* iColor (Integer)  \n *Arg6:* iMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.MSCNastran.ContactTable": {
        prefix: "ContactTable",
        text: "*Name:* Connections.Contacts.MSCNastran.ContactTable  \n*Desc:* create contacts of MSC Nastran Contact Table  \n *Arg1:* strName (String)  \n *Arg2:* nastranContact (NASTRAN_CONTACT)  \n *Arg3:* crplTarget (Cursor Pair List)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* iColor (Integer)  \n *Arg6:* iMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.NXNastran.ManualFace": {
        prefix: "ManualFace",
        text: "*Name:* Connections.Contacts.NXNastran.ManualFace  \n*Desc:* Create Contact NXNastran Manual Face  \n *Arg1:* crlFaceMaster (Cursor List)  \n *Arg2:* crlFaceSlave (Cursor List)  \n *Arg3:* strName (String)  \n *Arg4:* iContactType (Integer)  \n *Arg5:* iContactAlg (Integer)  \n *Arg6:* dNorPenFactor (Double)  \n *Arg7:* dTanPenFactor (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.NXNastran.ContactShareFace": {
        prefix: "ContactShareFace",
        text: "*Name:* Connections.Contacts.NXNastran.ContactShareFace  \n*Desc:* Create Contact NXNastran Contact Share Face  \n *Arg1:* crlShareFace (Cursor List)  \n *Arg2:* strName (String)  \n *Arg3:* iContactType (Integer)  \n *Arg4:* iContactAlg (Integer)  \n *Arg5:* dNorPenFactor (Double)  \n *Arg6:* dTanPenFactor (Double)  \n *Arg7:* dForceConTol (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.NXNastran.ContactTable": {
        prefix: "ContactTable",
        text: "*Name:* Connections.Contacts.NXNastran.ContactTable  \n*Desc:* Create Contact NXNastran Contact Table  \n *Arg1:* strName (String)  \n *Arg2:* iType (Integer)  \n *Arg3:* iAlg (Integer)  \n *Arg4:* dNorPenFactor (Double)  \n *Arg5:* dTanPenFactor (Double)  \n *Arg6:* dForceConTol (Double)  \n *Arg7:* dMaxForceIter (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.NXNastran.ManualGroup": {
        prefix: "ManualGroup",
        text: "*Name:* Connections.Contacts.NXNastran.ManualGroup  \n*Desc:* Create Contact NXNastran Manual Group  \n *Arg1:* crFaceMaster (Cursor)  \n *Arg2:* crFaceSlave (Cursor)  \n *Arg3:* strName (String)  \n *Arg4:* iContactType (Integer)  \n *Arg5:* iContactAlg (Integer)  \n *Arg6:* dNorPenFactor (Double)  \n *Arg7:* dTanPenFactor (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.NXNastran.ContactGroupByMatrix": {
        prefix: "ContactGroupByMatrix",
        text: "*Name:* Connections.Contacts.NXNastran.ContactGroupByMatrix  \n*Desc:* Create Contact NXNastran Contact Group By Matrix  \n *Arg1:* crFaceMaster (Cursor)  \n *Arg2:* crFaceSlave (Cursor)  \n *Arg3:* strName (String)  \n *Arg4:* iContactType (Integer)  \n *Arg5:* iContactAlg (Integer)  \n *Arg6:* dNorPenFactor (Double)  \n *Arg7:* dTanPenFactor (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.TSSolver.ManualFace": {
        prefix: "ManualFace",
        text: "*Name:* Connections.Contacts.TSSolver.ManualFace  \n*Desc:* Create TSSolver Contact  \n *Arg1:* strName (String)  \n *Arg2:* nastranContact (NASTRAN_CONTACT)  \n *Arg3:* crplTarget (Cursor Pair List)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* iColor (Integer)  \n *Arg6:* iMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.TSSolver.Auto": {
        prefix: "Auto",
        text: "*Name:* Connections.Contacts.TSSolver.Auto  \n*Desc:* find contact  \n *Arg1:* strlNames (String List)  \n *Arg2:* crllMasterFaceTargets (Cursor List List)  \n *Arg3:* crllSlaveFaceTargets (Cursor List List)  \n *Arg4:* crlContactTypes (Cursor List)  \n *Arg5:* dlInterferenceClosures (Double List)  \n *Arg6:* dlFrictionCoefficients (Double List)  \n *Arg7:* blInitialAdjustments (Boolean List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.TSSolver.ManualGroup": {
        prefix: "ManualGroup",
        text: "*Name:* Connections.Contacts.TSSolver.ManualGroup  \n*Desc:* Create TSSolver Contact  \n *Arg1:* strName (String)  \n *Arg2:* tssolverContact (TSSOLVER_CONTACT)  \n *Arg3:* crplTarget (Cursor Pair List)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* iColor (Integer)  \n *Arg6:* iMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.TSSS.ManualFace": {
        prefix: "ManualFace",
        text: "*Name:* Connections.Contacts.TSSS.ManualFace  \n*Desc:* Create Contact TSSS Manual Face  \n *Arg1:* crlFaceMaster (Cursor List)  \n *Arg2:* crlFaceSlave (Cursor List)  \n *Arg3:* strName (String)  \n *Arg4:* nastranContact (NASTRAN_CONTACT)  \n *Arg5:* crEdit (Cursor)  \n *Arg6:* iColor (Integer)  \n *Arg7:* iMethod (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.TSSS.ManualGroup": {
        prefix: "ManualGroup",
        text: "*Name:* Connections.Contacts.TSSS.ManualGroup  \n*Desc:* Create Contact TSSS Manual FaceGroup  \n *Arg1:* strName (String)  \n *Arg2:* tssolverContact (TSSOLVER_CONTACT)  \n *Arg3:* crplTarget (Cursor Pair List)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* iColor (Integer)  \n *Arg6:* iMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.TSSS.ContactTable": {
        prefix: "ContactTable",
        text: "*Name:* Connections.Contacts.TSSS.ContactTable  \n*Desc:* Create Contact TSSS Manual FaceGroup  \n *Arg1:* strName (String)  \n *Arg2:* nastranContact (NASTRAN_CONTACT)  \n *Arg3:* crplTarget (Cursor Pair List)  \n *Arg4:* crEdit (Cursor)  \n *Arg5:* iColor (Integer)  \n *Arg6:* iMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.CheckPattern": {
        prefix: "CheckPattern",
        text: "*Name:* Connections.Contacts.CheckPattern  \n*Desc:* check contact Pattern  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* bShowMismatch (Boolean)  \n *Arg3:* bShowMatch (Boolean)  \n *Arg4:* dTol (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.NXNastranGeneral": {
        prefix: "NXNastranGeneral",
        text: "*Name:* Connections.Contacts.NXNastranGeneral  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* iPiType (Integer)  \n *Arg3:* iPiAlg (Integer)  \n *Arg4:* dPdNorPenFactor (Double)  \n *Arg5:* dPdTanPenFactor (Double)  \n *Arg6:* dPdForceConTol (Double)  \n *Arg7:* dPdMaxForceIter (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Contacts.ExportCheckReport": {
        prefix: "ExportCheckReport",
        text: "*Name:* Connections.Contacts.ExportCheckReport  \n*Desc:* Unknown Description  \n *Arg1:* strFullPath (String)  \n *Arg2:* dZoomFactor (Double)  \n *Arg3:* iFitBy (Integer)  \n *Arg4:* iListBy (Integer)  \n *Arg5:* iListOrder (Integer)  \n *Arg6:* iFormat (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Gaps.TwoNodes": {
        prefix: "TwoNodes",
        text: "*Name:* Connections.Gaps.TwoNodes  \n*Desc:* create gap connection  \n *Arg1:* crlMaster (Cursor List)  \n *Arg2:* crlSlave (Cursor List)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iOriMode (Integer)  \n *Arg5:* crCoord (Cursor)  \n *Arg6:* strName (String)  \n *Arg7:* dU0 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Gaps.TwoEdges": {
        prefix: "TwoEdges",
        text: "*Name:* Connections.Gaps.TwoEdges  \n*Desc:* create gap connection  \n *Arg1:* crlMaster (Cursor List)  \n *Arg2:* crlSlave (Cursor List)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iOriMode (Integer)  \n *Arg5:* crCoord (Cursor)  \n *Arg6:* strName (String)  \n *Arg7:* dU0 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.Gaps.TwoFaces": {
        prefix: "TwoFaces",
        text: "*Name:* Connections.Gaps.TwoFaces  \n*Desc:* create gap connection  \n *Arg1:* crlMaster (Cursor List)  \n *Arg2:* crlSlave (Cursor List)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iOriMode (Integer)  \n *Arg5:* crCoord (Cursor)  \n *Arg6:* strName (String)  \n *Arg7:* dU0 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.Equation.MultiNodes": {
        prefix: "MultiNodes",
        text: "*Name:* Connections.MPC.Equation.MultiNodes  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.Equation.TwoFace": {
        prefix: "TwoFace",
        text: "*Name:* Connections.MPC.Equation.TwoFace  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.Equation.SemiAuto": {
        prefix: "SemiAuto",
        text: "*Name:* Connections.MPC.Equation.SemiAuto  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.General.NodeToNode": {
        prefix: "NodeToNode",
        text: "*Name:* Connections.MPC.General.NodeToNode  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.General.NodeToEdges": {
        prefix: "NodeToEdges",
        text: "*Name:* Connections.MPC.General.NodeToEdges  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.General.NodeToFaces": {
        prefix: "NodeToFaces",
        text: "*Name:* Connections.MPC.General.NodeToFaces  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.General.TwoEdges": {
        prefix: "TwoEdges",
        text: "*Name:* Connections.MPC.General.TwoEdges  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.General.FacesToFaces": {
        prefix: "FacesToFaces",
        text: "*Name:* Connections.MPC.General.FacesToFaces  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.General.NodesToNodes": {
        prefix: "NodesToNodes",
        text: "*Name:* Connections.MPC.General.NodesToNodes  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.General.TwoFaces": {
        prefix: "TwoFaces",
        text: "*Name:* Connections.MPC.General.TwoFaces  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.General.NodeToAny": {
        prefix: "NodeToAny",
        text: "*Name:* Connections.MPC.General.NodeToAny  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.MPC.General.NodesWithTolerance": {
        prefix: "NodesWithTolerance",
        text: "*Name:* Connections.MPC.General.NodesWithTolerance  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crlMaster (Cursor List)  \n *Arg3:* crlSlave (Cursor List)  \n *Arg4:* listMpcConnection (MPC_CONNECTION List)  \n *Arg5:* dSearchTol (Double)  \n *Arg6:* dValue (Double)  \n *Arg7:* iMPCType (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBar.OneToOne": {
        prefix: "OneToOne",
        text: "*Name:* Connections.RigidElements.RBar.OneToOne  \n*Desc:* create RBar  \n *Arg1:* strName (String)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iUlDOFs (Integer)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBar.OneToMany": {
        prefix: "OneToMany",
        text: "*Name:* Connections.RigidElements.RBar.OneToMany  \n*Desc:* create RBar  \n *Arg1:* strName (String)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iUlDOFs (Integer)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBar.OneToOneNodesWithTolerance": {
        prefix: "OneToOneNodesWithTolerance",
        text: "*Name:* Connections.RigidElements.RBar.OneToOneNodesWithTolerance  \n*Desc:* create RBar  \n *Arg1:* strName (String)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iUlDOFs (Integer)  \n *Arg6:* dTol (Double)  \n *Arg7:* crCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBE2.OneToMany": {
        prefix: "OneToMany",
        text: "*Name:* Connections.RigidElements.RBE2.OneToMany  \n*Desc:* create RBE2  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iEType (Integer)  \n *Arg5:* strName (String)  \n *Arg6:* crCoordSys (Cursor)  \n *Arg7:* dTolerance (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBE2.OneToOne": {
        prefix: "OneToOne",
        text: "*Name:* Connections.RigidElements.RBE2.OneToOne  \n*Desc:* create RBE2  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iEType (Integer)  \n *Arg5:* strName (String)  \n *Arg6:* crCoordSys (Cursor)  \n *Arg7:* dTolerance (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBE2.OneToOneNodesWithTolerance": {
        prefix: "OneToOneNodesWithTolerance",
        text: "*Name:* Connections.RigidElements.RBE2.OneToOneNodesWithTolerance  \n*Desc:* create RBE2  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iEType (Integer)  \n *Arg5:* strName (String)  \n *Arg6:* crCoordSys (Cursor)  \n *Arg7:* dTolerance (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBE2.ToCenter": {
        prefix: "ToCenter",
        text: "*Name:* Connections.RigidElements.RBE2.ToCenter  \n*Desc:* create RBE2  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iEType (Integer)  \n *Arg5:* strName (String)  \n *Arg6:* crCoordSys (Cursor)  \n *Arg7:* dTolerance (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBE2.ToCircleCenter": {
        prefix: "ToCircleCenter",
        text: "*Name:* Connections.RigidElements.RBE2.ToCircleCenter  \n*Desc:* create RBE2  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iEType (Integer)  \n *Arg5:* strName (String)  \n *Arg6:* crCoordSys (Cursor)  \n *Arg7:* dTolerance (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBE3.OneToMany": {
        prefix: "OneToMany",
        text: "*Name:* Connections.RigidElements.RBE3.OneToMany  \n*Desc:* Create RBE3  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* listRbe3TermConnection (RBE3TERM_CONNECTION List)  \n *Arg5:* iTypeRBE3 (Integer)  \n *Arg6:* strName (String)  \n *Arg7:* crCoordSys (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBE3.OneToOne": {
        prefix: "OneToOne",
        text: "*Name:* Connections.RigidElements.RBE3.OneToOne  \n*Desc:* Create RBE3  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* listRbe3TermConnection (RBE3TERM_CONNECTION List)  \n *Arg5:* iTypeRBE3 (Integer)  \n *Arg6:* strName (String)  \n *Arg7:* crCoordSys (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBE3.ToCenter": {
        prefix: "ToCenter",
        text: "*Name:* Connections.RigidElements.RBE3.ToCenter  \n*Desc:* Create RBE3  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* listRbe3TermConnection (RBE3TERM_CONNECTION List)  \n *Arg5:* iTypeRBE3 (Integer)  \n *Arg6:* strName (String)  \n *Arg7:* crCoordSys (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBE3.ToCircleCenter": {
        prefix: "ToCircleCenter",
        text: "*Name:* Connections.RigidElements.RBE3.ToCircleCenter  \n*Desc:* Create RBE3  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* listRbe3TermConnection (RBE3TERM_CONNECTION List)  \n *Arg5:* iTypeRBE3 (Integer)  \n *Arg6:* strName (String)  \n *Arg7:* crCoordSys (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.RigidElements.RBarGeneral": {
        prefix: "RBarGeneral",
        text: "*Name:* Connections.RigidElements.RBarGeneral  \n*Desc:* Unknown Description  \n *Arg1:* rbarConnection (RBAR_CONNECTION)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iUlDOFs (Integer)  \n *Arg5:* dTol (Double)  \n *Arg6:* crCoord (Cursor)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* iEType (Integer)  \n *Arg5:* strName (String)  \n *Arg6:* crCoordSys (Cursor)  \n *Arg7:* dTolerance (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlMasterTarget (Cursor List)  \n *Arg3:* crlSlaveTarget (Cursor List)  \n *Arg4:* listRbe3TermConnection (RBE3TERM_CONNECTION List)  \n *Arg5:* iTypeRBE3 (Integer)  \n *Arg6:* strName (String)  \n *Arg7:* crCoordSys (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Create Damper Connection  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMasterTarget (Cursor List)  \n *Arg4:* crlSlaveTarget (Cursor List)  \n *Arg5:* crCoordSys (Cursor)  \n *Arg6:* iGround (Integer)  \n *Arg7:* dTolerance (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.SpringsDampers.BushGeneral": {
        prefix: "BushGeneral",
        text: "*Name:* Connections.SpringsDampers.BushGeneral  \n*Desc:* Unknown Description  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMaster (Cursor List)  \n *Arg4:* crlSlave (Cursor List)  \n *Arg5:* crCoord (Cursor)  \n *Arg6:* dTol (Double)  \n *Arg7:* iGround (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.SpringsDampers.Bush.TwoNodes": {
        prefix: "TwoNodes",
        text: "*Name:* Connections.SpringsDampers.Bush.TwoNodes  \n*Desc:* Create bush connection  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMaster (Cursor List)  \n *Arg4:* crlSlave (Cursor List)  \n *Arg5:* crCoord (Cursor)  \n *Arg6:* dTol (Double)  \n *Arg7:* iGround (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.SpringsDampers.Bush.AnyEntities": {
        prefix: "AnyEntities",
        text: "*Name:* Connections.SpringsDampers.Bush.AnyEntities  \n*Desc:* Create bush connection  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMaster (Cursor List)  \n *Arg4:* crlSlave (Cursor List)  \n *Arg5:* crCoord (Cursor)  \n *Arg6:* dTol (Double)  \n *Arg7:* iGround (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.SpringsDampers.Bush.OnetoOne": {
        prefix: "OnetoOne",
        text: "*Name:* Connections.SpringsDampers.Bush.OnetoOne  \n*Desc:* Create bush connection  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMaster (Cursor List)  \n *Arg4:* crlSlave (Cursor List)  \n *Arg5:* crCoord (Cursor)  \n *Arg6:* dTol (Double)  \n *Arg7:* iGround (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.SpringsDampers.Spring.GroundedSpring": {
        prefix: "GroundedSpring",
        text: "*Name:* Connections.SpringsDampers.Spring.GroundedSpring  \n*Desc:* Grounded Spring connection  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMasterTarget (Cursor List)  \n *Arg4:* crlSlaveTarget (Cursor List)  \n *Arg5:* crCoordSys (Cursor)  \n *Arg6:* iSpringType (Integer)  \n *Arg7:* iGround (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.SpringsDampers.Spring.Nodeswithtolerance.sameDoFs": {
        prefix: "sameDoFs",
        text: "*Name:* Connections.SpringsDampers.Spring.Nodeswithtolerance.sameDoFs  \n*Desc:* Spring connection Nodes with tolerance same DOFs  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMasterTarget (Cursor List)  \n *Arg4:* crlSlaveTarget (Cursor List)  \n *Arg5:* crCoordSys (Cursor)  \n *Arg6:* iSpringType (Integer)  \n *Arg7:* iGround (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.SpringsDampers.Spring.Nodeswithtolerance.differentDoFs": {
        prefix: "differentDoFs",
        text: "*Name:* Connections.SpringsDampers.Spring.Nodeswithtolerance.differentDoFs  \n*Desc:* Spring connection Nodes with tolerance different DOFs  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMasterTarget (Cursor List)  \n *Arg4:* crlSlaveTarget (Cursor List)  \n *Arg5:* crCoordSys (Cursor)  \n *Arg6:* iSpringType (Integer)  \n *Arg7:* iGround (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.SpringsDampers.Spring.OneToOne.sameDoFs": {
        prefix: "sameDoFs",
        text: "*Name:* Connections.SpringsDampers.Spring.OneToOne.sameDoFs  \n*Desc:* Spring connection One to One same DOFs  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMasterTarget (Cursor List)  \n *Arg4:* crlSlaveTarget (Cursor List)  \n *Arg5:* crCoordSys (Cursor)  \n *Arg6:* iSpringType (Integer)  \n *Arg7:* iGround (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Connections.SpringsDampers.Spring.OneToOne.differentDoFs": {
        prefix: "differentDoFs",
        text: "*Name:* Connections.SpringsDampers.Spring.OneToOne.differentDoFs  \n*Desc:* Spring connection One to One different DOFs  \n *Arg1:* iMethod (Integer)  \n *Arg2:* strName (String)  \n *Arg3:* crlMasterTarget (Cursor List)  \n *Arg4:* crlSlaveTarget (Cursor List)  \n *Arg5:* crCoordSys (Cursor)  \n *Arg6:* iSpringType (Integer)  \n *Arg7:* iGround (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Designer.LBC.TemperatureLoad": {
        prefix: "TemperatureLoad",
        text: "*Name:* Designer.LBC.TemperatureLoad  \n*Desc:* create temperature load Desiner  \n *Arg1:* strName (String)  \n *Arg2:* iDnType (Integer)  \n *Arg3:* dFTemp (Double)  \n *Arg4:* strDstrFilePathName (String)  \n *Arg5:* crDcrTable (Cursor)  \n *Arg6:* crlTarget (Cursor List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Designer.Load.Moment": {
        prefix: "Moment",
        text: "*Name:* Designer.Load.Moment  \n*Desc:* Create moment  \n *Arg1:* strName (String)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* dlVecMomentXYZ (Double List)  \n *Arg4:* crCoord (Cursor)  \n *Arg5:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Designer.ContactMerge": {
        prefix: "ContactMerge",
        text: "*Name:* Designer.ContactMerge  \n*Desc:* Build contact for designer  \n *Arg1:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Designer.Material": {
        prefix: "Material",
        text: "*Name:* Designer.Material  \n*Desc:* Unknown Description  \n *Arg1:* strMatName (String)  \n *Arg2:* strPropName (String)  \n *Arg3:* dThickness (Double)  \n *Arg4:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "EngReliability.SubModelBC": {
        prefix: "SubModelBC",
        text: "*Name:* EngReliability.SubModelBC  \n*Desc:* create mapping forced displacement  \n *Arg1:* strName (String)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* iPos (Integer)  \n *Arg4:* iViewCp (Integer)  \n *Arg5:* iCp (Integer)  \n *Arg6:* iSrcType (Integer)  \n *Arg7:* iMappedCpIndexArr0 (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:*   \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlPart (Cursor List)  \n *Arg3:* dLayerWidth (Double)  \n *Arg4:* iLayerNumber (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Bar.TwoNodes": {
        prefix: "TwoNodes",
        text: "*Name:* Geometry.Bar.TwoNodes  \n*Desc:* Create Bar Body  \n *Arg1:* strPartName (String)  \n *Arg2:* iMeshCount (Integer)  \n *Arg3:* crStartNode (Cursor)  \n *Arg4:* crEndNode (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Bar.Arc": {
        prefix: "Arc",
        text: "*Name:* Geometry.Bar.Arc  \n*Desc:* Create Edge by spline  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* crPart (Cursor)  \n *Arg3:* strBarName (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Bar.Spline": {
        prefix: "Spline",
        text: "*Name:* Geometry.Bar.Spline  \n*Desc:* Create Edge by spline  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* crPart (Cursor)  \n *Arg3:* strBarName (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.BodyCut.XXYYOnOnePoint": {
        prefix: "XXYYOnOnePoint",
        text: "*Name:* Geometry.BodyCut.XXYYOnOnePoint  \n*Desc:* Cut body by one point  \n *Arg1:* crPart (Cursor)  \n *Arg2:* posCutPos (Position)  \n *Arg3:* iType (Integer)  \n *Arg4:* dOffset (Double)  \n *Arg5:* bSplit (Boolean)  \n *Arg6:* bSectionFace (Boolean)  \n *Arg7:* bShateFace (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.BodyCut.BySurface": {
        prefix: "BySurface",
        text: "*Name:* Geometry.BodyCut.BySurface  \n*Desc:* Cut body by surface  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crCutter (Cursor)  \n *Arg3:* bSplitOnly (Boolean)  \n *Arg4:* bMakeSectionFace (Boolean)  \n *Arg5:* bShareFace (Boolean)  \n *Arg6:* bSeparateFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Body Cut by 3 Points  \n *Arg1:* crPart (Cursor)  \n *Arg2:* poslPosition (Position List)  \n *Arg3:* dOffset (Double)  \n *Arg4:* bSplitonly (Boolean)  \n *Arg5:* bMakesectionface (Boolean)  \n *Arg6:* bShareface (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.BreakEntity.StlPart": {
        prefix: "StlPart",
        text: "*Name:* Geometry.BreakEntity.StlPart  \n*Desc:* break STL part  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iMinNoOfFaces (Integer)  \n *Arg3:* iMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.BreakEntity.Face": {
        prefix: "Face",
        text: "*Name:* Geometry.BreakEntity.Face  \n*Desc:* break entity for face  \n *Arg1:* crlFace (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.BreakEntity.Edge": {
        prefix: "Edge",
        text: "*Name:* Geometry.BreakEntity.Edge  \n*Desc:* Break selected edge  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* crlEdge (Cursor List)  \n *Arg4:* crlNode (Cursor List)  \n *Arg5:* bAutoByAngle (Boolean)  \n *Arg6:* dEdgeAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.BreakEntity.Part": {
        prefix: "Part",
        text: "*Name:* Geometry.BreakEntity.Part  \n*Desc:* Separate Part  \n *Arg1:* crlPart (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.DeleteEntity.Part": {
        prefix: "Part",
        text: "*Name:* Geometry.DeleteEntity.Part  \n*Desc:* Delete Part  \n *Arg1:* crlPart (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.DeleteEntity.Edge": {
        prefix: "Edge",
        text: "*Name:* Geometry.DeleteEntity.Edge  \n*Desc:* Delete Edge  \n *Arg1:* crlEdge (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.DeleteEntity.Vertex": {
        prefix: "Vertex",
        text: "*Name:* Geometry.DeleteEntity.Vertex  \n*Desc:* delete vertex  \n *Arg1:* crlVertex (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.DeleteEntity.Face": {
        prefix: "Face",
        text: "*Name:* Geometry.DeleteEntity.Face  \n*Desc:* Delete Face  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* bKeepSolid (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.Line": {
        prefix: "Line",
        text: "*Name:* Geometry.Edge.Line  \n*Desc:* Imprint line 2 point  \n *Arg1:* poslPositions (Position List)  \n *Arg2:* crlTargetFace (Cursor List)  \n *Arg3:* bBreakFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.Spline": {
        prefix: "Spline",
        text: "*Name:* Geometry.Edge.Spline  \n*Desc:* Imprint a Spline on a face  \n *Arg1:* veclAprroxiPositions (Vector List)  \n *Arg2:* crlTargetFace (Cursor List)  \n *Arg3:* bBreakFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.PlanarLine": {
        prefix: "PlanarLine",
        text: "*Name:* Geometry.Edge.PlanarLine  \n*Desc:* Imprint Planar Line  \n *Arg1:* veclPosition (Vector List)  \n *Arg2:* crlTargetFace (Cursor List)  \n *Arg3:* crLocalCoord (Cursor)  \n *Arg4:* iType (Integer)  \n *Arg5:* bBreakFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.Circle": {
        prefix: "Circle",
        text: "*Name:* Geometry.Edge.Circle  \n*Desc:* Imprint Cirlcle Line S  \n *Arg1:* veclPositions (Vector List)  \n *Arg2:* crlTargetFace (Cursor List)  \n *Arg3:* dInRadius (Double)  \n *Arg4:* dOutRadius (Double)  \n *Arg5:* iNoOfLayer (Integer)  \n *Arg6:* iNoOfDiv (Integer)  \n *Arg7:* bBreakFace (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.PerpendicularLineOfEdge": {
        prefix: "PerpendicularLineOfEdge",
        text: "*Name:* Geometry.Edge.PerpendicularLineOfEdge  \n*Desc:* Imprint the perpendicular line of edge  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* dOffset (Double)  \n *Arg4:* bReakFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.ExtendLine": {
        prefix: "ExtendLine",
        text: "*Name:* Geometry.Edge.ExtendLine  \n*Desc:* make edge by extend line  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* iMethod (Integer)  \n *Arg3:* iEnd (Integer)  \n *Arg4:* iNoFittingPoints (Integer)  \n *Arg5:* iDiv (Integer)  \n *Arg6:* iEnableBreakFace (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.ElementEdges": {
        prefix: "ElementEdges",
        text: "*Name:* Geometry.Edge.ElementEdges  \n*Desc:* Create Edge by element edges  \n *Arg1:* crplElemEdge (Cursor Pair List)  \n *Arg2:* bBreakEdge (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.Angle": {
        prefix: "Angle",
        text: "*Name:* Geometry.Edge.Angle  \n*Desc:* create new adge by convert angle  \n *Arg1:* crpPair (Cursor Pair)  \n *Arg2:* dAngle (Double)  \n *Arg3:* bCurvature (Boolean)  \n *Arg4:* bBreakFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.NodeShortestPath": {
        prefix: "NodeShortestPath",
        text: "*Name:* Geometry.Edge.NodeShortestPath  \n*Desc:* create edge by 2 nodes shortest path  \n *Arg1:* crFirstNode (Cursor)  \n *Arg2:* crSecondNode (Cursor)  \n *Arg3:* iEnableBreakFace (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.OffsetLine": {
        prefix: "OffsetLine",
        text: "*Name:* Geometry.Edge.OffsetLine  \n*Desc:* Imprint geometry edge offset line  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlEdge (Cursor List)  \n *Arg3:* bBreakFace (Boolean)  \n *Arg4:* dOffsetDistance (Double)  \n *Arg5:* iNumberLayer (Integer)  \n *Arg6:* bMerge (Boolean)  \n *Arg7:* bExtend (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.SplineFreeEdges": {
        prefix: "SplineFreeEdges",
        text: "*Name:* Geometry.Edge.SplineFreeEdges  \n*Desc:* Create Edge by spline  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* iEnableArc (Integer)  \n *Arg3:* crPart (Cursor)  \n *Arg4:* strBarName (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.ClosedLine": {
        prefix: "ClosedLine",
        text: "*Name:* Geometry.Edge.ClosedLine  \n*Desc:* imprint closed line  \n *Arg1:* veclPositions (Vector List)  \n *Arg2:* crlTargetFace (Cursor List)  \n *Arg3:* iEnableBreakFace (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.PerpendicularCylinderLine": {
        prefix: "PerpendicularCylinderLine",
        text: "*Name:* Geometry.Edge.PerpendicularCylinderLine  \n*Desc:*   \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* dOffset (Double)  \n *Arg5:* bOppositeSide (Boolean)  \n *Arg6:* bBreakFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.IntersectionLine": {
        prefix: "IntersectionLine",
        text: "*Name:* Geometry.Edge.IntersectionLine  \n*Desc:*   \n *Arg1:* crlFaces (Cursor List)  \n *Arg2:* bBreakFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.ProjectLine": {
        prefix: "ProjectLine",
        text: "*Name:* Geometry.Edge.ProjectLine  \n*Desc:*   \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* crlFaces (Cursor List)  \n *Arg3:* crlNode (Cursor List)  \n *Arg4:* bBreakFace (Boolean)  \n *Arg5:* iType (Integer)  \n *Arg6:* bCheckGap (Boolean)  \n *Arg7:* dGap (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Edge.PerpendicularLineToEdge": {
        prefix: "PerpendicularLineToEdge",
        text: "*Name:* Geometry.Edge.PerpendicularLineToEdge  \n*Desc:*   \n *Arg1:* crNode (Cursor)  \n *Arg2:* crEdge (Cursor)  \n *Arg3:* crlFace (Cursor List)  \n *Arg4:* bBreakFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.ExtractSurfaces.ExtractRefSurface": {
        prefix: "ExtractRefSurface",
        text: "*Name:* Geometry.ExtractSurfaces.ExtractRefSurface  \n*Desc:* Unknown Description  \n *Arg1:* listFace (FACE List)  \n *Arg2:* dAngle (Double)  \n *Arg3:* strName (String)  \n *Arg4:* isMergePart (IS_MERGE_PART)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.ExtractSurfaces.ExtractSurfaces": {
        prefix: "ExtractSurfaces",
        text: "*Name:* Geometry.ExtractSurfaces.ExtractSurfaces  \n*Desc:* Unknown Description  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dAngle (Double)  \n *Arg3:* strName (String)  \n *Arg4:* bMergePart (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Face.FourEdges": {
        prefix: "FourEdges",
        text: "*Name:* Geometry.Face.FourEdges  \n*Desc:* Create face by four edges  \n *Arg1:* crlEdge (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Face.FromMesh": {
        prefix: "FromMesh",
        text: "*Name:* Geometry.Face.FromMesh  \n*Desc:* Create geometry face from mesh face  \n *Arg1:* crlFace (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Face.CreateSmoothFace": {
        prefix: "CreateSmoothFace",
        text: "*Name:* Geometry.Face.CreateSmoothFace  \n*Desc:* Geometry Face CreateSmoothFace  \n *Arg1:* bInterPoration (Boolean)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* iElemGeneration (Integer)  \n *Arg4:* dGradation (Double)  \n *Arg5:* iEnableFaceSmooth (Integer)  \n *Arg6:* crTargetPart (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Face.Edges": {
        prefix: "Edges",
        text: "*Name:* Geometry.Face.Edges  \n*Desc:* Create Face From Edges  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* crlPart (Cursor List)  \n *Arg3:* crlNode (Cursor List)  \n *Arg4:* bSharedFace (Boolean)  \n *Arg5:* bSmoothFace (Boolean)  \n *Arg6:* bCreatePart (Boolean)  \n *Arg7:* bImproved (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Face.Elements": {
        prefix: "Elements",
        text: "*Name:* Geometry.Face.Elements  \n*Desc:* Create Face By Elements  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* bShareFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.FindFeature.DelCircChamfer": {
        prefix: "DelCircChamfer",
        text: "*Name:* Geometry.FindFeature.DelCircChamfer  \n*Desc:* Delete Circ Chamfer  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* dMaxThick (Double)  \n *Arg3:* dMinThick (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.FindFeature.Fillet": {
        prefix: "Fillet",
        text: "*Name:* Geometry.FindFeature.Fillet  \n*Desc:* Find feature in part by typical description  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* dMinAngle (Double)  \n *Arg4:* dMaxAngle (Double)  \n *Arg5:* dMinFaceWidth (Double)  \n *Arg6:* dMaxFaceWidth (Double)  \n *Arg7:* dMinCurveRadius (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.FindFeature.Faces": {
        prefix: "Faces",
        text: "*Name:* Geometry.FindFeature.Faces  \n*Desc:* Unknown Description  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlEdge (Cursor List)  \n *Arg3:* bCylinder (Boolean)  \n *Arg4:* bDisc (Boolean)  \n *Arg5:* bFourCorners (Boolean)  \n *Arg6:* dMinThickness (Double)  \n *Arg7:* dMaxThickness (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.FindFeature.Edges": {
        prefix: "Edges",
        text: "*Name:* Geometry.FindFeature.Edges  \n*Desc:* Unknown Description  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlEdge (Cursor List)  \n *Arg3:* bCylinder (Boolean)  \n *Arg4:* bDisc (Boolean)  \n *Arg5:* bFourCorners (Boolean)  \n *Arg6:* dMinThickness (Double)  \n *Arg7:* dMaxThickness (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.MergeEntities.Faces": {
        prefix: "Faces",
        text: "*Name:* Geometry.MergeEntities.Faces  \n*Desc:* Merge faces  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* bMergeEdge (Boolean)  \n *Arg3:* bRemoveNonBoundEdge (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.MergeEntities.TinyFacesMerge": {
        prefix: "TinyFacesMerge",
        text: "*Name:* Geometry.MergeEntities.TinyFacesMerge  \n*Desc:* merge tiny faces  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* dMinFaceWidth (Double)  \n *Arg4:* dMaxFaceWidth (Double)  \n *Arg5:* dFaceAngle (Double)  \n *Arg6:* bReferLocalSetting (Boolean)  \n *Arg7:* bConnectFace (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.MergeEntities.CBarParts": {
        prefix: "CBarParts",
        text: "*Name:* Geometry.MergeEntities.CBarParts  \n*Desc:* Merge CBar Parts  \n *Arg1:* crlCBarPart (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.MergeEntities.Edges": {
        prefix: "Edges",
        text: "*Name:* Geometry.MergeEntities.Edges  \n*Desc:* Merge Edge  \n *Arg1:* crlEdge (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.MergeEntities.Parts": {
        prefix: "Parts",
        text: "*Name:* Geometry.MergeEntities.Parts  \n*Desc:* Merge Part  \n *Arg1:* dTolerance (Double)  \n *Arg2:* bRemovesharefaceflag (Boolean)  \n *Arg3:* crlPart (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.MergeEntities.PartFaces": {
        prefix: "PartFaces",
        text: "*Name:* Geometry.MergeEntities.PartFaces  \n*Desc:* Merge by Part Faces  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* bAngle (Boolean)  \n *Arg4:* dTolAngle (Double)  \n *Arg5:* bWidth (Boolean)  \n *Arg6:* dTolWidth (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Part.Cube": {
        prefix: "Cube",
        text: "*Name:* Geometry.Part.Cube  \n*Desc:* create cube part  \n *Arg1:* 0 (0)  \n *Arg2:* 0] (0])  \n *Arg3:* dlOrigin (Double List)  \n *Arg4:* 0.01 (0.01)  \n *Arg5:* 0.01] (0.01])  \n *Arg6:* dlLength (Double List)  \n *Arg7:* 10 (10)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Part.Wedge": {
        prefix: "Wedge",
        text: "*Name:* Geometry.Part.Wedge  \n*Desc:* Create Wedge Body  \n *Arg1:* 0.0 (0.0)  \n *Arg2:* 0.0] (0.0])  \n *Arg3:* vecOrigin (Vector)  \n *Arg4:* 0.01 (0.01)  \n *Arg5:* 0.01] (0.01])  \n *Arg6:* vecLength (Vector)  \n *Arg7:* 10 (10)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Part.Sphere": {
        prefix: "Sphere",
        text: "*Name:* Geometry.Part.Sphere  \n*Desc:* create Sphere part  \n *Arg1:* 0 (0)  \n *Arg2:* 0] (0])  \n *Arg3:* dlOrigin (Double List)  \n *Arg4:* dRadius (Double)  \n *Arg5:* iLatitudeNodeCnt (Integer)  \n *Arg6:* iLongitudeNodeCnt (Integer)  \n *Arg7:* strPartName (String)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Part.Torus": {
        prefix: "Torus",
        text: "*Name:* Geometry.Part.Torus  \n*Desc:* create Torus part  \n *Arg1:* 0 (0)  \n *Arg2:* 0] (0])  \n *Arg3:* dlOrigin (Double List)  \n *Arg4:* dInnerRadius (Double)  \n *Arg5:* dRingRadius (Double)  \n *Arg6:* iLatitudeNodeCnt (Integer)  \n *Arg7:* iLongitudeNodeCnt (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Part.Elems": {
        prefix: "Elems",
        text: "*Name:* Geometry.Part.Elems  \n*Desc:* create part from element  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* strPartName (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Part.Cylinder": {
        prefix: "Cylinder",
        text: "*Name:* Geometry.Part.Cylinder  \n*Desc:* create cylinder part  \n *Arg1:* dlOrigin (Double List)  \n *Arg2:* dTopRadius (Double)  \n *Arg3:* dBotRadius (Double)  \n *Arg4:* dHeight (Double)  \n *Arg5:* iCircleNodeCnt (Integer)  \n *Arg6:* iAxisNodeCnt (Integer)  \n *Arg7:* strName (String)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Part.Tube": {
        prefix: "Tube",
        text: "*Name:* Geometry.Part.Tube  \n*Desc:* create tube part  \n *Arg1:* dlOrigin (Double List)  \n *Arg2:* dTopInnerRadius (Double)  \n *Arg3:* dTopOuterRadius (Double)  \n *Arg4:* dBotInnerRadius (Double)  \n *Arg5:* dBotOuterRadius (Double)  \n *Arg6:* dHeight (Double)  \n *Arg7:* iCircleNodeCnt (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Part.Trapezoid": {
        prefix: "Trapezoid",
        text: "*Name:* Geometry.Part.Trapezoid  \n*Desc:* Create trapezoid part  \n *Arg1:* dlOrigin (Double List)  \n *Arg2:* 0.01 (0.01)  \n *Arg3:* 0.01] (0.01])  \n *Arg4:* dlLength (Double List)  \n *Arg5:* dTopXLength (Double)  \n *Arg6:* dRadius (Double)  \n *Arg7:* 10 (10)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Part.Cone": {
        prefix: "Cone",
        text: "*Name:* Geometry.Part.Cone  \n*Desc:* Create Cone Body  \n *Arg1:* dlOriginXyz (Double List)  \n *Arg2:* dBottomRadius (Double)  \n *Arg3:* dHeight (Double)  \n *Arg4:* iCircleNodeCount (Integer)  \n *Arg5:* iAxisNodeCnt (Integer)  \n *Arg6:* strPartName (String)  \n *Arg7:* iPartColor (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.ShowAdjacent.Faces": {
        prefix: "Faces",
        text: "*Name:* Geometry.ShowAdjacent.Faces  \n*Desc:* Unknown Description  \n *Arg1:* dAngle (Double)  \n *Arg2:* iIncludeStopFace (Integer)  \n *Arg3:* iLayer (Integer)  \n *Arg4:* bIsPreview (Boolean)  \n *Arg5:* crlStartFace (Cursor List)  \n *Arg6:* crlStopFace (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.ShowAdjacent.Elements": {
        prefix: "Elements",
        text: "*Name:* Geometry.ShowAdjacent.Elements  \n*Desc:* Unknown Description  \n *Arg1:* dAngle (Double)  \n *Arg2:* iIncludeStopFace (Integer)  \n *Arg3:* iLayer (Integer)  \n *Arg4:* bIsPreview (Boolean)  \n *Arg5:* crlStartElem (Cursor List)  \n *Arg6:* crlStopElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Transform.Rotation": {
        prefix: "Rotation",
        text: "*Name:* Geometry.Transform.Rotation  \n*Desc:* Rotate the selected Part.  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* posCenter (Position)  \n *Arg3:* vecAxis (Vector)  \n *Arg4:* dAngle (Double)  \n *Arg5:* bCreateNewPart (Boolean)  \n *Arg6:* bCopyLBC (Boolean)  \n *Arg7:* bCopyProperty (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Transform.Scaling": {
        prefix: "Scaling",
        text: "*Name:* Geometry.Transform.Scaling  \n*Desc:* Scale Body  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* dlScaleVector (Double List)  \n *Arg3:* dlScaleCentre (Double List)  \n *Arg4:* crCoordinate (Cursor)  \n *Arg5:* bCreateNew (Boolean)  \n *Arg6:* bCopyLbc (Boolean)  \n *Arg7:* bCopyProperty (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Transform.Mirror": {
        prefix: "Mirror",
        text: "*Name:* Geometry.Transform.Mirror  \n*Desc:* mirror body  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* 0.0 (0.0)  \n *Arg3:* 0.0]] (0.0]])  \n *Arg4:* veclPoint (Vector List)  \n *Arg5:* dOffset (Double)  \n *Arg6:* bCreateNewPart (Boolean)  \n *Arg7:* bCopyLBC (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Transform.Position": {
        prefix: "Position",
        text: "*Name:* Geometry.Transform.Position  \n*Desc:* transform position  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* 0.0 (0.0)  \n *Arg3:* 0.0]] (0.0]])  \n *Arg4:* veclPoint (Vector List)  \n *Arg5:* bCreateNewPart (Boolean)  \n *Arg6:* bCopyLBC (Boolean)  \n *Arg7:* bCopyProperty (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Transform.Translation": {
        prefix: "Translation",
        text: "*Name:* Geometry.Transform.Translation  \n*Desc:* Translate the selected Part.  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* poslTranslates (Position List)  \n *Arg3:* crCoord (Cursor)  \n *Arg4:* bCreateNewPart (Boolean)  \n *Arg5:* bCopyLBC (Boolean)  \n *Arg6:* bCopyProperty (Boolean)  \n *Arg7:* iCopyCount (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Transform.MatingFace": {
        prefix: "MatingFace",
        text: "*Name:* Geometry.Transform.MatingFace  \n*Desc:* Transform MatingFace  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crSrcFace (Cursor)  \n *Arg3:* crDstFace (Cursor)  \n *Arg4:* crSrcEdge (Cursor)  \n *Arg5:* crDstEdge (Cursor)  \n *Arg6:* crSrcNode (Cursor)  \n *Arg7:* crDstNode (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.Transform.CylinderFace": {
        prefix: "CylinderFace",
        text: "*Name:* Geometry.Transform.CylinderFace  \n*Desc:* transform position  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* 0.0 (0.0)  \n *Arg3:* 0.0]] (0.0]])  \n *Arg4:* veclPoint (Vector List)  \n *Arg5:* bCreateNewPart (Boolean)  \n *Arg6:* bCopyLBC (Boolean)  \n *Arg7:* bCopyProperty (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.CADTrim": {
        prefix: "CADTrim",
        text: "*Name:* Geometry.CADTrim  \n*Desc:* CAD Trim  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlPart (Cursor List)  \n *Arg3:* dTrimSize (Double)  \n *Arg4:* dTrimAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.StitchEdge": {
        prefix: "StitchEdge",
        text: "*Name:* Geometry.StitchEdge  \n*Desc:* Stitch Edges  \n *Arg1:* dTolerance (Double)  \n *Arg2:* bKeepSlave (Boolean)  \n *Arg3:* crlMaster (Cursor List)  \n *Arg4:* crlSlave (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.LogoRemoval": {
        prefix: "LogoRemoval",
        text: "*Name:* Geometry.LogoRemoval  \n*Desc:* Create Face From Edges  \n *Arg1:* crlStartFaces (Cursor List)  \n *Arg2:* crlStopFaces (Cursor List)  \n *Arg3:* iLayers (Integer)  \n *Arg4:* bMergeFaces (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.ShellAsm": {
        prefix: "ShellAsm",
        text: "*Name:* Geometry.ShellAsm  \n*Desc:* assemble the separated parts  \n *Arg1:* crlPartK (Cursor List)  \n *Arg2:* crlFaceK (Cursor List)  \n *Arg3:* dTol (Double)  \n *Arg4:* iElemType (Integer)  \n *Arg5:* bSkipTiny (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.SquareUpFillet": {
        prefix: "SquareUpFillet",
        text: "*Name:* Geometry.SquareUpFillet  \n*Desc:* Square Up Fillet  \n *Arg1:* crlFace (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.MakeFillet": {
        prefix: "MakeFillet",
        text: "*Name:* Geometry.MakeFillet  \n*Desc:*   \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* dRadius (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.MakeFacePlanar": {
        prefix: "MakeFacePlanar",
        text: "*Name:* Geometry.MakeFacePlanar  \n*Desc:* Make planar faces by given plane points  \n *Arg1:* dlPlanePt1 (Double List)  \n *Arg2:* dlPlanePt2 (Double List)  \n *Arg3:* dlPlanePt3 (Double List)  \n *Arg4:* ilFaceIds (Integer List)  \n *Arg5:* iMergeFace (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.FCircleAdjustVertex": {
        prefix: "FCircleAdjustVertex",
        text: "*Name:* Geometry.FCircleAdjustVertex  \n*Desc:* adjust vertex in circle  \n *Arg1:* crlPart (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.AdjustHalfCylinder": {
        prefix: "AdjustHalfCylinder",
        text: "*Name:* Geometry.AdjustHalfCylinder  \n*Desc:* Adjust half cylinder  \n *Arg1:* poslPoint (Position List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* crCoord (Cursor)  \n *Arg4:* iAxisPlane (Integer)  \n *Arg5:* bDivideFace (Boolean)  \n *Arg6:* crlPart (Cursor List)  \n *Arg7:* bMergeEdge (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.FCircVertexAdjust": {
        prefix: "FCircVertexAdjust",
        text: "*Name:* Geometry.FCircVertexAdjust  \n*Desc:* FCirc Vertex Adjust  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* dMinRadius (Double)  \n *Arg3:* bFullCylinder (Boolean)  \n *Arg4:* bCylinderMorethan90 (Boolean)  \n *Arg5:* bSkipFaceHaveLocalSetting (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.ExtractSurfaces": {
        prefix: "ExtractSurfaces",
        text: "*Name:* Geometry.ExtractSurfaces  \n*Desc:* Extract Reference Surfaces  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dAngle (Double)  \n *Arg3:* strName (String)  \n *Arg4:* bMergePart (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.RemoveRibBoss": {
        prefix: "RemoveRibBoss",
        text: "*Name:* Geometry.RemoveRibBoss  \n*Desc:*   \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dGradiation (Double)  \n *Arg3:* iContinuity (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.AdvancedShellAssembly": {
        prefix: "AdvancedShellAssembly",
        text: "*Name:* Geometry.AdvancedShellAssembly  \n*Desc:* Test shell assembly  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* iMeshType (Integer)  \n *Arg4:* bSelfIntersection (Boolean)  \n *Arg5:* iMethod (Integer)  \n *Arg6:* dGapTol (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Geometry.ExtractRefSurface": {
        prefix: "ExtractRefSurface",
        text: "*Name:* Geometry.ExtractRefSurface  \n*Desc:* Unknown Description  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dAngle (Double)  \n *Arg3:* strName (String)  \n *Arg4:* bMergePart (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Groups.RightClick.PropertyGroup": {
        prefix: "PropertyGroup",
        text: "*Name:* Groups.RightClick.PropertyGroup  \n*Desc:* create group of properties  \n *Arg1:* strTmp (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Groups.RightClick.Rename": {
        prefix: "Rename",
        text: "*Name:* Groups.RightClick.Rename  \n*Desc:* Unknown Description  \n *Arg1:* strNewName (String)  \n *Arg2:* crItem (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Groups.RightClick.DeleteGroup": {
        prefix: "DeleteGroup",
        text: "*Name:* Groups.RightClick.DeleteGroup  \n*Desc:* Delete Group  \n *Arg1:* crlDelGroup (Cursor List)  \n *Arg2:* bRemoveAll (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Groups.RightClick.CopyGroup": {
        prefix: "CopyGroup",
        text: "*Name:* Groups.RightClick.CopyGroup  \n*Desc:* Copy Group  \n *Arg1:* crlSrc (Cursor List)  \n *Arg2:* strlNames (String List)  \n *Arg3:* crDest (Cursor)  \n *Arg4:* bKeep (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Groups.RightClick.AddSupGroup": {
        prefix: "AddSupGroup",
        text: "*Name:* Groups.RightClick.AddSupGroup  \n*Desc:* Add supper group  \n *Arg1:* crSupGroupSelected (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Groups.RightClick.CreateMatGroup": {
        prefix: "CreateMatGroup",
        text: "*Name:* Groups.RightClick.CreateMatGroup  \n*Desc:* Unknown Description  \n *Arg1:* strTmp (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Sweep.Circular": {
        prefix: "Circular",
        text: "*Name:* HexModeling.Sweep.Circular  \n*Desc:* Unknown Description  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dAngle (Double)  \n *Arg3:* dTol (Double)  \n *Arg4:* iLayer (Integer)  \n *Arg5:* vecAxisPt (Vector)  \n *Arg6:* vecAxisVect (Vector)  \n *Arg7:* bInterfaceElem (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Sweep.FaceToFace": {
        prefix: "FaceToFace",
        text: "*Name:* HexModeling.Sweep.FaceToFace  \n*Desc:* Unknown Description  \n *Arg1:* crSrcFace (Cursor)  \n *Arg2:* crDstFace (Cursor)  \n *Arg3:* bDeleteOriginalParts (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Sweep.Layer": {
        prefix: "Layer",
        text: "*Name:* HexModeling.Sweep.Layer  \n*Desc:* Unknown Description  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dFrontWidth (Double)  \n *Arg3:* dBackWidth (Double)  \n *Arg4:* iFrontLayers (Integer)  \n *Arg5:* iBackLayers (Integer)  \n *Arg6:* iBaseFaceType (Integer)  \n *Arg7:* iSeparate (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Sweep.Linear": {
        prefix: "Linear",
        text: "*Name:* HexModeling.Sweep.Linear  \n*Desc:* Unknown Description  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dLength (Double)  \n *Arg3:* iLayer (Integer)  \n *Arg4:* dlSweepDirection (Double List)  \n *Arg5:* bInterfaceElemFlag (Boolean)  \n *Arg6:* iLinearMethod (Integer)  \n *Arg7:* bDeleteOriginalParts (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Sweep.Curve": {
        prefix: "Curve",
        text: "*Name:* HexModeling.Sweep.Curve  \n*Desc:* Unknown Description  \n *Arg1:* crFace (Cursor)  \n *Arg2:* crlEdge (Cursor List)  \n *Arg3:* crlRefEdge (Cursor List)  \n *Arg4:* dMeshSize (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Sweep.FromMidPlane": {
        prefix: "FromMidPlane",
        text: "*Name:* HexModeling.Sweep.FromMidPlane  \n*Desc:* Unknown Description  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* bRef (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.SolidElemInterface": {
        prefix: "SolidElemInterface",
        text: "*Name:* HexModeling.SolidElemInterface  \n*Desc:* make solid elem interface  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* bFlip (Boolean)  \n *Arg3:* crlElms (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.BallHexa": {
        prefix: "BallHexa",
        text: "*Name:* HexModeling.BallHexa  \n*Desc:* hexa modeling ball hexa  \n *Arg1:* crPart (Cursor)  \n *Arg2:* vecCenter (Vector)  \n *Arg3:* dRadius (Double)  \n *Arg4:* dMeshSize (Double)  \n *Arg5:* iType (Integer)  \n *Arg6:* iLayer (Integer)  \n *Arg7:* bMakeCenterNode (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.BoxMesh": {
        prefix: "BoxMesh",
        text: "*Name:* HexModeling.BoxMesh  \n*Desc:* Box hex mesh creator for parts  \n *Arg1:* ilPartIds (Integer List)  \n *Arg2:* dMeshSize (Double)  \n *Arg3:* strMaterialName (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.AutoSweep": {
        prefix: "AutoSweep",
        text: "*Name:* HexModeling.AutoSweep  \n*Desc:* Hex Modeling Auto Sweep  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* dMeshSize (Double)  \n *Arg3:* bLayers (Boolean)  \n *Arg4:* iLayers (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Circular": {
        prefix: "Circular",
        text: "*Name:* HexModeling.Circular  \n*Desc:* create Hexa mesh by revolving a surface  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dAngle (Double)  \n *Arg3:* dTol (Double)  \n *Arg4:* iLayer (Integer)  \n *Arg5:* vecAxisPt (Vector)  \n *Arg6:* vecAxisVect (Vector)  \n *Arg7:* bInterfaceElem (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.FaceToFace": {
        prefix: "FaceToFace",
        text: "*Name:* HexModeling.FaceToFace  \n*Desc:*   \n *Arg1:* crSrcFace (Cursor)  \n *Arg2:* crDstFace (Cursor)  \n *Arg3:* bDeleteOriginalParts (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Layer": {
        prefix: "Layer",
        text: "*Name:* HexModeling.Layer  \n*Desc:* sweep by layer  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dFrontWidth (Double)  \n *Arg3:* dBackWidth (Double)  \n *Arg4:* iFrontLayers (Integer)  \n *Arg5:* iBackLayers (Integer)  \n *Arg6:* iBaseFaceType (Integer)  \n *Arg7:* iSeparate (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Linear": {
        prefix: "Linear",
        text: "*Name:* HexModeling.Linear  \n*Desc:* Linear hex mesh creation  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* dLength (Double)  \n *Arg3:* iLayer (Integer)  \n *Arg4:* vecSweepDirection (Vector)  \n *Arg5:* bInterfaceElemFlag (Boolean)  \n *Arg6:* iLinearMethod (Integer)  \n *Arg7:* bDeleteOriginalParts (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.FromMidPlane": {
        prefix: "FromMidPlane",
        text: "*Name:* HexModeling.FromMidPlane  \n*Desc:* HexModeling From MidPlane  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* bRef (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "HexModeling.Curve": {
        prefix: "Curve",
        text: "*Name:* HexModeling.Curve  \n*Desc:* make hex by sweeping curve  \n *Arg1:* crFace (Cursor)  \n *Arg2:* crlEdge (Cursor List)  \n *Arg3:* crlRefEdge (Cursor List)  \n *Arg4:* dMeshSize (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportCAD.Elysium": {
        prefix: "Elysium",
        text: "*Name:* Home.ImportCAD.Elysium  \n*Desc:* import elysium  \n *Arg1:* strlPath (String List)  \n *Arg2:* dChordHeightTolerance (Double)  \n *Arg3:* dAngleToleranceDegree (Double)  \n *Arg4:* dPointCoincidentTolerance (Double)  \n *Arg5:* iConvertIsolatedCurve (Integer)  \n *Arg6:* iDekCleanselfintersectingloop (Integer)  \n *Arg7:* iDekVolumetopart (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportCAD.Spatial": {
        prefix: "Spatial",
        text: "*Name:* Home.ImportCAD.Spatial  \n*Desc:* import CAD by Spatial  \n *Arg1:* strlPath (String List)  \n *Arg2:* dSurfacePlaneTolerance (Double)  \n *Arg3:* dSufacePlaneAngle (Double)  \n *Arg4:* dMaxFacetWidth (Double)  \n *Arg5:* bNXMultipart (Boolean)  \n *Arg6:* bHealing (Boolean)  \n *Arg7:* bIsNXDirect (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportCAD.Parasolid": {
        prefix: "Parasolid",
        text: "*Name:* Home.ImportCAD.Parasolid  \n*Desc:* Import Parasolid  \n *Arg1:* strlFiles (String List)  \n *Arg2:* dChordHeightTolerance (Double)  \n *Arg3:* dAngleToleranceDegree (Double)  \n *Arg4:* iConvertIsolatedCurve (Integer)  \n *Arg5:* dSurfacePlaneTolerance (Double)  \n *Arg6:* dSufacePlaneAngle (Double)  \n *Arg7:* dMaxFacetWidth (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportCAD.STL": {
        prefix: "STL",
        text: "*Name:* Home.ImportCAD.STL  \n*Desc:* Import STL  \n *Arg1:* strlFiles (String List)  \n *Arg2:* dChordHeightTolerance (Double)  \n *Arg3:* dAngleToleranceDegree (Double)  \n *Arg4:* iConvertIsolatedCurve (Integer)  \n *Arg5:* dSurfacePlaneTolerance (Double)  \n *Arg6:* dSufacePlaneAngle (Double)  \n *Arg7:* dMaxFacetWidth (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportCAD.VRML": {
        prefix: "VRML",
        text: "*Name:* Home.ImportCAD.VRML  \n*Desc:* Import VRML  \n *Arg1:* strlFiles (String List)  \n *Arg2:* dChordHeightTolerance (Double)  \n *Arg3:* dAngleToleranceDegree (Double)  \n *Arg4:* iConvertIsolatedCurve (Integer)  \n *Arg5:* dSurfacePlaneTolerance (Double)  \n *Arg6:* dSufacePlaneAngle (Double)  \n *Arg7:* dMaxFacetWidth (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportCAD.ProECreoDirect": {
        prefix: "ProECreoDirect",
        text: "*Name:* Home.ImportCAD.ProECreoDirect  \n*Desc:* import Creo by Direct  \n *Arg1:* strlPath (String List)  \n *Arg2:* dChordHeightTolerance (Double)  \n *Arg3:* dAngleToleranceDegree (Double)  \n *Arg4:* dStepMaxSize (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportCAD.TechnoStarGeometry": {
        prefix: "TechnoStarGeometry",
        text: "*Name:* Home.ImportCAD.TechnoStarGeometry  \n*Desc:* Import Geometry bdf file  \n *Arg1:* strlPath (String List)  \n *Arg2:* bUseUnit (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportMesh.ADVCADX": {
        prefix: "ADVCADX",
        text: "*Name:* Home.ImportMesh.ADVCADX  \n*Desc:* import adx files  \n *Arg1:* strPath (String)  \n *Arg2:* dFaceAngle (Double)  \n *Arg3:* dEdgeAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportMesh.AnsysDat": {
        prefix: "AnsysDat",
        text: "*Name:* Home.ImportMesh.AnsysDat  \n*Desc:* Import Ansys file  \n *Arg1:* strlPath (String List)  \n *Arg2:* dFaceAngle (Double)  \n *Arg3:* dEdgeAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportMesh.NastranBdf": {
        prefix: "NastranBdf",
        text: "*Name:* Home.ImportMesh.NastranBdf  \n*Desc:* import Nastran bdf file  \n *Arg1:* strlFilePaths (String List)  \n *Arg2:* iImportType (Integer)  \n *Arg3:* dFaceAngle (Double)  \n *Arg4:* dEdgeAngle (Double)  \n *Arg5:* bReadNameComment (Boolean)  \n *Arg6:* iCreateDup1DElemAnswer (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportMesh.AbaqusINP": {
        prefix: "AbaqusINP",
        text: "*Name:* Home.ImportMesh.AbaqusINP  \n*Desc:* import Abaqus INP file  \n *Arg1:* strlFilePaths (String List)  \n *Arg2:* dFaceAngle (Double)  \n *Arg3:* dEdgeAngle (Double)  \n *Arg4:* iImportType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportMesh.LSDYNA": {
        prefix: "LSDYNA",
        text: "*Name:* Home.ImportMesh.LSDYNA  \n*Desc:* Import Ls-Dyna file  \n *Arg1:* strlPath (String List)  \n *Arg2:* dFaceAngle (Double)  \n *Arg3:* dEdgeAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportMesh.Universal": {
        prefix: "Universal",
        text: "*Name:* Home.ImportMesh.Universal  \n*Desc:* Import Universal  \n *Arg1:* strPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ImportMesh.TSVPre": {
        prefix: "TSVPre",
        text: "*Name:* Home.ImportMesh.TSVPre  \n*Desc:* Convert a old TSV-Pre/Designer file into one or more jtdb files.  \n *Arg1:* strImportPath (String)  \n *Arg2:* strExportPath (String)  \n *Arg3:* ilModelIndex (Integer List)  \n *Arg4:* iMerge (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ExportSTL": {
        prefix: "ExportSTL",
        text: "*Name:* Home.ExportSTL  \n*Desc:* export stl  \n *Arg1:* strFile (String)  \n *Arg2:* crlPart (Cursor List)  \n *Arg3:* dScale (Double)  \n *Arg4:* bFilterIndex (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ExportGeometryBDF": {
        prefix: "ExportGeometryBDF",
        text: "*Name:* Home.ExportGeometryBDF  \n*Desc:* Unknown Description  \n *Arg1:* strFileName (String)  \n *Arg2:* crlPart (Cursor List)  \n *Arg3:* bBigID (Boolean)  \n *Arg4:* bUseUnit (Boolean)  \n *Arg5:* bVert (Boolean)  \n *Arg6:* bEdge (Boolean)  \n *Arg7:* bFace (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.ToImage": {
        prefix: "ToImage",
        text: "*Name:* Home.ToImage  \n*Desc:* Unknown Description  \n *Arg1:* strImgPath (String)  \n *Arg2:* bWhiteBG (Boolean)  \n *Arg3:* bTransparentBG (Boolean)  \n *Arg4:* bFixedSize (Boolean)  \n *Arg5:* iExportWidth (Integer)  \n *Arg6:* iExportHeight (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.Find": {
        prefix: "Find",
        text: "*Name:* Home.Find  \n*Desc:* Unknown Description  \n *Arg1:* strSearch (String)  \n *Arg2:* strSeletedType (String)  \n *Arg3:* bFindMatch (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.RectangularCapture": {
        prefix: "RectangularCapture",
        text: "*Name:* Home.RectangularCapture  \n*Desc:* Unknown Description  \n *Arg1:* iLeft (Integer)  \n *Arg2:* iTop (Integer)  \n *Arg3:* iRight (Integer)  \n *Arg4:* iBottom (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.CopyToClipboard": {
        prefix: "CopyToClipboard",
        text: "*Name:* Home.CopyToClipboard  \n*Desc:* Unknown Description  \n *Arg1:* bWhiteBG (Boolean)  \n *Arg2:* bTransparentBG (Boolean)  \n *Arg3:* bFixedSize (Boolean)  \n *Arg4:* iWidth (Integer)  \n *Arg5:* iHeight (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.FullScreen": {
        prefix: "FullScreen",
        text: "*Name:* Home.FullScreen  \n*Desc:* Unknown Description  \n *Arg1:*  ()  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Home.Synchronize": {
        prefix: "Synchronize",
        text: "*Name:* Home.Synchronize  \n*Desc:* Unknown Description  \n *Arg1:*  ()  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MainWindow.RightClick.MergeFaces": {
        prefix: "MergeFaces",
        text: "*Name:* MainWindow.RightClick.MergeFaces  \n*Desc:* Merge Faces  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* bIsMergeEdge (Boolean)  \n *Arg3:* bRemoveNonBoundEdge (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MainWindow.RightClick.SelectAllParts": {
        prefix: "SelectAllParts",
        text: "*Name:* MainWindow.RightClick.SelectAllParts  \n*Desc:* Select all of the parts in the model  \n *Arg1:*  ()  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MainWindow.RightClick.AssociatedPick": {
        prefix: "AssociatedPick",
        text: "*Name:* MainWindow.RightClick.AssociatedPick  \n*Desc:* pick associated entity  \n *Arg1:* crlInput (Cursor List)  \n *Arg2:* strTarget (String)  \n *Arg3:* strConnect (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MainWindow.RightClick.FlipElement": {
        prefix: "FlipElement",
        text: "*Name:* MainWindow.RightClick.FlipElement  \n*Desc:* flip element  \n *Arg1:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Element.SolidElement": {
        prefix: "SolidElement",
        text: "*Name:* MeshCleanup.Element.SolidElement  \n*Desc:* Change Topology for Solid Element  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crPart (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Element.SurfaceElement": {
        prefix: "SurfaceElement",
        text: "*Name:* MeshCleanup.Element.SurfaceElement  \n*Desc:* Change Topology Element  \n *Arg1:* ilElement (Integer List)  \n *Arg2:* ilFace (Integer List)  \n *Arg3:* ilPart (Integer List)  \n *Arg4:* iCreateNewPart (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Face": {
        prefix: "Face",
        text: "*Name:* MeshCleanup.Face  \n*Desc:* change topology face  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlPart (Cursor List)  \n *Arg3:* bCreateNewPart (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.CorrectModel": {
        prefix: "CorrectModel",
        text: "*Name:* MeshCleanup.CorrectModel  \n*Desc:* correct model  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iEnableBreakEdge (Integer)  \n *Arg3:* dEdgeAngle (Double)  \n *Arg4:* iEnableMergeEdge (Integer)  \n *Arg5:* dMergeEdgeAngle (Double)  \n *Arg6:* iEnableMergePlanarFace (Integer)  \n *Arg7:* iEnableRemoveExtraVertex (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.CloseHoles": {
        prefix: "CloseHoles",
        text: "*Name:* MeshCleanup.CloseHoles  \n*Desc:* close holes  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* dAreaMin (Double)  \n *Arg3:* dAreaMax (Double)  \n *Arg4:* bMergeFace (Boolean)  \n *Arg5:* bMergeEdge (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.CloseGap": {
        prefix: "CloseGap",
        text: "*Name:* MeshCleanup.CloseGap  \n*Desc:* MeshCleanup Cleanup CloseGap  \n *Arg1:* crlPartCur (Cursor List)  \n *Arg2:* dDistanceTol (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.AutoCheck": {
        prefix: "AutoCheck",
        text: "*Name:* MeshCleanup.AutoCheck  \n*Desc:* check meshing quality  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iElemType (Integer)  \n *Arg3:* blCheckCondition (Boolean List)  \n *Arg4:* blElemQuality (Boolean List)  \n *Arg5:* dlLimitValue (Double List)  \n *Arg6:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.ManualCheck": {
        prefix: "ManualCheck",
        text: "*Name:* MeshCleanup.ManualCheck  \n*Desc:* MeshCleanup ManualCheck  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iElemType (Integer)  \n *Arg3:* iVeQuality (Integer)  \n *Arg4:* iCheckCondition (Integer)  \n *Arg5:* dLimitValue (Double)  \n *Arg6:* dCFLValue (Double)  \n *Arg7:* iNonManifold (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.ChangeTopology.Element.SurfaceElement": {
        prefix: "SurfaceElement",
        text: "*Name:* MeshCleanup.ChangeTopology.Element.SurfaceElement  \n*Desc:* Unknown Description  \n *Arg1:* ilElement (Integer List)  \n *Arg2:* ilFace (Integer List)  \n *Arg3:* ilPart (Integer List)  \n *Arg4:* iCreateNewPart (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Cleanup.CloseGap": {
        prefix: "CloseGap",
        text: "*Name:* MeshCleanup.Cleanup.CloseGap  \n*Desc:* Unknown Description  \n *Arg1:* crlPartCur (Cursor List)  \n *Arg2:* dDistanceTol (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.MergeElement.TwoQuadsToQuad": {
        prefix: "TwoQuadsToQuad",
        text: "*Name:* MeshCleanup.Manual2D.MergeElement.TwoQuadsToQuad  \n*Desc:* Merge two Quad elements into one Quad element  \n *Arg1:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.MergeElement.TwoTrisToQuad": {
        prefix: "TwoTrisToQuad",
        text: "*Name:* MeshCleanup.Manual2D.MergeElement.TwoTrisToQuad  \n*Desc:*   \n *Arg1:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Split element 2D  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crDatumNode0 (Cursor)  \n *Arg3:* crDatumNode1 (Cursor)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iAutoExecute (Integer)  \n *Arg6:* iAutoTransition (Integer)  \n *Arg7:* iCADProject (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crDatumNode0 (Cursor)  \n *Arg3:* crDatumNode1 (Cursor)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iAutoExecute (Integer)  \n *Arg6:* iAutoTransition (Integer)  \n *Arg7:* iCADProject (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crDatumNode0 (Cursor)  \n *Arg3:* crDatumNode1 (Cursor)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iAutoExecute (Integer)  \n *Arg6:* iAutoTransition (Integer)  \n *Arg7:* iCADProject (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crDatumNode0 (Cursor)  \n *Arg3:* crDatumNode1 (Cursor)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iAutoExecute (Integer)  \n *Arg6:* iAutoTransition (Integer)  \n *Arg7:* iCADProject (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crDatumNode0 (Cursor)  \n *Arg3:* crDatumNode1 (Cursor)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iAutoExecute (Integer)  \n *Arg6:* iAutoTransition (Integer)  \n *Arg7:* iCADProject (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crDatumNode0 (Cursor)  \n *Arg3:* crDatumNode1 (Cursor)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iAutoExecute (Integer)  \n *Arg6:* iAutoTransition (Integer)  \n *Arg7:* iCADProject (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crDatumNode0 (Cursor)  \n *Arg3:* crDatumNode1 (Cursor)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iAutoExecute (Integer)  \n *Arg6:* iAutoTransition (Integer)  \n *Arg7:* iCADProject (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.SplitElement.QuadToQuadTri": {
        prefix: "QuadToQuadTri",
        text: "*Name:* MeshCleanup.Manual2D.SplitElement.QuadToQuadTri  \n*Desc:* Unknown Description  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crDatumNode0 (Cursor)  \n *Arg3:* crDatumNode1 (Cursor)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iAutoExecute (Integer)  \n *Arg6:* iAutoTransition (Integer)  \n *Arg7:* iCADProject (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Unknown Description  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* crDatumNode0 (Cursor)  \n *Arg3:* crDatumNode1 (Cursor)  \n *Arg4:* iMethod (Integer)  \n *Arg5:* iAutoExecute (Integer)  \n *Arg6:* iAutoTransition (Integer)  \n *Arg7:* iCADProject (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.Equivalence": {
        prefix: "Equivalence",
        text: "*Name:* MeshCleanup.Manual2D.Equivalence  \n*Desc:* Equivalence Nodes  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* iTypeEquiva (Integer)  \n *Arg3:* dTolerance (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.DeleteElement": {
        prefix: "DeleteElement",
        text: "*Name:* MeshCleanup.Manual2D.DeleteElement  \n*Desc:* Delete Element  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* bKeepShareElem (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.Split": {
        prefix: "Split",
        text: "*Name:* MeshCleanup.Manual2D.Split  \n*Desc:* manual cleanup by split  \n *Arg1:* crplElemEdge (Cursor Pair List)  \n *Arg2:* dRatio (Double)  \n *Arg3:* crNodeRef (Cursor)  \n *Arg4:* crProjectPart (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.Swap": {
        prefix: "Swap",
        text: "*Name:* MeshCleanup.Manual2D.Swap  \n*Desc:* Swap Element Edge  \n *Arg1:* crplElemEdge (Cursor Pair List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.Collapse": {
        prefix: "Collapse",
        text: "*Name:* MeshCleanup.Manual2D.Collapse  \n*Desc:* Collapse for Mesh Cleanup  \n *Arg1:* crNodeRef (Cursor)  \n *Arg2:* crNodeEq (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.CreateElement": {
        prefix: "CreateElement",
        text: "*Name:* MeshCleanup.Manual2D.CreateElement  \n*Desc:* Create element  \n *Arg1:* iElemType (Integer)  \n *Arg2:* crParentEntity (Cursor)  \n *Arg3:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual2D.RemeshElement": {
        prefix: "RemeshElement",
        text: "*Name:* MeshCleanup.Manual2D.RemeshElement  \n*Desc:* local surface remesh  \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* surfaceMesh (SURFACE_MESH)  \n *Arg3:* bUseSetting (Boolean)  \n *Arg4:* bGrading (Boolean)  \n *Arg5:* bFMesher (Boolean)  \n *Arg6:* iOverrideType (Integer)  \n *Arg7:* bKeepConnection (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.Collapse.CenterFaceCollapse": {
        prefix: "CenterFaceCollapse",
        text: "*Name:* MeshCleanup.Manual3D.Collapse.CenterFaceCollapse  \n*Desc:*   \n *Arg1:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.Collapse.HalfEdgeCollapse": {
        prefix: "HalfEdgeCollapse",
        text: "*Name:* MeshCleanup.Manual3D.Collapse.HalfEdgeCollapse  \n*Desc:* mash cleanup by manual for half edge collapse  \n *Arg1:* crplElemEdge (Cursor Pair List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.Collapse.EdgeCollapse": {
        prefix: "EdgeCollapse",
        text: "*Name:* MeshCleanup.Manual3D.Collapse.EdgeCollapse  \n*Desc:* collapse  \n *Arg1:* crplElemEdge (Cursor Pair List)  \n *Arg2:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.DeleteNode": {
        prefix: "DeleteNode",
        text: "*Name:* MeshCleanup.Manual3D.DeleteNode  \n*Desc:* remove node for solid element.  \n *Arg1:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.Swap": {
        prefix: "Swap",
        text: "*Name:* MeshCleanup.Manual3D.Swap  \n*Desc:* cleanup element edge by swap  \n *Arg1:* crplElemEdge (Cursor Pair List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.Equivalence": {
        prefix: "Equivalence",
        text: "*Name:* MeshCleanup.Manual3D.Equivalence  \n*Desc:*   \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* iMergeTowards (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.Split": {
        prefix: "Split",
        text: "*Name:* MeshCleanup.Manual3D.Split  \n*Desc:* Merge two Quad elements into one Quad element  \n *Arg1:* crplElemEdge (Cursor Pair List)  \n *Arg2:* crlNode (Cursor List)  \n *Arg3:* dRatioDistance (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.CreateHex": {
        prefix: "CreateHex",
        text: "*Name:* MeshCleanup.Manual3D.CreateHex  \n*Desc:* create hex8 elements  \n *Arg1:* iParentEntityId (Integer)  \n *Arg2:* crlElem (Cursor List)  \n *Arg3:* iSeprateN (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.CreatePenta": {
        prefix: "CreatePenta",
        text: "*Name:* MeshCleanup.Manual3D.CreatePenta  \n*Desc:* Create penta5 element  \n *Arg1:* iParentEntityId (Integer)  \n *Arg2:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.Manual3D.CreateTetra": {
        prefix: "CreateTetra",
        text: "*Name:* MeshCleanup.Manual3D.CreateTetra  \n*Desc:* create element Tet  \n *Arg1:* iParentEntityId (Integer)  \n *Arg2:* crlNode (Cursor List)  \n *Arg3:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshCleanup.ManualCheck.Tri": {
        prefix: "Tri",
        text: "*Name:* MeshCleanup.ManualCheck.Tri  \n*Desc:* Unknown Description  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* nElemType (N_ELEM_TYPE)  \n *Arg3:* veQuality (VE_QUALITY)  \n *Arg4:* nCheckCondition (N_CHECK_CONDITION)  \n *Arg5:* dLimitValue (Double)  \n *Arg6:* CFLValue (CFLVALUE)  \n *Arg7:* nNonManifold (N_NON_MANIFOLD)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateElement.Hex": {
        prefix: "Hex",
        text: "*Name:* MeshEdit.CreateElement.Hex  \n*Desc:* create hex8 elements  \n *Arg1:* iParentEntityId (Integer)  \n *Arg2:* crlElem (Cursor List)  \n *Arg3:* iSeprateN (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateElement.Penta": {
        prefix: "Penta",
        text: "*Name:* MeshEdit.CreateElement.Penta  \n*Desc:* Create penta element  \n *Arg1:* iParentEntityId (Integer)  \n *Arg2:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateElement.Tet": {
        prefix: "Tet",
        text: "*Name:* MeshEdit.CreateElement.Tet  \n*Desc:* create element Tet  \n *Arg1:* iParentEntityId (Integer)  \n *Arg2:* crlNode (Cursor List)  \n *Arg3:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Create element  \n *Arg1:* iElemType (Integer)  \n *Arg2:* crParentEntity (Cursor)  \n *Arg3:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Create element  \n *Arg1:* iElemType (Integer)  \n *Arg2:* crParentEntity (Cursor)  \n *Arg3:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.CircleCenter": {
        prefix: "CircleCenter",
        text: "*Name:* MeshEdit.CreateNode.CircleCenter  \n*Desc:* create node at center of circle  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* iNodeID (Integer)  \n *Arg3:* bImprint (Boolean)  \n *Arg4:* crFace (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.Absolute": {
        prefix: "Absolute",
        text: "*Name:* MeshEdit.CreateNode.Absolute  \n*Desc:* create node by input direct value  \n *Arg1:* veclNodeCoord (Vector List)  \n *Arg2:* ilNewNodeID (Integer List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.Import": {
        prefix: "Import",
        text: "*Name:* MeshEdit.CreateNode.Import  \n*Desc:* create node by importing CSV file  \n *Arg1:* strCsvFilePath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.Point": {
        prefix: "Point",
        text: "*Name:* MeshEdit.CreateNode.Point  \n*Desc:* create node point  \n *Arg1:* iNodeID (Integer)  \n *Arg2:* posPoint (Position)  \n *Arg3:* bImprint (Boolean)  \n *Arg4:* crShape (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* create node point  \n *Arg1:* iNodeID (Integer)  \n *Arg2:* dX (Double)  \n *Arg3:* dY (Double)  \n *Arg4:* dZ (Double)  \n *Arg5:* iNumberofNodes (Integer)  \n *Arg6:* bImprint (Boolean)  \n *Arg7:* crlNode (Cursor List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* create node point  \n *Arg1:* iNodeID (Integer)  \n *Arg2:* dX (Double)  \n *Arg3:* dY (Double)  \n *Arg4:* dZ (Double)  \n *Arg5:* bImprint (Boolean)  \n *Arg6:* crlNode (Cursor List)  \n *Arg7:* crlFace (Cursor List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.ProjectToPlane": {
        prefix: "ProjectToPlane",
        text: "*Name:* MeshEdit.CreateNode.ProjectToPlane  \n*Desc:* create node point  \n *Arg1:* dX (Double)  \n *Arg2:* dY (Double)  \n *Arg3:* dZ (Double)  \n *Arg4:* crlNode (Cursor List)  \n *Arg5:* crlFace (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.CenterOfCylinder": {
        prefix: "CenterOfCylinder",
        text: "*Name:* MeshEdit.CreateNode.CenterOfCylinder  \n*Desc:* Create node of center cylinder  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* iNodeID (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.CenterOfSphere": {
        prefix: "CenterOfSphere",
        text: "*Name:* MeshEdit.CreateNode.CenterOfSphere  \n*Desc:* Create node of center sphere  \n *Arg1:* crlNodeOrFace (Cursor List)  \n *Arg2:* iNodeID (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.Offset": {
        prefix: "Offset",
        text: "*Name:* MeshEdit.CreateNode.Offset  \n*Desc:* MeshEdit CreateNode CreateNodeNodeOffset  \n *Arg1:* vecOffset (Vector)  \n *Arg2:* iRep (Integer)  \n *Arg3:* crlNode (Cursor List)  \n *Arg4:* crCoord (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.CenterOfGravity": {
        prefix: "CenterOfGravity",
        text: "*Name:* MeshEdit.CreateNode.CenterOfGravity  \n*Desc:* create node Center Of Gravity  \n *Arg1:* iCreationType (Integer)  \n *Arg2:* iNodeID (Integer)  \n *Arg3:* dX (Double)  \n *Arg4:* dY (Double)  \n *Arg5:* dZ (Double)  \n *Arg6:* crlPart (Cursor List)  \n *Arg7:* crlBarPart (Cursor List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.ProjectToLine": {
        prefix: "ProjectToLine",
        text: "*Name:* MeshEdit.CreateNode.ProjectToLine  \n*Desc:* create node by projection to line  \n *Arg1:* crlTa (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.CreateNode.IntersectionNode": {
        prefix: "IntersectionNode",
        text: "*Name:* MeshEdit.CreateNode.IntersectionNode  \n*Desc:* create node by intersection node  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlPart (Cursor List)  \n *Arg3:* crlEdge (Cursor List)  \n *Arg4:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.Point": {
        prefix: "Point",
        text: "*Name:* MeshEdit.MoveNode.Point  \n*Desc:* Move node(s) to an Face(Edge) Point position  \n *Arg1:* dX (Double)  \n *Arg2:* dY (Double)  \n *Arg3:* dZ (Double)  \n *Arg4:* ilNodeList (Integer List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.ProjectToLine": {
        prefix: "ProjectToLine",
        text: "*Name:* MeshEdit.MoveNode.ProjectToLine  \n*Desc:* move node by project to line  \n *Arg1:* crlRefNodes (Cursor List)  \n *Arg2:* crlObjNodes (Cursor List)  \n *Arg3:* iType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.ProjectToPlaneElem": {
        prefix: "ProjectToPlaneElem",
        text: "*Name:* MeshEdit.MoveNode.ProjectToPlaneElem  \n*Desc:* Move Node by Project to Plane(Elem)  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.Equalize": {
        prefix: "Equalize",
        text: "*Name:* MeshEdit.MoveNode.Equalize  \n*Desc:* Move node by equalize  \n *Arg1:* crlEdge (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.NormalOffset": {
        prefix: "NormalOffset",
        text: "*Name:* MeshEdit.MoveNode.NormalOffset  \n*Desc:* Move node(s) in Normal Direction of plane  \n *Arg1:* dMagnitude (Double)  \n *Arg2:* ilNodeList (Integer List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.CoincidentNodes": {
        prefix: "CoincidentNodes",
        text: "*Name:* MeshEdit.MoveNode.CoincidentNodes  \n*Desc:* Coincident Nodes  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* dTol (Double)  \n *Arg3:* bDesOrder (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.AlongCylinder": {
        prefix: "AlongCylinder",
        text: "*Name:* MeshEdit.MoveNode.AlongCylinder  \n*Desc:* Move node along cylinder surface  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlNode (Cursor List)  \n *Arg3:* dIrX (Double)  \n *Arg4:* dIrY (Double)  \n *Arg5:* dIrZ (Double)  \n *Arg6:* dCircleX (Double)  \n *Arg7:* dCircleY (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Move Nodes from Node to 3 nodes created Plane  \n *Arg1:* ilNodeList (Integer List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.MoveNodeOffset": {
        prefix: "MoveNodeOffset",
        text: "*Name:* MeshEdit.MoveNode.MoveNodeOffset  \n*Desc:* Unknown Description  \n *Arg1:* dDeltaX (Double)  \n *Arg2:* dDeltaY (Double)  \n *Arg3:* dDeltaZ (Double)  \n *Arg4:* crlNode (Cursor List)  \n *Arg5:* crCoord (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.RefineQuality": {
        prefix: "RefineQuality",
        text: "*Name:* MeshEdit.MoveNode.RefineQuality  \n*Desc:* MeshEdit RefineQuality  \n *Arg1:* iMetric (Integer)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* crlElem (Cursor List)  \n *Arg4:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.StraightenMidnodes": {
        prefix: "StraightenMidnodes",
        text: "*Name:* MeshEdit.MoveNode.StraightenMidnodes  \n*Desc:* move node by straighten_mid_nodes  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* crlEdge (Cursor List)  \n *Arg4:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.Offset": {
        prefix: "Offset",
        text: "*Name:* MeshEdit.MoveNode.Offset  \n*Desc:* MeshEdit MoveNode MoveNodeOffset  \n *Arg1:* dDeltaX (Double)  \n *Arg2:* dDeltaY (Double)  \n *Arg3:* dDeltaZ (Double)  \n *Arg4:* crCoord (Cursor)  \n *Arg5:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.Laplacian": {
        prefix: "Laplacian",
        text: "*Name:* MeshEdit.MoveNode.Laplacian  \n*Desc:*   \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* iType (Integer)  \n *Arg3:* bWithCADFollow (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.AlongEdge": {
        prefix: "AlongEdge",
        text: "*Name:* MeshEdit.MoveNode.AlongEdge  \n*Desc:*   \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* bMoveX (Boolean)  \n *Arg3:* bMoveY (Boolean)  \n *Arg4:* bMoveZ (Boolean)  \n *Arg5:* dPosX (Double)  \n *Arg6:* dPosY (Double)  \n *Arg7:* dPosZ (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.AlongDirection": {
        prefix: "AlongDirection",
        text: "*Name:* MeshEdit.MoveNode.AlongDirection  \n*Desc:*   \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* crElem (Cursor)  \n *Arg3:* crFace (Cursor)  \n *Arg4:* vecDirection (Vector)  \n *Arg5:* dMagnitude (Double)  \n *Arg6:* bDestination (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.CADFollows": {
        prefix: "CADFollows",
        text: "*Name:* MeshEdit.MoveNode.CADFollows  \n*Desc:*   \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* dMovedPosX (Double)  \n *Arg3:* dMovedPosY (Double)  \n *Arg4:* dMovedPosZ (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.Scale": {
        prefix: "Scale",
        text: "*Name:* MeshEdit.MoveNode.Scale  \n*Desc:* Move node scale  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* crlNodeOrigin (Cursor List)  \n *Arg3:* crCoord (Cursor)  \n *Arg4:* 10.0 (10.0)  \n *Arg5:* 10.0] (10.0])  \n *Arg6:* posDeltaXYZ (Position)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MoveNode.Absolute": {
        prefix: "Absolute",
        text: "*Name:* MeshEdit.MoveNode.Absolute  \n*Desc:* move node absolute  \n *Arg1:* dDeltaX (Double)  \n *Arg2:* dDeltaY (Double)  \n *Arg3:* dDeltaZ (Double)  \n *Arg4:* b1stCoord (B1ST_COORD)  \n *Arg5:* b2ndCoord (B2ND_COORD)  \n *Arg6:* b3rdCoord (B3RD_COORD)  \n *Arg7:* crlNode (Cursor List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.Face": {
        prefix: "Face",
        text: "*Name:* MeshEdit.Face  \n*Desc:* Make Mesh deformation  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlFaceFixed (Cursor List)  \n *Arg3:* iOffsetType (Integer)  \n *Arg4:* crCoord (Cursor)  \n *Arg5:* 0.0 (0.0)  \n *Arg6:* 0.0] (0.0])  \n *Arg7:* dlOffset (Double List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.ElementConvert": {
        prefix: "ElementConvert",
        text: "*Name:* MeshEdit.ElementConvert  \n*Desc:* Element Conversion  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.Deform": {
        prefix: "Deform",
        text: "*Name:* MeshEdit.Deform  \n*Desc:* geometry deform  \n *Arg1:* crlFaceSrcObverse (Cursor List)  \n *Arg2:* crlFaceDstReverse (Cursor List)  \n *Arg3:* crlFaceSrcReverse (Cursor List)  \n *Arg4:* crlFaceDstObverse (Cursor List)  \n *Arg5:* crlFaceFixed (Cursor List)  \n *Arg6:* dDistEffect (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MirrorCopy": {
        prefix: "MirrorCopy",
        text: "*Name:* MeshEdit.MirrorCopy  \n*Desc:* mirror copy of surface mesh  \n *Arg1:* crlFace (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.DeleteNode": {
        prefix: "DeleteNode",
        text: "*Name:* MeshEdit.DeleteNode  \n*Desc:* Delete floating nodes in db  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* bRemoveVertex (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.FaceImprint": {
        prefix: "FaceImprint",
        text: "*Name:* MeshEdit.FaceImprint  \n*Desc:* import Nastran bdf file  \n *Arg1:* crlFaces (Cursor List)  \n *Arg2:* bMeshCopy (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.AdjustOrientation": {
        prefix: "AdjustOrientation",
        text: "*Name:* MeshEdit.AdjustOrientation  \n*Desc:* Adjust Orientation  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* crlElem (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.OneNode": {
        prefix: "OneNode",
        text: "*Name:* MeshEdit.OneNode  \n*Desc:* morphing one node  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* crlFaceFixed (Cursor List)  \n *Arg3:* bOffsetvector (Boolean)  \n *Arg4:* crCoord (Cursor)  \n *Arg5:* 1 (1)  \n *Arg6:* 0] (0])  \n *Arg7:* dlOffset (Double List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.SeparateNodes": {
        prefix: "SeparateNodes",
        text: "*Name:* MeshEdit.SeparateNodes  \n*Desc:* Separate nodes  \n *Arg1:* crlShareNodes (Cursor List)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* iKeepNodeIDsOn (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.RefineQuality": {
        prefix: "RefineQuality",
        text: "*Name:* MeshEdit.RefineQuality  \n*Desc:* Unknown Description  \n *Arg1:* iMetric (Integer)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* crlElem (Cursor List)  \n *Arg4:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.Import": {
        prefix: "Import",
        text: "*Name:* MeshEdit.Import  \n*Desc:* Move nodes deform  \n *Arg1:* iSolverType (Integer)  \n *Arg2:* strFilePath (String)  \n *Arg3:* iStep (Integer)  \n *Arg4:* dScale (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.RemoveSolidMesh": {
        prefix: "RemoveSolidMesh",
        text: "*Name:* MeshEdit.RemoveSolidMesh  \n*Desc:* Remove Solid Mesh  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* bConvFirst (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MergeNodes": {
        prefix: "MergeNodes",
        text: "*Name:* MeshEdit.MergeNodes  \n*Desc:* Merge nodes  \n *Arg1:* dTolerance (Double)  \n *Arg2:* iKeepType (Integer)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* bGroup (Boolean)  \n *Arg5:* bEquivalence (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.MeshCopy": {
        prefix: "MeshCopy",
        text: "*Name:* MeshEdit.MeshCopy  \n*Desc:* Mesh Copy Pattern  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.RibThickness": {
        prefix: "RibThickness",
        text: "*Name:* MeshEdit.RibThickness  \n*Desc:* Mesh Edit Morphing Rib Thickness  \n *Arg1:* crlFaceMove (Cursor List)  \n *Arg2:* crlFaceFixed (Cursor List)  \n *Arg3:* dMove (Double)  \n *Arg4:* dDistStrong (Double)  \n *Arg5:* dDistWeak (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.ChangePattern": {
        prefix: "ChangePattern",
        text: "*Name:* MeshEdit.ChangePattern  \n*Desc:* Element ChangePattern  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* iPatternType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.SurfaceMesh": {
        prefix: "SurfaceMesh",
        text: "*Name:* MeshEdit.SurfaceMesh  \n*Desc:* Element Conversion  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.SolidMesh": {
        prefix: "SolidMesh",
        text: "*Name:* MeshEdit.SolidMesh  \n*Desc:* Element Conversion  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MeshEdit.DividePartByRegion": {
        prefix: "DividePartByRegion",
        text: "*Name:* MeshEdit.DividePartByRegion  \n*Desc:* Divide Part By Region  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlBoundaryParts (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.CADProjection.Part": {
        prefix: "Part",
        text: "*Name:* Meshing.CADProjection.Part  \n*Desc:* CadProject for Part  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crCadPart (Cursor)  \n *Arg3:* crMeshedPart (Cursor)  \n *Arg4:* bForceProject (Boolean)  \n *Arg5:* bProjectCornerNodes (Boolean)  \n *Arg6:* bProjectMidNodes (Boolean)  \n *Arg7:* bIDcheck (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.CADProjection.Face": {
        prefix: "Face",
        text: "*Name:* Meshing.CADProjection.Face  \n*Desc:* CadProject for Face  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crCadPart (Cursor)  \n *Arg3:* crlMeshedFace (Cursor List)  \n *Arg4:* bForceProject (Boolean)  \n *Arg5:* bProjectCornerNodes (Boolean)  \n *Arg6:* bProjectMidNodes (Boolean)  \n *Arg7:* bIDcheck (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.CADProjection.FaceToFace": {
        prefix: "FaceToFace",
        text: "*Name:* Meshing.CADProjection.FaceToFace  \n*Desc:* CadProject for Fact to Face  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlCadFace (Cursor List)  \n *Arg3:* crlMeshedFace (Cursor List)  \n *Arg4:* bForceProject (Boolean)  \n *Arg5:* bProjectCornerNodes (Boolean)  \n *Arg6:* bProjectMidNodes (Boolean)  \n *Arg7:* bIDcheck (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.CADProjection.NodeToFace": {
        prefix: "NodeToFace",
        text: "*Name:* Meshing.CADProjection.NodeToFace  \n*Desc:* CadProject for Node to Face  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crlCadFace (Cursor List)  \n *Arg3:* crlMeshedNode (Cursor List)  \n *Arg4:* iDirection (Integer)  \n *Arg5:* iImproveQuality (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.CADProjection.NodeToEdge": {
        prefix: "NodeToEdge",
        text: "*Name:* Meshing.CADProjection.NodeToEdge  \n*Desc:* CadProject for Node to Edge  \n *Arg1:* iMethod (Integer)  \n *Arg2:* crCadEdge (Cursor)  \n *Arg3:* crlMeshedNode (Cursor List)  \n *Arg4:* iDirection (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalMeshing.FilletMapping": {
        prefix: "FilletMapping",
        text: "*Name:* Meshing.LocalMeshing.FilletMapping  \n*Desc:*   \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* iIsoDiv (Integer)  \n *Arg3:* dIsoSize (Double)  \n *Arg4:* dIsoError (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalMeshing.SelectFillet": {
        prefix: "SelectFillet",
        text: "*Name:* Meshing.LocalMeshing.SelectFillet  \n*Desc:* Unknown Description  \n *Arg1:* crlItems (Cursor List)  \n *Arg2:* dSelectWidthMin (Double)  \n *Arg3:* dSelectWidthMax (Double)  \n *Arg4:* dSelectRMin (Double)  \n *Arg5:* dSelectRMax (Double)  \n *Arg6:* dAngleMin (Double)  \n *Arg7:* dAngleMax (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalSetting.SearchTargetFaces": {
        prefix: "SearchTargetFaces",
        text: "*Name:* Meshing.LocalSetting.SearchTargetFaces  \n*Desc:* Search Target Faces for Local mesh setting  \n *Arg1:* iPartType (Integer)  \n *Arg2:* 0 (0)  \n *Arg3:* 0] (0])  \n *Arg4:* dlOrigin (Double List)  \n *Arg5:* 0.1 (0.1)  \n *Arg6:* 0.1] (0.1])  \n *Arg7:* dlLength (Double List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.Templates.TemplateCopy": {
        prefix: "TemplateCopy",
        text: "*Name:* Meshing.Templates.TemplateCopy  \n*Desc:* Template Copy local setting  \n *Arg1:* crlReferent (Cursor List)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iCopySub (Integer)  \n *Arg5:* dTolerance (Double)  \n *Arg6:* strSource (String)  \n *Arg7:* strTarget (String)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.BarMeshing": {
        prefix: "BarMeshing",
        text: "*Name:* Meshing.BarMeshing  \n*Desc:* meshing 1D edge/bar  \n *Arg1:* crlCadEdge (Cursor List)  \n *Arg2:* crlBarEdge (Cursor List)  \n *Arg3:* crlBarPart (Cursor List)  \n *Arg4:* dDocMeshSize (Double)  \n *Arg5:* iDocNumofElem (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.GridMesh": {
        prefix: "GridMesh",
        text: "*Name:* Meshing.GridMesh  \n*Desc:* Grid meshing  \n *Arg1:* listGridMesh (GRID_MESH List)  \n *Arg2:* bLocalsetting (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.SolidMeshing": {
        prefix: "SolidMeshing",
        text: "*Name:* Meshing.SolidMeshing  \n*Desc:* Solid Meshing  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* bTet10 (Boolean)  \n *Arg3:* dGradingFactor (Double)  \n *Arg4:* bGravCenter (Boolean)  \n *Arg5:* dStretchLimit (Double)  \n *Arg6:* iSpeedVsQual (Integer)  \n *Arg7:* iSpeedVsMem (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.SurfaceMeshing": {
        prefix: "SurfaceMeshing",
        text: "*Name:* Meshing.SurfaceMeshing  \n*Desc:* Surface Meshing  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* surfaceMesh (SURFACE_MESH)  \n *Arg3:* bUseSetting (Boolean)  \n *Arg4:* bFMesher (Boolean)  \n *Arg5:* iThreadNum (Integer)  \n *Arg6:* bRefData (Boolean)  \n *Arg7:* bMeshColor (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.SetAttib": {
        prefix: "SetAttib",
        text: "*Name:* Meshing.SetAttib  \n*Desc:* set attribute  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* surfaceMesh (SURFACE_MESH)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalRemesh.Solid": {
        prefix: "Solid",
        text: "*Name:* Meshing.LocalRemesh.Solid  \n*Desc:*   \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* dlCenter (Double List)  \n *Arg3:* dRadius (Double)  \n *Arg4:* dGradFactor (Double)  \n *Arg5:* dStrechLimit (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalRemesh.Surfase": {
        prefix: "Surfase",
        text: "*Name:* Meshing.LocalRemesh.Surfase  \n*Desc:* local surface remesh  \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* surfaceMesh (SURFACE_MESH)  \n *Arg3:* bUseSetting (Boolean)  \n *Arg4:* bGrading (Boolean)  \n *Arg5:* bFMesher (Boolean)  \n *Arg6:* iOverrideType (Integer)  \n *Arg7:* bKeepConnection (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalSettings.Edge": {
        prefix: "Edge",
        text: "*Name:* Meshing.LocalSettings.Edge  \n*Desc:* LocalSettings.Edge  \n *Arg1:* strName (String)  \n *Arg2:* localMesh (LOCAL_MESH)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* ilHardPointId (Integer List)  \n *Arg5:* veclHardPointXYZ (Vector List)  \n *Arg6:* crlHardPointTarget (Cursor List)  \n *Arg7:* crEditTarget (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalSettings.Face": {
        prefix: "Face",
        text: "*Name:* Meshing.LocalSettings.Face  \n*Desc:* LocalSettings.Face  \n *Arg1:* strName (String)  \n *Arg2:* localMesh (LOCAL_MESH)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* ilHardPointId (Integer List)  \n *Arg5:* veclHardPointXYZ (Vector List)  \n *Arg6:* crlHardPointTarget (Cursor List)  \n *Arg7:* crEditTarget (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalSettings.FaceElement": {
        prefix: "FaceElement",
        text: "*Name:* Meshing.LocalSettings.FaceElement  \n*Desc:* LocalSettings.FaceElement  \n *Arg1:* strName (String)  \n *Arg2:* localMesh (LOCAL_MESH)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* ilHardPointId (Integer List)  \n *Arg5:* veclHardPointXYZ (Vector List)  \n *Arg6:* crlHardPointTarget (Cursor List)  \n *Arg7:* crEditTarget (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalSettings.Model": {
        prefix: "Model",
        text: "*Name:* Meshing.LocalSettings.Model  \n*Desc:* LocalSettings.Model  \n *Arg1:* strName (String)  \n *Arg2:* localMesh (LOCAL_MESH)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* ilHardPointId (Integer List)  \n *Arg5:* veclHardPointXYZ (Vector List)  \n *Arg6:* crlHardPointTarget (Cursor List)  \n *Arg7:* crEditTarget (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalSettings.Part": {
        prefix: "Part",
        text: "*Name:* Meshing.LocalSettings.Part  \n*Desc:* LocalSettings.Part  \n *Arg1:* strName (String)  \n *Arg2:* localMesh (LOCAL_MESH)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* ilHardPointId (Integer List)  \n *Arg5:* veclHardPointXYZ (Vector List)  \n *Arg6:* crlHardPointTarget (Cursor List)  \n *Arg7:* crEditTarget (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Meshing.LocalSettings.Points": {
        prefix: "Points",
        text: "*Name:* Meshing.LocalSettings.Points  \n*Desc:* LocalSettings.Points  \n *Arg1:* strName (String)  \n *Arg2:* localMesh (LOCAL_MESH)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* ilHardPointId (Integer List)  \n *Arg5:* veclHardPointXYZ (Vector List)  \n *Arg6:* crlHardPointTarget (Cursor List)  \n *Arg7:* crEditTarget (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlane.AdjustThickness": {
        prefix: "AdjustThickness",
        text: "*Name:* MidPlane.AdjustThickness  \n*Desc:* Adjust thickness of midplane  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* dRatio (Double)  \n *Arg3:* bAdjustFaceThick (Boolean)  \n *Arg4:* bAdjustPropThick (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlane.FaceCross": {
        prefix: "FaceCross",
        text: "*Name:* MidPlane.FaceCross  \n*Desc:* Face Cross  \n *Arg1:* crlBodies (Cursor List)  \n *Arg2:* crlFaces (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlane.CreateThickProps": {
        prefix: "CreateThickProps",
        text: "*Name:* MidPlane.CreateThickProps  \n*Desc:* create thick properties for mid-plane  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* dThickDiff (Double)  \n *Arg3:* dMaxThick (Double)  \n *Arg4:* dMinThick (Double)  \n *Arg5:* crMatMembrane (Cursor)  \n *Arg6:* crMatBend (Cursor)  \n *Arg7:* crMatShear (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlane.FindMidPlane": {
        prefix: "FindMidPlane",
        text: "*Name:* MidPlane.FindMidPlane  \n*Desc:* Unknown Description  \n *Arg1:*  ()  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.Edge.Nodes": {
        prefix: "Nodes",
        text: "*Name:* MidPlaneEdit.Edge.Nodes  \n*Desc:* Edit mid-plane with edge nodes  \n *Arg1:* crlNode (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.ExtendFace.CylinderFace": {
        prefix: "CylinderFace",
        text: "*Name:* MidPlaneEdit.ExtendFace.CylinderFace  \n*Desc:* project an edge to face to get a new edge  \n *Arg1:* crlExtFace (Cursor List)  \n *Arg2:* crRefFace (Cursor)  \n *Arg3:* crEdge (Cursor)  \n *Arg4:* iExtendType (Integer)  \n *Arg5:* iFaceType (Integer)  \n *Arg6:* iMethod (Integer)  \n *Arg7:* dParaAngleOffset (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.ExtendFace.PlanarFace": {
        prefix: "PlanarFace",
        text: "*Name:* MidPlaneEdit.ExtendFace.PlanarFace  \n*Desc:* Extend Face  \n *Arg1:* bIType (Boolean)  \n *Arg2:* crExtFace (Cursor)  \n *Arg3:* crRefFace (Cursor)  \n *Arg4:* crEdge (Cursor)  \n *Arg5:* iFaceType (Integer)  \n *Arg6:* iExtendType (Integer)  \n *Arg7:* iMethod (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.Face.FaceExtendtoFace": {
        prefix: "FaceExtendtoFace",
        text: "*Name:* MidPlaneEdit.Face.FaceExtendtoFace  \n*Desc:* add face by face extend to face  \n *Arg1:* crlExtFaces (Cursor List)  \n *Arg2:* crlRefFaces (Cursor List)  \n *Arg3:* bMergeFace (Boolean)  \n *Arg4:* bMergeEdge (Boolean)  \n *Arg5:* dMergeEdgeAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.Face.FaceExtendToIntersection": {
        prefix: "FaceExtendToIntersection",
        text: "*Name:* MidPlaneEdit.Face.FaceExtendToIntersection  \n*Desc:* Face Extend To Intersection  \n *Arg1:* crEdge0 (Cursor)  \n *Arg2:* crEdge1 (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.Face.EdgesToEdges": {
        prefix: "EdgesToEdges",
        text: "*Name:* MidPlaneEdit.Face.EdgesToEdges  \n*Desc:* add face by edges  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* bImprint (Boolean)  \n *Arg3:* bMultiEdges (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.Manual.vecOffset": {
        prefix: "vecOffset",
        text: "*Name:* MidPlaneEdit.Manual.vecOffset  \n*Desc:* Unknown Description  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crPart (Cursor)  \n *Arg3:* dOffset (Double)  \n *Arg4:* bCyl (Boolean)  \n *Arg5:* strNewPartName (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.Manual.MidByPair": {
        prefix: "MidByPair",
        text: "*Name:* MidPlaneEdit.Manual.MidByPair  \n*Desc:* Midplane Manual MidByPair  \n *Arg1:* crlBaseFaces (Cursor List)  \n *Arg2:* crlPairFaces (Cursor List)  \n *Arg3:* crlRefFaces (Cursor List)  \n *Arg4:* crPart (Cursor)  \n *Arg5:* bMergeFaces (Boolean)  \n *Arg6:* bExtendFaces (Boolean)  \n *Arg7:* bHideFaces (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.AddItems.Edge.ProjectEdgeToFace": {
        prefix: "ProjectEdgeToFace",
        text: "*Name:* MidPlaneEdit.AddItems.Edge.ProjectEdgeToFace  \n*Desc:* project an edge to face to get a new edge  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* bExtendEdge (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.AddItems.Edge.FaceTwoFace": {
        prefix: "FaceTwoFace",
        text: "*Name:* MidPlaneEdit.AddItems.Edge.FaceTwoFace  \n*Desc:* Exent face to face  \n *Arg1:* crRefFace (Cursor)  \n *Arg2:* crExtFace (Cursor)  \n *Arg3:* iExtendType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.AddItems.Face.EFExtendFreeEdge": {
        prefix: "EFExtendFreeEdge",
        text: "*Name:* MidPlaneEdit.AddItems.Face.EFExtendFreeEdge  \n*Desc:* Create new face by extend free edge to a destination face  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* bMergeFace (Boolean)  \n *Arg4:* bMergeEdge (Boolean)  \n *Arg5:* bUseNeighDir (Boolean)  \n *Arg6:* dMergeEdgeAngle (Double)  \n *Arg7:* bMultiEF (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MidPlaneEdit.AddItems.Face.EFProject": {
        prefix: "EFProject",
        text: "*Name:* MidPlaneEdit.AddItems.Face.EFProject  \n*Desc:* Creat new face by project edge to destination face  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* bMergeFace (Boolean)  \n *Arg4:* bMergeEdge (Boolean)  \n *Arg5:* dMergeEdgeAngle (Double)  \n *Arg6:* bMultiEF (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MMCCarACTools.ACModelCreationTools.MeshedFace": {
        prefix: "MeshedFace",
        text: "*Name:* MMCCarACTools.ACModelCreationTools.MeshedFace  \n*Desc:*   \n *Arg1:* crlItem1 (Cursor List)  \n *Arg2:* crlItem2 (Cursor List)  \n *Arg3:* crlItem3 (Cursor List)  \n *Arg4:* crlPart (Cursor List)  \n *Arg5:* iType (Integer)  \n *Arg6:* dMeshSise (Double)  \n *Arg7:* bMergeTol (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MMCCarACTools.ClearanceElement.Connect": {
        prefix: "Connect",
        text: "*Name:* MMCCarACTools.ClearanceElement.Connect  \n*Desc:* MMCCarACTools ClearanceElement Connect  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlElem (Cursor List)  \n *Arg3:* iConnectionMethod (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MMCCarACTools.ClearanceElement.Edit": {
        prefix: "Edit",
        text: "*Name:* MMCCarACTools.ClearanceElement.Edit  \n*Desc:* Edit clearance elment  \n *Arg1:* dDx (Double)  \n *Arg2:* dDy (Double)  \n *Arg3:* dDz (Double)  \n *Arg4:* dLx (Double)  \n *Arg5:* dLy (Double)  \n *Arg6:* dLz (Double)  \n *Arg7:* crlTarget (Cursor List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MufflerHA.CreateEdge.PerpendicularLineToEdge": {
        prefix: "PerpendicularLineToEdge",
        text: "*Name:* MufflerHA.CreateEdge.PerpendicularLineToEdge  \n*Desc:* Unknown Description  \n *Arg1:* crNode (Cursor)  \n *Arg2:* crEdge (Cursor)  \n *Arg3:* crlFace (Cursor List)  \n *Arg4:* bBreakFace (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MufflerHA.CreateEdgeClassic.ProjectLine": {
        prefix: "ProjectLine",
        text: "*Name:* MufflerHA.CreateEdgeClassic.ProjectLine  \n*Desc:* create edge  \n *Arg1:* ilAiedgeidForMacro (Integer List)  \n *Arg2:* ilAifaceidForMacro (Integer List)  \n *Arg3:* bDivideFace (Boolean)  \n *Arg4:* crlAiparttargetForMarco (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MufflerHA.CopyMeshCount": {
        prefix: "CopyMeshCount",
        text: "*Name:* MufflerHA.CopyMeshCount  \n*Desc:*   \n *Arg1:* crlMasterEdge (Cursor List)  \n *Arg2:* crlSlaveEdge (Cursor List)  \n *Arg3:* strBaseName (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MufflerT.SpecialModeling.Rod.Rod": {
        prefix: "Rod",
        text: "*Name:* MufflerT.SpecialModeling.Rod.Rod  \n*Desc:* create rod  \n *Arg1:* crlNode (Cursor List)  \n *Arg2:* dRadius (Double)  \n *Arg3:* iType (Integer)  \n *Arg4:* dMeshSize (Double)  \n *Arg5:* dStartDist (Double)  \n *Arg6:* dWeldDist (Double)  \n *Arg7:* iDivNumber (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MuxWeld.CreateWeld.Auto": {
        prefix: "Auto",
        text: "*Name:* MuxWeld.CreateWeld.Auto  \n*Desc:* Auto create weld  \n *Arg1:* iIconnectattributeMethod (Integer)  \n *Arg2:* strStrconnectattributeName (String)  \n *Arg3:* crlMasterTarget (Cursor List)  \n *Arg4:* crlSlaveTarget (Cursor List)  \n *Arg5:* iIconnectattributeCoordsys (Integer)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MuxWeld.CreateWeld.CreateBeadWeld": {
        prefix: "CreateBeadWeld",
        text: "*Name:* MuxWeld.CreateWeld.CreateBeadWeld  \n*Desc:* Unknown Description  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* crlPrjtedEdge (Cursor List)  \n *Arg3:* crlPart (Cursor List)  \n *Arg4:* dTol (Double)  \n *Arg5:* dRatio (Double)  \n *Arg6:* crRefElem (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MuxWeld.DefineSequence.Single": {
        prefix: "Single",
        text: "*Name:* MuxWeld.DefineSequence.Single  \n*Desc:* Define Sequence  \n *Arg1:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "MuxWeld.MeshingPass": {
        prefix: "MeshingPass",
        text: "*Name:* MuxWeld.MeshingPass  \n*Desc:* sweep cross section to create welding  \n *Arg1:* crPart (Cursor)  \n *Arg2:* crlEdge (Cursor List)  \n *Arg3:* dMeshSize (Double)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* create Property 3D Weld Bead  \n *Arg1:* strName (String)  \n *Arg2:* crMaterial (Cursor)  \n *Arg3:* crlTarget (Cursor List)  \n *Arg4:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "NSModeling.NSModeling_Close_Hole": {
        prefix: "NSModeling_Close_Hole",
        text: "*Name:* NSModeling.NSModeling_Close_Hole  \n*Desc:* NSModeling NSModeling_Close_Hole  \n *Arg1:* iType (Integer)  \n *Arg2:* dMaxLength (Double)  \n *Arg3:* bMergeFaces (Boolean)  \n *Arg4:* bSetCenterPoint (Boolean)  \n *Arg5:* crlNode (Cursor List)  \n *Arg6:* crlPart (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "OasisAWizard.LocalMeshing.FilletMapMeshing": {
        prefix: "FilletMapMeshing",
        text: "*Name:* OasisAWizard.LocalMeshing.FilletMapMeshing  \n*Desc:*   \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* dMinLength (Double)  \n *Arg4:* dMaxLength (Double)  \n *Arg5:* dMinRadius (Double)  \n *Arg6:* dMaxRadius (Double)  \n *Arg7:* bConvex (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* import Nastran op2 mesh  \n *Arg1:* strlFilePaths (String List)  \n *Arg2:* iImportType (Integer)  \n *Arg3:* dFaceAngle (Double)  \n *Arg4:* dEdgeAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* import Nastran op2 post job  \n *Arg1:* strName (String)  \n *Arg2:* strlPaths (String List)  \n *Arg3:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Post.ImportResults.ImportTsdbMesh": {
        prefix: "ImportTsdbMesh",
        text: "*Name:* Post.ImportResults.ImportTsdbMesh  \n*Desc:* import tsdb mesh  \n *Arg1:* strTsdbFilePath (String)  \n *Arg2:* strBtxFilePath (String)  \n *Arg3:* iImportType (Integer)  \n *Arg4:* dFaceAngle (Double)  \n *Arg5:* dEdgeAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* import Nastran HDF5Mesh file  \n *Arg1:* strlFilePaths (String List)  \n *Arg2:* iImportType (Integer)  \n *Arg3:* dFaceAngle (Double)  \n *Arg4:* dEdgeAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Post.ImportResults.ADVC": {
        prefix: "ADVC",
        text: "*Name:* Post.ImportResults.ADVC  \n*Desc:* Unknown Description  \n *Arg1:* strlPath (String List)  \n *Arg2:* iImportType (Integer)  \n *Arg3:* dFaceAngle (Double)  \n *Arg4:* dEdgeAngle (Double)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Post ImportResults ADVC2PostJob  \n *Arg1:* strName (String)  \n *Arg2:* strlResultFolderPaths (String List)  \n *Arg3:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Import Nastran HDF5PostJob file  \n *Arg1:* strName (String)  \n *Arg2:* strlPaths (String List)  \n *Arg3:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.ElemRelatedInfo.Shell": {
        prefix: "Shell",
        text: "*Name:* Properties.ElemRelatedInfo.Shell  \n*Desc:* Set Shell Parameter  \n *Arg1:* listErishellThetaProp (ERISHELL_THETA_PROP List)  \n *Arg2:* listErishellCsProp (ERISHELL_CS_PROP List)  \n *Arg3:* listErishellZoffsProp (ERISHELL_ZOFFS_PROP List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.ElemRelatedInfo.Conn": {
        prefix: "Conn",
        text: "*Name:* Properties.ElemRelatedInfo.Conn  \n*Desc:* Set Shell Parameter  \n *Arg1:* listEricontEndProp (ERICONT_END_PROP List)  \n *Arg2:* listEricontOriVecProp (ERICONT_ORI_VEC_PROP List)  \n *Arg3:* listCidProp (CID_PROP List)  \n *Arg4:* listEricontDamperLocProp (ERICONT_DAMPER_LOC_PROP List)  \n *Arg5:* listOcidProp (OCID_PROP List)  \n *Arg6:* listDamperOffsetVecs (DAMPER_OFFSET_VECS List)  \n *Arg7:* listEricontNodeidProp (ERICONT_NODEID_PROP List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.ElemRelatedInfo.Rod": {
        prefix: "Rod",
        text: "*Name:* Properties.ElemRelatedInfo.Rod  \n*Desc:* Set Rod Parameter  \n *Arg1:* listEricontEndProp (ERICONT_END_PROP List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.ElemRelatedInfo.Beam": {
        prefix: "Beam",
        text: "*Name:* Properties.ElemRelatedInfo.Beam  \n*Desc:* Set Beam Parameter  \n *Arg1:* listEribeamEndProp (ERIBEAM_END_PROP List)  \n *Arg2:* listEribeamOriVecProp (ERIBEAM_ORI_VEC_PROP List)  \n *Arg3:* listEribeamOriNodeidProp (ERIBEAM_ORI_NODEID_PROP List)  \n *Arg4:* listEribeamOffsetVecA (ERIBEAM_OFFSET_VEC_A List)  \n *Arg5:* listEribeamOffsetVecB (ERIBEAM_OFFSET_VEC_B List)  \n *Arg6:* listEribeamPinAProp (ERIBEAM_PIN_APROP List)  \n *Arg7:* listEribeamPinBProp (ERIBEAM_PIN_BPROP List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.ElemRelatedInfo.Bar": {
        prefix: "Bar",
        text: "*Name:* Properties.ElemRelatedInfo.Bar  \n*Desc:* Set Bar Parameter  \n *Arg1:* listEribeamEndProp (ERIBEAM_END_PROP List)  \n *Arg2:* listEribeamOriVecProp (ERIBEAM_ORI_VEC_PROP List)  \n *Arg3:* listEribeamOriNodeidProp (ERIBEAM_ORI_NODEID_PROP List)  \n *Arg4:* listEribeamOffsetVecA (ERIBEAM_OFFSET_VEC_A List)  \n *Arg5:* listEribeamOffsetVecB (ERIBEAM_OFFSET_VEC_B List)  \n *Arg6:* listEribeamPinAProp (ERIBEAM_PIN_APROP List)  \n *Arg7:* listEribeamPinBProp (ERIBEAM_PIN_BPROP List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.ElemRelatedInfo.Gap": {
        prefix: "Gap",
        text: "*Name:* Properties.ElemRelatedInfo.Gap  \n*Desc:* Set Shell Parameter  \n *Arg1:* listEricontEndProp (ERICONT_END_PROP List)  \n *Arg2:* listEricontOriVecProp (ERICONT_ORI_VEC_PROP List)  \n *Arg3:* listCidProp (CID_PROP List)  \n *Arg4:* listEricontDamperLocProp (ERICONT_DAMPER_LOC_PROP List)  \n *Arg5:* listOcidProp (OCID_PROP List)  \n *Arg6:* listDamperOffsetVecs (DAMPER_OFFSET_VECS List)  \n *Arg7:* listEricontNodeidProp (ERICONT_NODEID_PROP List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.ElemRelatedInfo.Bush": {
        prefix: "Bush",
        text: "*Name:* Properties.ElemRelatedInfo.Bush  \n*Desc:* Set Shell Parameter  \n *Arg1:* listEricontEndProp (ERICONT_END_PROP List)  \n *Arg2:* listEricontOriVecProp (ERICONT_ORI_VEC_PROP List)  \n *Arg3:* listCidProp (CID_PROP List)  \n *Arg4:* listEricontDamperLocProp (ERICONT_DAMPER_LOC_PROP List)  \n *Arg5:* listOcidProp (OCID_PROP List)  \n *Arg6:* listDamperOffsetVecs (DAMPER_OFFSET_VECS List)  \n *Arg7:* listEricontNodeidProp (ERICONT_NODEID_PROP List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Material.Add": {
        prefix: "Add",
        text: "*Name:* Properties.Material.Add  \n*Desc:* Unknown Description  \n *Arg1:* strMaterialName (String)  \n *Arg2:* listMaterialProperty (MATERIAL_PROPERTY List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Material.Modify": {
        prefix: "Modify",
        text: "*Name:* Properties.Material.Modify  \n*Desc:* Unknown Description  \n *Arg1:* strMaterialID (String)  \n *Arg2:* listMaterialProperty (MATERIAL_PROPERTY List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Material.Delete": {
        prefix: "Delete",
        text: "*Name:* Properties.Material.Delete  \n*Desc:* Unknown Description  \n *Arg1:* strMaterialID (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Section.Import": {
        prefix: "Import",
        text: "*Name:* Properties.Section.Import  \n*Desc:* import 1D Section  \n *Arg1:* strImportPath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Section.ModifyGeneral": {
        prefix: "ModifyGeneral",
        text: "*Name:* Properties.Section.ModifyGeneral  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crSection (Cursor)  \n *Arg3:* iSecType (Integer)  \n *Arg4:* iGeneralType (Integer)  \n *Arg5:* dA (Double)  \n *Arg6:* dB (Double)  \n *Arg7:* dH (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Section.ModifyLibrary": {
        prefix: "ModifyLibrary",
        text: "*Name:* Properties.Section.ModifyLibrary  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crSection (Cursor)  \n *Arg3:* iType (Integer)  \n *Arg4:* iLibType (Integer)  \n *Arg5:* dDimSize0 (Double)  \n *Arg6:* dDimSize1 (Double)  \n *Arg7:* dDimSize2 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Section.ModifySketcher": {
        prefix: "ModifySketcher",
        text: "*Name:* Properties.Section.ModifySketcher  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* crSection (Cursor)  \n *Arg3:* iType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Section.Export": {
        prefix: "Export",
        text: "*Name:* Properties.Section.Export  \n*Desc:* export 1D section to xml file  \n *Arg1:* strExportSavePath (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Section.Delete": {
        prefix: "Delete",
        text: "*Name:* Properties.Section.Delete  \n*Desc:* Properties Section Delete  \n *Arg1:* crlSection (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Section.AddGeneral": {
        prefix: "AddGeneral",
        text: "*Name:* Properties.Section.AddGeneral  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* iSecType (Integer)  \n *Arg3:* iSecGenType (Integer)  \n *Arg4:* dDsecGensizeA (Double)  \n *Arg5:* dDsecGensizeB (Double)  \n *Arg6:* dDsecGensizeH (Double)  \n *Arg7:* dDsecGensizeT1 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Section.AddLibrary": {
        prefix: "AddLibrary",
        text: "*Name:* Properties.Section.AddLibrary  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* iSecType (Integer)  \n *Arg3:* iLibType (Integer)  \n *Arg4:* dDim1 (Double)  \n *Arg5:* dDim2 (Double)  \n *Arg6:* dDim3 (Double)  \n *Arg7:* dDim4 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Section.AddSketcher": {
        prefix: "AddSketcher",
        text: "*Name:* Properties.Section.AddSketcher  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* iSecType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Cohesive": {
        prefix: "Cohesive",
        text: "*Name:* Properties.Cohesive  \n*Desc:* create property 3d cohesive  \n *Arg1:* strName (String)  \n *Arg2:* crMaterial (Cursor)  \n *Arg3:* iResponse (Integer)  \n *Arg4:* bSpecifyThick (Boolean)  \n *Arg5:* dInitialThick (Double)  \n *Arg6:* crlTarget (Cursor List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Gasket": {
        prefix: "Gasket",
        text: "*Name:* Properties.Gasket  \n*Desc:* create property 3d gasket  \n *Arg1:* strName (String)  \n *Arg2:* crMaterial (Cursor)  \n *Arg3:* dThickX (Double)  \n *Arg4:* dThickY (Double)  \n *Arg5:* dThickZ (Double)  \n *Arg6:* crlTarget (Cursor List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Shell": {
        prefix: "Shell",
        text: "*Name:* Properties.Shell  \n*Desc:* create shell property  \n *Arg1:* strName (String)  \n *Arg2:* iPID (Integer)  \n *Arg3:* crMatMembrane (Cursor)  \n *Arg4:* crMatBend (Cursor)  \n *Arg5:* crMatShear (Cursor)  \n *Arg6:* crMatCoupl (Cursor)  \n *Arg7:* dMatOrient1 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.PropertyTable": {
        prefix: "PropertyTable",
        text: "*Name:* Properties.PropertyTable  \n*Desc:* renumber property/material ID  \n *Arg1:* listRenumberProp (RENUMBER_PROP List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Beam": {
        prefix: "Beam",
        text: "*Name:* Properties.Beam  \n*Desc:* add property of 1D beam  \n *Arg1:* strNewName (String)  \n *Arg2:* iPId (Integer)  \n *Arg3:* crSection (Cursor)  \n *Arg4:* iShapeDataType (Integer)  \n *Arg5:* crMat (Cursor)  \n *Arg6:* dArea (Double)  \n *Arg7:* dlVecOrient (Double List)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Rod": {
        prefix: "Rod",
        text: "*Name:* Properties.Rod  \n*Desc:* create 1D rod property  \n *Arg1:* strName (String)  \n *Arg2:* iId (Integer)  \n *Arg3:* crSection (Cursor)  \n *Arg4:* crMat (Cursor)  \n *Arg5:* dArea (Double)  \n *Arg6:* dTorConst (Double)  \n *Arg7:* dTorStressCoeff (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:*   \n *Arg1:* strName (String)  \n *Arg2:* iId (Integer)  \n *Arg3:* crSection (Cursor)  \n *Arg4:* crMat (Cursor)  \n *Arg5:* vecOrient (Vector)  \n *Arg6:* crlTarget (Cursor List)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Solid": {
        prefix: "Solid",
        text: "*Name:* Properties.Solid  \n*Desc:* create property solid  \n *Arg1:* strName (String)  \n *Arg2:* iPID (Integer)  \n *Arg3:* crMaterial (Cursor)  \n *Arg4:* iCordM (Integer)  \n *Arg5:* iIN (Integer)  \n *Arg6:* iOutLoc (Integer)  \n *Arg7:* iISOP (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* Create 1D Property Sketcher Section  \n *Arg1:* strName (String)  \n *Arg2:* iSecType (Integer)  \n *Arg3:* iSecGentype (Integer)  \n *Arg4:* dSecGensizeA (Double)  \n *Arg5:* dSecGensizeB (Double)  \n *Arg6:* dSecGensizeH (Double)  \n *Arg7:* dSecGensizeT1 (Double)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.Composite": {
        prefix: "Composite",
        text: "*Name:* Properties.Composite  \n*Desc:* Create 2D Composite Material Shell Property  \n *Arg1:* strName (String)  \n *Arg2:* iDFT (Integer)  \n *Arg3:* dGE (Double)  \n *Arg4:* iDLAM (Integer)  \n *Arg5:* crMat (Cursor)  \n *Arg6:* dNSM (Double)  \n *Arg7:* iDPID (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.BAR": {
        prefix: "BAR",
        text: "*Name:* Properties.BAR  \n*Desc:* create 1D bar property  \n *Arg1:* strName (String)  \n *Arg2:* iId (Integer)  \n *Arg3:* crSection (Cursor)  \n *Arg4:* iShapeDataType (Integer)  \n *Arg5:* crDatacrMat (Cursor)  \n *Arg6:* dDatadArea (Double)  \n *Arg7:* 0 (0)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.ThicknessDistribution": {
        prefix: "ThicknessDistribution",
        text: "*Name:* Properties.ThicknessDistribution  \n*Desc:* Properties view Thickness Distribution  \n *Arg1:* dMax (Double)  \n *Arg2:* dMin (Double)  \n *Arg3:* iByEach (Integer)  \n *Arg4:* dlThicknessValueSet (Double List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Properties.RigidBody": {
        prefix: "RigidBody",
        text: "*Name:* Properties.RigidBody  \n*Desc:* assign properties rigid body  \n *Arg1:* strName (String)  \n *Arg2:* iId (Integer)  \n *Arg3:* iRefNodeId (Integer)  \n *Arg4:* crlTarget (Cursor List)  \n *Arg5:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SNOnePush.DropTest.CalcTimestep": {
        prefix: "CalcTimestep",
        text: "*Name:* SNOnePush.DropTest.CalcTimestep  \n*Desc:* Used to calculate time step for drop test function  \n *Arg1:* dRelevantElemRate (Double)  \n *Arg2:* dChangeMassRage (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SNOnePush.DropTest.UpdateFloor": {
        prefix: "UpdateFloor",
        text: "*Name:* SNOnePush.DropTest.UpdateFloor  \n*Desc:* Assemble cylinder layer  \n *Arg1:* strName (String)  \n *Arg2:* iDir (Integer)  \n *Arg3:* dRopHeight (Double)  \n *Arg4:* dSolutionTime (Double)  \n *Arg5:* iNumberOutput (Integer)  \n *Arg6:* dContactFriction (Double)  \n *Arg7:* iRotAxis (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SNOnePush.DropTest.DropRotation": {
        prefix: "DropRotation",
        text: "*Name:* SNOnePush.DropTest.DropRotation  \n*Desc:* Assemble cylinder layer  \n *Arg1:* strName (String)  \n *Arg2:* iDir (Integer)  \n *Arg3:* dRopHeight (Double)  \n *Arg4:* dSolutionTime (Double)  \n *Arg5:* iNumberOutput (Integer)  \n *Arg6:* dContactFriction (Double)  \n *Arg7:* iRotAxis (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SNOnePush.CADImport": {
        prefix: "CADImport",
        text: "*Name:* SNOnePush.CADImport  \n*Desc:* import CAD model  \n *Arg1:* dDsurfaceplaneTolerance (Double)  \n *Arg2:* dDsurfaceplaneAngle (Double)  \n *Arg3:* dMaxFacetWidth (Double)  \n *Arg4:* bBnxMultipart (Boolean)  \n *Arg5:* dChordHeightTolerance (Double)  \n *Arg6:* dAngleToleranceDegree (Double)  \n *Arg7:* iConvertIsolatedCurve (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SNOnePush.DropTestSNOnePush": {
        prefix: "DropTestSNOnePush",
        text: "*Name:* SNOnePush.DropTestSNOnePush  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* iDir (Integer)  \n *Arg3:* dRopHeight (Double)  \n *Arg4:* dSolutionTime (Double)  \n *Arg5:* iNumOutput (Integer)  \n *Arg6:* dContactFriction (Double)  \n *Arg7:* iRotAxis (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SNOnePush.AutoSweepClosedLoopShaped": {
        prefix: "AutoSweepClosedLoopShaped",
        text: "*Name:* SNOnePush.AutoSweepClosedLoopShaped  \n*Desc:* Make hexa for closed loop shaped  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* dMeshSize (Double)  \n *Arg3:* dLengthSize (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "StiffCalc.Force": {
        prefix: "Force",
        text: "*Name:* StiffCalc.Force  \n*Desc:* create NormalUnityForce  \n *Arg1:* strName (String)  \n *Arg2:* poslForce (Position List)  \n *Arg3:* poslMoment (Position List)  \n *Arg4:* iEnArrowDir (Integer)  \n *Arg5:* iDistributionMethod (Integer)  \n *Arg6:* crCurCoord (Cursor)  \n *Arg7:* crTable (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SZOnepushReliability.Assembly.CreateWeld": {
        prefix: "CreateWeld",
        text: "*Name:* SZOnepushReliability.Assembly.CreateWeld  \n*Desc:* Create welding  \n *Arg1:* crlWelds (Cursor List)  \n *Arg2:* dMeshSize (Double)  \n *Arg3:* iRrate (Integer)  \n *Arg4:* dFilletRadius (Double)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SZOnepushReliability.Assembly.ContactSurface": {
        prefix: "ContactSurface",
        text: "*Name:* SZOnepushReliability.Assembly.ContactSurface  \n*Desc:* Contact surface  \n *Arg1:* crlSrcFace (Cursor List)  \n *Arg2:* crlTarPart (Cursor List)  \n *Arg3:* dTolerance (Double)  \n *Arg4:* iLayer (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SZOnepushReliability.MeshEdit.FilletMapping": {
        prefix: "FilletMapping",
        text: "*Name:* SZOnepushReliability.MeshEdit.FilletMapping  \n*Desc:* Fillet mapping  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* dMinRadius (Double)  \n *Arg4:* dMaxRadius (Double)  \n *Arg5:* dMinAngle (Double)  \n *Arg6:* dMaxAngle (Double)  \n *Arg7:* bConvex (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "SZOnepushReliability.AlignMidNode": {
        prefix: "AlignMidNode",
        text: "*Name:* SZOnepushReliability.AlignMidNode  \n*Desc:* align mid-nodes  \n *Arg1:* crlSource (Cursor List)  \n *Arg2:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Test.Connection.RRod": {
        prefix: "RRod",
        text: "*Name:* Test.Connection.RRod  \n*Desc:* create RRod  \n *Arg1:* rbarConnection (RBAR_CONNECTION)  \n *Arg2:* iUlDOFs (Integer)  \n *Arg3:* dTol (Double)  \n *Arg4:* crlMasterTarget (Cursor List)  \n *Arg5:* crlSlaveTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Test.Muffler.ProjectLineForWeld": {
        prefix: "ProjectLineForWeld",
        text: "*Name:* Test.Muffler.ProjectLineForWeld  \n*Desc:* Projec line for weld  \n *Arg1:* crlEdge (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Test.ZGeometryTest.IntersectionCheck": {
        prefix: "IntersectionCheck",
        text: "*Name:* Test.ZGeometryTest.IntersectionCheck  \n*Desc:* Intersection check  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* crlElem (Cursor List)  \n *Arg4:* iType (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Test.ZGeometryTest.ShellAssy": {
        prefix: "ShellAssy",
        text: "*Name:* Test.ZGeometryTest.ShellAssy  \n*Desc:* Unknown Description  \n *Arg1:* taPart (TA_PART)  \n *Arg2:* crlFace (Cursor List)  \n *Arg3:* _iMeshType (_I_MESH_TYPE)  \n *Arg4:* _bSelfIntersection (_B_SELF_INTERSECTION)  \n *Arg5:* _iMethod (_I_METHOD)  \n *Arg6:* _dGapTol (_D_GAP_TOL)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Test.FindFacesInPart": {
        prefix: "FindFacesInPart",
        text: "*Name:* Test.FindFacesInPart  \n*Desc:* Find faces in part by typical description  \n *Arg1:* crPart (Cursor)  \n *Arg2:* strIdentical (String)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Test.CreateElementForWelding": {
        prefix: "CreateElementForWelding",
        text: "*Name:* Test.CreateElementForWelding  \n*Desc:* Create weld elements  \n *Arg1:* crlSrcElems (Cursor List)  \n *Arg2:* crlDstElems (Cursor List)  \n *Arg3:* crlSideElems (Cursor List)  \n *Arg4:* crlPart (Cursor List)  \n *Arg5:* crMaterial (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Toolbar.Undo": {
        prefix: "Undo",
        text: "*Name:* Toolbar.Undo  \n*Desc:* Undo  \n *Arg1:* iCntUndo (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Toolbar.Redo": {
        prefix: "Redo",
        text: "*Name:* Toolbar.Redo  \n*Desc:* Redo  \n *Arg1:* iCntRedo (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.BySelection.SelectionOrder": {
        prefix: "SelectionOrder",
        text: "*Name:* Tools.BySelection.SelectionOrder  \n*Desc:* Renumber by selection order  \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* iType (Integer)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iStartID (Integer)  \n *Arg5:* iIncrementStep (Integer)  \n *Arg6:* bAscending (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.BySelection.Position": {
        prefix: "Position",
        text: "*Name:* Tools.BySelection.Position  \n*Desc:* Renumber by position  \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* iType (Integer)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iStartID (Integer)  \n *Arg5:* iIncrementStep (Integer)  \n *Arg6:* bAscending1 (Boolean)  \n *Arg7:* bAscending2 (Boolean)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.BySelection.OriginalID": {
        prefix: "OriginalID",
        text: "*Name:* Tools.BySelection.OriginalID  \n*Desc:* Renumber by original ID  \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* iType (Integer)  \n *Arg3:* iMethod (Integer)  \n *Arg4:* iStartID (Integer)  \n *Arg5:* iIncrementStep (Integer)  \n *Arg6:* bAscending (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Coordinates.CylinderFace": {
        prefix: "CylinderFace",
        text: "*Name:* Tools.Coordinates.CylinderFace  \n*Desc:* create Coordinate by Cylinder Face  \n *Arg1:* strName (String)  \n *Arg2:* iCoordType (Integer)  \n *Arg3:* crFace (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Coordinates.ThreeNode": {
        prefix: "ThreeNode",
        text: "*Name:* Tools.Coordinates.ThreeNode  \n*Desc:* create Coordinate by Cylinder Face  \n *Arg1:* strName (String)  \n *Arg2:* iCoordType (Integer)  \n *Arg3:* iOrder (Integer)  \n *Arg4:* crlNode (Cursor List)  \n *Arg5:* veclPoints (Vector List)  \n *Arg6:* crRefCoord (Cursor)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Coordinates.Align": {
        prefix: "Align",
        text: "*Name:* Tools.Coordinates.Align  \n*Desc:* create Coordinate by Align  \n *Arg1:* strName (String)  \n *Arg2:* iCoordType (Integer)  \n *Arg3:* iCoordAxis (Integer)  \n *Arg4:* bCreateNew (Boolean)  \n *Arg5:* crlNode (Cursor List)  \n *Arg6:* crEdge (Cursor)  \n *Arg7:* crEdit (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Coordinates.vecOffset": {
        prefix: "vecOffset",
        text: "*Name:* Tools.Coordinates.vecOffset  \n*Desc:* Unknown Description  \n *Arg1:* strName (String)  \n *Arg2:* iCoordType (Integer)  \n *Arg3:* vTranslate (V_TRANSLATE)  \n *Arg4:* bCreateNew (Boolean)  \n *Arg5:* crRefCoord (Cursor)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Coordinates.Rotate": {
        prefix: "Rotate",
        text: "*Name:* Tools.Coordinates.Rotate  \n*Desc:* create Coordinate by Rotate  \n *Arg1:* strName (String)  \n *Arg2:* iCoordType (Integer)  \n *Arg3:* vecRotate (Vector)  \n *Arg4:* bCreateNew (Boolean)  \n *Arg5:* crRefCoord (Cursor)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Coordinates.AttachCircle": {
        prefix: "AttachCircle",
        text: "*Name:* Tools.Coordinates.AttachCircle  \n*Desc:* create Coordinate by AttachCircle  \n *Arg1:* strName (String)  \n *Arg2:* iCoordType (Integer)  \n *Arg3:* crEdge (Cursor)  \n *Arg4:* bCreateNew (Boolean)  \n *Arg5:* crRefCoord (Cursor)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Coordinates.AttachNode": {
        prefix: "AttachNode",
        text: "*Name:* Tools.Coordinates.AttachNode  \n*Desc:* create Coordinate by AttachNode  \n *Arg1:* strName (String)  \n *Arg2:* iCoordType (Integer)  \n *Arg3:* crNode (Cursor)  \n *Arg4:* bCreateNew (Boolean)  \n *Arg5:* crRefCoord (Cursor)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Coordinates.Face": {
        prefix: "Face",
        text: "*Name:* Tools.Coordinates.Face  \n*Desc:* create Coordinate by Face  \n *Arg1:* strName (String)  \n *Arg2:* iCoordType (Integer)  \n *Arg3:* iOrder (Integer)  \n *Arg4:* veclPoint (Vector List)  \n *Arg5:* crlNode (Cursor List)  \n *Arg6:* crItem (Cursor)  \n *Arg7:* crRefCoord (Cursor)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Coordinates.Offset": {
        prefix: "Offset",
        text: "*Name:* Tools.Coordinates.Offset  \n*Desc:* create Coordinate by Offset  \n *Arg1:* strName (String)  \n *Arg2:* iCoordType (Integer)  \n *Arg3:* vecTranslate (Vector)  \n *Arg4:* bCreateNew (Boolean)  \n *Arg5:* crRefCoord (Cursor)  \n *Arg6:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Group.DeleteGroupEntity": {
        prefix: "DeleteGroupEntity",
        text: "*Name:* Tools.Group.DeleteGroupEntity  \n*Desc:* Delete Entity in Group  \n *Arg1:* crlDelGroup (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Group.CreateGroup": {
        prefix: "CreateGroup",
        text: "*Name:* Tools.Group.CreateGroup  \n*Desc:* Unknown Description  \n *Arg1:* strGroupName (String)  \n *Arg2:* crlTarget (Cursor List)  \n *Arg3:* crEdit (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.TotalLoad.LBC": {
        prefix: "LBC",
        text: "*Name:* Tools.TotalLoad.LBC  \n*Desc:*   \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* crCoordinate (Cursor)  \n *Arg3:* strOutput (String)  \n *Arg4:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.TotalLoad.Model": {
        prefix: "Model",
        text: "*Name:* Tools.TotalLoad.Model  \n*Desc:*   \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* crCoordinate (Cursor)  \n *Arg3:* strOutput (String)  \n *Arg4:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.TotalLoad.Node": {
        prefix: "Node",
        text: "*Name:* Tools.TotalLoad.Node  \n*Desc:*   \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* crCoordinate (Cursor)  \n *Arg3:* strOutput (String)  \n *Arg4:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.TotalLoad.Part": {
        prefix: "Part",
        text: "*Name:* Tools.TotalLoad.Part  \n*Desc:*   \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* crCoordinate (Cursor)  \n *Arg3:* strOutput (String)  \n *Arg4:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.TotalLoad.Face": {
        prefix: "Face",
        text: "*Name:* Tools.TotalLoad.Face  \n*Desc:*   \n *Arg1:* crlTarget (Cursor List)  \n *Arg2:* crCoordinate (Cursor)  \n *Arg3:* strOutput (String)  \n *Arg4:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.NodeCS": {
        prefix: "NodeCS",
        text: "*Name:* Tools.NodeCS  \n*Desc:* create Node CS  \n *Arg1:* crlInst (Cursor List)  \n *Arg2:* crCoordSystem (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.NodeCSGroup": {
        prefix: "NodeCSGroup",
        text: "*Name:* Tools.NodeCSGroup  \n*Desc:* Unknown Description  \n *Arg1:*  ()  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.DisplacementCS": {
        prefix: "DisplacementCS",
        text: "*Name:* Tools.DisplacementCS  \n*Desc:* displace coordinate  \n *Arg1:* crlInst (Cursor List)  \n *Arg2:* crCoordSystem (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Connections": {
        prefix: "Connections",
        text: "*Name:* Tools.Connections  \n*Desc:* renumber connection  \n *Arg1:* listConnectRenumberTool (CONNECT_RENUMBER_TOOL List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.GroupByDCS": {
        prefix: "GroupByDCS",
        text: "*Name:* Tools.GroupByDCS  \n*Desc:* Unknown Description  \n *Arg1:*  ()  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Renumber": {
        prefix: "Renumber",
        text: "*Name:* Tools.Renumber  \n*Desc:* Set renumber data  \n *Arg1:* listRenumberItem (RENUMBER_ITEM List)  \n *Arg2:* bAssignProp (Boolean)  \n *Arg3:* bSurfCornerFirst (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.RenumberByConnection": {
        prefix: "RenumberByConnection",
        text: "*Name:* Tools.RenumberByConnection  \n*Desc:* Renumber by selection  \n *Arg1:* connectRenumberTool (CONNECT_RENUMBER_TOOL)  \n *Arg2:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.RenumberByFile": {
        prefix: "RenumberByFile",
        text: "*Name:* Tools.RenumberByFile  \n*Desc:* Renumber By File  \n *Arg1:* strCSVPath (String)  \n *Arg2:* iConfilctStrategy (Integer)  \n *Arg3:* bNeedToUpdateCount (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.ModelInfo": {
        prefix: "ModelInfo",
        text: "*Name:* Tools.ModelInfo  \n*Desc:* export model info file  \n *Arg1:* strPath (String)  \n *Arg2:* strPathName (String)  \n *Arg3:* listMeshPartInfoTool (MESH_PART_INFO_TOOL List)  \n *Arg4:* bPropertyAssignedPart (Boolean)  \n *Arg5:* bPropertyAssignedSummary (Boolean)  \n *Arg6:* iModelNode (Integer)  \n *Arg7:* iNmodelnodeWithprop (Integer)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Section": {
        prefix: "Section",
        text: "*Name:* Tools.Section  \n*Desc:* Unknown Description  \n *Arg1:* bSection (Boolean)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.ElementCS": {
        prefix: "ElementCS",
        text: "*Name:* Tools.ElementCS  \n*Desc:* create element coordinate system  \n *Arg1:* iMethod (Integer)  \n *Arg2:* iDispType (Integer)  \n *Arg3:* bDispXDir (Boolean)  \n *Arg4:* bDispCoord (Boolean)  \n *Arg5:* dDispScale (Double)  \n *Arg6:* crlTarget (Cursor List)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Angle.TwoNodesAxis": {
        prefix: "TwoNodesAxis",
        text: "*Name:* Tools.Measure.Angle.TwoNodesAxis  \n*Desc:* Measure the angle created by 2 nodes and Axis.  \n *Arg1:* crNode1 (Cursor)  \n *Arg2:* crNode2 (Cursor)  \n *Arg3:* dlAxis (Double List)  \n *Arg4:* strTarget (String)  \n *Arg5:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Angle.ThreeNodes": {
        prefix: "ThreeNodes",
        text: "*Name:* Tools.Measure.Angle.ThreeNodes  \n*Desc:*   \n *Arg1:* crNode1 (Cursor)  \n *Arg2:* crNode2 (Cursor)  \n *Arg3:* crNode3 (Cursor)  \n *Arg4:* strTarget (String)  \n *Arg5:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Angle.ProjectedNode": {
        prefix: "ProjectedNode",
        text: "*Name:* Tools.Measure.Angle.ProjectedNode  \n*Desc:* measure angle on projected node  \n *Arg1:* crNode (Cursor)  \n *Arg2:* strTarget (String)  \n *Arg3:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Angle.TwoElemEdges": {
        prefix: "TwoElemEdges",
        text: "*Name:* Tools.Measure.Angle.TwoElemEdges  \n*Desc:*   \n *Arg1:* crpElemEdge1 (Cursor Pair)  \n *Arg2:* crpElemEdge2 (Cursor Pair)  \n *Arg3:* strTarget (String)  \n *Arg4:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Angle.TwoAxis": {
        prefix: "TwoAxis",
        text: "*Name:* Tools.Measure.Angle.TwoAxis  \n*Desc:* Measure the angle created by 2 Axis.  \n *Arg1:* 0 (0)  \n *Arg2:* 0] (0])  \n *Arg3:* dlXyz1 (Double List)  \n *Arg4:* 0 (0)  \n *Arg5:* 0] (0])  \n *Arg6:* dlXyz2 (Double List)  \n *Arg7:* strTarget (String)  \n ... please read PSJ Command document for other args ...  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Angle.TwoEdges": {
        prefix: "TwoEdges",
        text: "*Name:* Tools.Measure.Angle.TwoEdges  \n*Desc:* Measure the angle created by 2 edges.  \n *Arg1:* crEdge1 (Cursor)  \n *Arg2:* crEdge2 (Cursor)  \n *Arg3:* strTarget (String)  \n *Arg4:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Area.Element": {
        prefix: "Element",
        text: "*Name:* Tools.Measure.Area.Element  \n*Desc:* Measure Distance By FaceNode  \n *Arg1:* crlElem (Cursor List)  \n *Arg2:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Area.Face": {
        prefix: "Face",
        text: "*Name:* Tools.Measure.Area.Face  \n*Desc:* Measure Distance By FaceNode  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Area.Part": {
        prefix: "Part",
        text: "*Name:* Tools.Measure.Area.Part  \n*Desc:* Measure Distance By FaceNode  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Distance.TwoEdges": {
        prefix: "TwoEdges",
        text: "*Name:* Tools.Measure.Distance.TwoEdges  \n*Desc:* measure the distance of two edges  \n *Arg1:* crEdge1 (Cursor)  \n *Arg2:* crEdge2 (Cursor)  \n *Arg3:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Distance.TwoNodes": {
        prefix: "TwoNodes",
        text: "*Name:* Tools.Measure.Distance.TwoNodes  \n*Desc:* Measure Distance Two Nodes  \n *Arg1:* crNode1 (Cursor)  \n *Arg2:* crNode2 (Cursor)  \n *Arg3:* strTarget (String)  \n *Arg4:* iPrecision (Integer)  \n *Arg5:* crCoordinateSystem (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Distance.FaceNode": {
        prefix: "FaceNode",
        text: "*Name:* Tools.Measure.Distance.FaceNode  \n*Desc:* Measure Distance By FaceNode  \n *Arg1:* crlFace (Cursor List)  \n *Arg2:* crlNode (Cursor List)  \n *Arg3:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Distance.Edge": {
        prefix: "Edge",
        text: "*Name:* Tools.Measure.Distance.Edge  \n*Desc:* Measure Edge Length  \n *Arg1:* crEdge (Cursor)  \n *Arg2:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Distance.TwoPoints": {
        prefix: "TwoPoints",
        text: "*Name:* Tools.Measure.Distance.TwoPoints  \n*Desc:* measure distance 2 points  \n *Arg1:* posPoint1 (Position)  \n *Arg2:* posPoint2 (Position)  \n *Arg3:* strTarget (String)  \n *Arg4:* iPrecision (Integer)  \n *Arg5:* crCoordinateSystem (Cursor)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Distance.EdgeNode": {
        prefix: "EdgeNode",
        text: "*Name:* Tools.Measure.Distance.EdgeNode  \n*Desc:* Measure Distance From Node to Edge  \n *Arg1:* crEdge (Cursor)  \n *Arg2:* crNode (Cursor)  \n *Arg3:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Distance.LineNode": {
        prefix: "LineNode",
        text: "*Name:* Tools.Measure.Distance.LineNode  \n*Desc:* Measures the distance of a perpendicular line from a node toward the line defined by the two nodes.  \n *Arg1:* crlTargetNode (Cursor List)  \n *Arg2:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Distance.PlaneElemToNode": {
        prefix: "PlaneElemToNode",
        text: "*Name:* Tools.Measure.Distance.PlaneElemToNode  \n*Desc:* Measure Distance between Node and plane (created by element).  \n *Arg1:* crNode (Cursor)  \n *Arg2:* crElem (Cursor)  \n *Arg3:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n *Desc:* measure the distance from node to plane(defined by 3 nodes)  \n *Arg1:* crNode1 (Cursor)  \n *Arg2:* crNode2 (Cursor)  \n *Arg3:* crNode3 (Cursor)  \n *Arg4:* crNode (Cursor)  \n *Arg5:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Mass.Property": {
        prefix: "Property",
        text: "*Name:* Tools.Measure.Mass.Property  \n*Desc:* measure mass using applied property  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlCondition (Cursor List)  \n *Arg3:* strTarget (String)  \n *Arg4:* bGravityCenter (Boolean)  \n *Arg5:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Mass.Material": {
        prefix: "Material",
        text: "*Name:* Tools.Measure.Mass.Material  \n*Desc:* measure mass by material  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* crlCondition (Cursor List)  \n *Arg3:* strDensity (String)  \n *Arg4:* strTarget (String)  \n *Arg5:* bGravityCenter (Boolean)  \n *Arg6:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Radius.Edge": {
        prefix: "Edge",
        text: "*Name:* Tools.Measure.Radius.Edge  \n*Desc:* Measure edge minimum radius  \n *Arg1:* crEdge (Cursor)  \n *Arg2:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Radius.ThreeNodes": {
        prefix: "ThreeNodes",
        text: "*Name:* Tools.Measure.Radius.ThreeNodes  \n*Desc:* Measure Radius MeasureRadiusBy3Nodes  \n *Arg1:* crNode13 (Cursor)  \n *Arg2:* crNode23 (Cursor)  \n *Arg3:* crNode33 (Cursor)  \n *Arg4:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "Tools.Measure.Volume": {
        prefix: "Volume",
        text: "*Name:* Tools.Measure.Volume  \n*Desc:* measure volume of parts  \n *Arg1:* crlPart (Cursor List)  \n *Arg2:* iPrecision (Integer)  \n *Return:* 1 if successed, or 0 if failed  \n ",
    },
    "JPT.RemoveEntitiesByID": {
        prefix: "RemoveEntitiesByID",
        text: '*Function:* JPT.RemoveEntitiesByID  \n*Description:* remove entities from model by id  \n *Input1:* DItem type (JPT.EntityType)  \n *Input2:* id of entity (int)  \n *Return:* None  \n *Example:*   \n listbody = JPT.GetEntitiesByName(JPT.DTableType.DTABLE_BODY, "Cube", JPT.BoolType.FALSE_VAL)  \n idbody = listbody[0].id  \n JPT.RemoveEntitiesByID(JPT.EntityType.BODY, idbody)  \n ',
    },
    "JPT.RemoveEntitiesByName": {
        prefix: "RemoveEntitiesByName",
        text: '*Function:* JPT.RemoveEntitiesByName  \n*Description:* remove entities from model by name  \n *Input1:* DTable type (JPT.DTableType)  \n *Input2:* name of entity (string)  \n *Input3:* match with name option (1,0 or JPT.BoolType)  \n *Return:* None  \n *Example:* JPT.RemoveEntitiesByName(JPT.DTableType.DTABLE_BODY, "Cube_1", 1)  \n ',
    },
    "JPT.RemoveAllLoadsBCs": {
        prefix: "RemoveAllLoadsBCs",
        text: "*Function:* JPT.RemoveAllLoadsBCs  \n*Description:* Remove all Loads and Boundary Condition in model  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllLoadsBCs ()  \n ",
    },
    "JPT.RemoveAllContacts": {
        prefix: "RemoveAllContacts",
        text: "*Function:* JPT.RemoveAllContacts  \n*Description:* Remove all of Contact in models  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllContacts()  \n ",
    },
    "JPT.RemoveAllConnections": {
        prefix: "RemoveAllConnections",
        text: "*Function:* JPT.RemoveAllConnections  \n*Description:* Remove all of Connection in models  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllConnections()  \n ",
    },
    "JPT.RemoveAllLoadCases": {
        prefix: "RemoveAllLoadCases",
        text: "*Function:* JPT.RemoveAllLoadCases  \n*Description:* Remove all load cases in models  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllLoadCases()  \n ",
    },
    "JPT.RemoveAllMaterials": {
        prefix: "RemoveAllMaterials",
        text: "*Function:* JPT.RemoveAllMaterials  \n*Description:* Remove all of Material in User Data Base  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllMaterials()  \n ",
    },
    "JPT.RemoveWSProperties": {
        prefix: "RemoveWSProperties",
        text: "*Function:* JPT.RemoveWSProperties  \n*Description:* Remove all properties in models  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveWSProperties()  \n ",
    },
    "JPT.RemoveAllCoordinates": {
        prefix: "RemoveAllCoordinates",
        text: "*Function:* JPT.RemoveAllCoordinates  \n*Description:* Remove all of created coordinates  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllCoordinates()  \n ",
    },
    "JPT.RemoveAllMeshSettings": {
        prefix: "RemoveAllMeshSettings",
        text: "*Function:* JPT.RemoveAllMeshSettings  \n*Description:* Remove all local mesh settings  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllMeshSettings()  \n ",
    },
    "JPT.RemoveAllFieldTables": {
        prefix: "RemoveAllFieldTables",
        text: "*Function:* JPT.RemoveAllFieldTables  \n*Description:* Remove all of Field Data table in models  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllFieldTables()  \n ",
    },
    "JPT.RemoveAllAbaqusStep": {
        prefix: "RemoveAllAbaqusStep",
        text: "*Function:* JPT.RemoveAllAbaqusStep  \n*Description:* Remove all of Abaqus steps in Analysis  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllAbaqusStep()  \n ",
    },
    "JPT.RemoveAllSolverjob": {
        prefix: "RemoveAllSolverjob",
        text: "*Function:* JPT.RemoveAllSolverjob  \n*Description:* Remove all analysis Jobs  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.RemoveAllSolverjob()  \n ",
    },
    "JPT.RemoveAllByTableType": {
        prefix: "RemoveAllByTableType",
        text: "*Function:* JPT.RemoveAllByTableType  \n*Description:* remove all entities in models by table type   \n *Input1:* DTable type (JPT.DTableType)  \n *Return:* None  \n *Example:* JPT.RemoveAllByTableType(JPT.DTableType.DTABLE_BODY)  \n ",
    },
    "JPT.CreateSubAssembly": {
        prefix: "CreateSubAssembly",
        text: '*Function:* JPT.CreateSubAssembly  \n*Description:* Create a sub node under parent on assembly tree with name  \n *Input1:* name of sub node (string)  \n *Input2:* parent object (DItem class)  \n *Return:* new sub node object (DItem class)  \n *Example:* JPT.CreateSubAssembly("LocalSetting_1", parentObject)  \n ',
    },
    "JPT.DeleteSubAssembly": {
        prefix: "DeleteSubAssembly",
        text: "*Function:* JPT.DeleteSubAssembly  \n*Description:* Delete a sub node from assembly tree  \n *Input1:* sub node object (DItem class)  \n *Return:* None  \n *Example:* JPT.DeleteSubAssembly(dentityObject)  \n ",
    },
    "JPT.FindSubAssemblyByName": {
        prefix: "FindSubAssemblyByName",
        text: '*Function:* JPT.FindSubAssemblyByName  \n*Description:* Find a sub node from assembly tree by name  \n *Input1:* name of sub node (string)  \n *Return:* list DItem object matched with input name (DItemVector)  \n *Example:* JPT.FindSubAssemblyByName("LocalSetting_1")  \n ',
    },
    "JPT.FindSubAssemblyByID": {
        prefix: "FindSubAssemblyByID",
        text: "*Function:* JPT.FindSubAssemblyByID  \n*Description:* Find a sub node from assembly tree by id  \n *Input1:* id of entity sub node (int)   \n *Return:* sub node object matched with input id (DItem)   \n *Example:* JPT.FindSubAssemblyByID(1)  \n ",
    },
    "JPT.DeleteSubAssemblyRecursively": {
        prefix: "DeleteSubAssemblyRecursively",
        text: "*Function:* JPT.DeleteSubAssemblyRecursively  \n*Description:* Delete a sub node and all childs from assembly tree  \n *Input1:* sub node object (DItem class)  \n *Return:* None  \n *Example:* JPT.DeleteSubAssemblyRecursively(dentityObject)  \n ",
    },
    "JPT.GetAllPartsInSubAssembly": {
        prefix: "GetAllPartsInSubAssembly",
        text: "*Function:* JPT.GetAllPartsInSubAssembly  \n*Description:* get all parts in a sub node from assembly tree  \n *Input1:* sub node object (DItem class)  \n *Return:* list of DItem object matched with input name (DItemVector)  \n *Example:* JPT.GetAllPartsInSubAssembly(DItem)   \n ",
    },
    "JPT.CastToDItem": {
        prefix: "CastToDItem",
        text: "*Function:* JPT.CastToDItem  \n*Description:* cast a child object to entity object  \n *Input1:* any kind of objects (Body, Face, Elem, Edge, Group, Node,...)  \n *Return:* entity object (DItem class)  \n *Example:*   \n listDbodyObject = JPT.GetAllParts()   \n bodyObject = listDbodyObject[0]  \n entityObject = JPT.CastToDItem(dbodyObject)  \n ",
    },
    "JPT.CastDItemToDBody": {
        prefix: "CastDItemToDBody",
        text: "*Function:* JPT.CastDItemToDBody  \n*Description:* cast a DItem object to Body object  \n *Input1:* DItem object (DItem class)  \n *Return:* Body object (Body class)  \n *Example:*   \n listEntityObject = JPT.GetAllByType(JPT.EntityType.BODY)  \n entityObject = listEntityObject[0]  \n bodyObject = JPT.CastDItemToDBody(dentityObject)  \n ",
    },
    "JPT.CastDItemToDFace": {
        prefix: "CastDItemToDFace",
        text: "*Function:* JPT.CastDItemToDFace  \n*Description:* cast a DItem object to Face object  \n *Input1:* DItem object (DItem class)  \n *Return:* Face object (Face class)  \n *Example:*   \n listEntityObject = JPT.GetAllByType(JPT.EntityType.FACE)  \n entityObject = listEntityObject[0]  \n faceObject = JPT.CastDItemToDFace(dentityObject)  \n ",
    },
    "JPT.CastDItemToDElem": {
        prefix: "CastDItemToDElem",
        text: "*Function:* JPT.CastDItemToDElem  \n*Description:* cast a DItem object to Elem object  \n *Input1:* DItem object (DItem class)  \n *Return:* Elem object (Elem class)  \n *Example:*   \n listEntityObject = JPT.GetAllByType(JPT.EntityType.ELEM)  \n entityObject = listEntityObject[0]  \n elemObject = JPT.CastDItemToDElem(dentityObject)  \n ",
    },
    "JPT.CastDItemToDEdge": {
        prefix: "CastDItemToDEdge",
        text: "*Function:* JPT.CastDItemToDEdge  \n*Description:* cast a DItem object to Edge object  \n *Input1:* DItem object (DItem class)  \n *Return:* Edge object (Edge class)  \n *Example:*   \n listEntityObject = JPT.GetAllByType(JPT.EntityType.EDGE)  \n entityObject = listEntityObject[0]  \n edgeObject = JPT.CastDItemToDEdge(dentityObject)  \n ",
    },
    "JPT.CastDItemToDGroup": {
        prefix: "CastDItemToDGroup",
        text: "*Function:* JPT.CastDItemToDGroup  \n*Description:* cast a DItem object to Group object  \n *Input1:* DItem object (DItem class)  \n *Return:* Group object (Group class)  \n *Example:*   \n listEntityObject = JPT.GetAllByType(JPT.EntityType.GROUP)  \n entityObject = listEntityObject[0]  \n groupObject = JPT.CastDItemToDGroup(dentityObject)  \n ",
    },
    "JPT.CastDItemToDNode": {
        prefix: "CastDItemToDNode",
        text: "*Function:* JPT.CastDItemToDNode  \n*Description:* cast a DItem object to Node object  \n *Input1:* DItem object (DItem class)  \n *Return:* Node object (Node class)  \n *Example:*   \n listEntityObject = JPT.GetAllByType(JPT.EntityType.NODE)  \n entityObject = listEntityObject[0]  \n nodeObject = JPT.CastDItemToDNode(dentityObject)  \n ",
    },
    "JPT.CastDItemToDCoord": {
        prefix: "CastDItemToDCoord",
        text: "*Function:* JPT.CastDItemToDCoord  \n*Description:* cast a DItem object to Coordinate object  \n *Input1:* DItem object (DItem class)  \n *Return:* Coordinate object (DCoord class)  \n *Example:*   \n listEntityObject = JPT.GetAllByType(JPT.EntityType.COORD)  \n entityObject = listEntityObject[0]  \n coordObject = JPT.CastDItemToDCoord(dentityObject)  \n ",
    },
    "JPT.CastDItemToDConnect": {
        prefix: "CastDItemToDConnect",
        text: "*Function:* JPT.CastDItemToDConnect  \n*Description:* cast a DItem object to Connection object  \n *Input1:* DItem object (DItem class)  \n *Return:* DConnect object (DConnect class)  \n *Example:*   \n listEntityObject = JPT.GetAllByType(JPT.EntityType.CONNECT_MPC)  \n entityObject = listEntityObject[0]  \n connectObject= JPT.CastDItemToDConnect(dentityObject)  \n ",
    },
    "JPT.CastDItemToDLoadBC": {
        prefix: "CastDItemToDLoadBC",
        text: "*Function:* JPT.CastDItemToDLoadBC  \n*Description:* cast a DItem object to LBC object  \n *Input1:* DItem object (DItem class)  \n *Return:* LBC object (DLoadBC class)  \n *Example:*   \n listEntityObject = JPT.GetAllByType(JPT.EntityType.LBC_FORCE)  \n entityObject = listEntityObject[0]  \n lbcObject = JPT.CastDItemToDLoadBC(dentityObject)  \n ",
    },
    "JPT.DItemToMacroTCursorPair": {
        prefix: "DItemToMacroTCursorPair",
        text: "*Function:* JPT.DItemToMacroTCursorPair  \n*Description:* convert pair of DItem object to cursor pair macro string    \n *Input1:* DItem object 1 (DItem class)  \n *Input2:* DItem object 2 (DItem class)  \n *Return:* cursor pair macro string (string)  \n *Example:*   \n listNodeObject = JPT.GetAllNodes()  \n entityObject1 = JPT.CastToDItem(listNodeObject[0])  \n entityObject2 = JPT.CastToDItem(listNodeObject[1])  \n *strElemEdge = JPT.DItemToMacroTCursorPair(dentityObject1, dentityObject2) // 10:1-10:*2  \n ",
    },
    "JPT.ListDoubleToMacroVector": {
        prefix: "ListDoubleToMacroVector",
        text: "*Function:* JPT.ListDoubleToMacroVector  \n*Description:* convert list of double value to vector3d macro string    \n *Input1:* value1 (double)   \n *Input2:* value2 (double)   \n *Input2:* value3 (double)   \n *Return:* vector3d macro string (string)   \n *Example:*   \n JPT.ListDoubleToMacroVector(1.0, 1.0, 1.0) // [1.0,1.0,1.0]  \n JPT.ListDoubleToMacroVector(1, 2, 3) // [1,2,3]  \n ",
    },
    "JPT.DTVector3dToMacroVector": {
        prefix: "DTVector3dToMacroVector",
        text: "*Function:* JPT.DTVector3dToMacroVector  \n*Description:* convert Vector3d object to vector3d macro string   \n *Input1:* Vector3d object (DTVector3d class)  \n *Return:* vector3d macro string (string)   \n *Example:*   \n listNodeObject = JPT.GetAllNodes()  \n posNode1 = listNodeObject[0].pos  \n JPT.DTVector3dToMacroVector(posNode1)  \n ",
    },
    "JPT.DItemToMacroTCursor": {
        prefix: "DItemToMacroTCursor",
        text: "*Function:* JPT.DItemToMacroTCursor  \n*Description:* convert a DItem object to cursor macro string   \n *Input1:* DItem object (DItem class)  \n *Return:* cursor macro string (string)  \n *Example:*   \n listnode1 = JPT.GetEntitiesByID(JPT.EntityType.NODE, 435)  \n listnode2 = JPT.GetEntitiesByID(JPT.EntityType.NODE, 434)  \n *node1 = JPT.DItemToMacroTCursor(listnode1[0]) // 10:*1  \n *node2 = JPT.DItemToMacroTCursor(listnode2[0]) // 10:*2  \n JPT.Exec('Collapse({0}, {1})'.format(node1, node2))  \n ",
    },
    "JPT.DItemListToMacroListTCursor": {
        prefix: "DItemListToMacroListTCursor",
        text: "*Function:* JPT.DItemListToMacroListTCursor  \n*Description:* convert list of DItem objects to cursor list macro string   \n *Input1:* list of DItem objects (DItemVector)   \n *Return:* cursor list macro string (string)    \n *Example:*   \n listface1 = JPT.GetAllFaces()  \n *JPT.DItemListToMacroListTCursor(listface1) // [10:1, 10:*1, ...]  \n ",
    },
    "JPT.DItemToMacroListTCursor": {
        prefix: "DItemToMacroListTCursor",
        text: "*Function:* JPT.DItemToMacroListTCursor  \n*Description:* convert a DItem object to cursor list macro string   \n *Input1:* DItem objects (DItem class)  \n *Return:* cursor list macro string (string)    \n *Example:*   \n listnode = JPT.GetEntitiesByID(JPT.EntityType.NODE, 434)  \n *node = JPT.DItemToMacroTCursor(listnode[0]) // 10:*1  \n *JPT.DItemToMacroListTCursor(node) [10:*1]  \n ",
    },
    "JPT.MacroResultParser": {
        prefix: "MacroResultParser",
        text: '*Function:* JPT.MacroResultParser  \n*Description:* parse returned string from macro to list of string  \n *Input1:* returned string from macro (string)    \n *Input2:* list of string pattern (string, cursor, cursor_pair, list_number  \n list_cursor_pair, list_cursor, list_list_cursor, list_string, vector3d, number)   \n *Return:* list of result (list string)    \n *Example:*   \n *result = JPT.Exec(\'MC_Mesh_Quality_Manual_Check_Tri([3:*1], 0, 0, 0.1)\')  \n *# result = 1, [6:100, 6:*101]  \n listString = JPT.MacroResultParser(result, ["number", "list_cursor"])   \n ',
    },
    "JPT.MacroListTCursorToListDItem": {
        prefix: "MacroListTCursorToListDItem",
        text: "*Function:* JPT.MacroListTCursorToListDItem  \n*Description:* convert a macro cursor list string to list of DItem objects  \n *Input1:* macro cursor list string (string)  \n *Return:* list of DItem objects (DItemVector)  \n *Example: listEntityObject = JPT.MacroListTCursorToListDItem('[10:1, 10:*1, ...]')  \n ",
    },
    "JPT.MacroTCursorToDItem": {
        prefix: "MacroTCursorToDItem",
        text: "*Function:* JPT.MacroTCursorToDItem  \n*Description:* convert a macro cursor string to DItem object  \n *Input1:* macro cursor string (string)  \n *Return:* DItem object (DItem class)  \n *Example: dentityObject = JPT.MacroTCursorToDItem('3:*1')  \n ",
    },
    "JPT.ConvertRGBToJPTColor": {
        prefix: "ConvertRGBToJPTColor",
        text: '*Function:* JPT.ConvertRGBToJPTColor  \n*Description:* convert a RGB (red,green,blue) value to JPT color number  \n *Input1:* RGB (red,green,blue)  \n *Return:* JPT color number (int)  \n *Example:*   \n newcolor = JPT.ConvertRGBToJPTColor(255,0,0) # red color  \n listbody = JPT.GetEntitiesByName(JPT.DTableType.DTABLE_BODY, "Cube_1", 1)  \n JPT.CastDItemToDBody(listbody[0]).color = newcolor  \n ',
    },
    "JPT.CopyToClipBoard": {
        prefix: "CopyToClipBoard",
        text: "*Function:* JPT.CopyToClipBoard  \n*Description:* put a text to clipboard buffer   \n *Input1:* text input (string)  \n *Return:* None  \n *Example:* JPT.CopyToClipBoard(text)  \n ",
    },
    "JPT.CheckLicense": {
        prefix: "CheckLicense",
        text: '*Function:* JPT.CheckLicense  \n*Description:* Check feature license whether active or not  \n *Input1:* License name(string)  \n *        Jupiter feature license:* Home > Preference > License  \n *Return:* True / False  \n *Example:* JPT.CheckLicense("JPT_BASE")  \n ',
    },
    "JPT.IsDefaultDouble": {
        prefix: "IsDefaultDouble",
        text: "*Function:* JPT.IsDefaultDouble  \n*Description:* check a double value is Default value or not   \n *Input1:* value (double)   \n *Return:* True / False  \n *Example:* JPT.IsDefaultDouble(value)  \n ",
    },
    "JPT.IsDefaultInt": {
        prefix: "IsDefaultInt",
        text: "*Function:* JPT.IsDefaultInt  \n*Description:* check a int value is Default value or not   \n *Input1:* value (int)   \n *Return:* True / False  \n *Example:* JPT.IsDefaultInt(value)  \n ",
    },
    "JPT.ConvertFromDocUnit": {
        prefix: "ConvertFromDocUnit",
        text: "*Function:* JPT.ConvertFromDocUnit  \n*Description:* Convert value from JPT user setup unit to SI unit system  \n *Input1:* Conversion source value (double)  \n *Input2:* Unit system conversion type (JPT.UnitType)  \n *Return:* Converted Value (double)  \n *Example:* JPT.ConvertFromDocUnit(1, JPT.UnitType.Unit_Length)  \n ",
    },
    "JPT.ConvertValueToDocUnit": {
        prefix: "ConvertValueToDocUnit",
        text: "*Function:* JPT.ConvertValueToDocUnit  \n*Description:* Convert value from SI unit system to JPT user setup unit  \n *Input1:* Conversion source value (double)  \n *Input2:* Unit system conversion type (JPT.UnitType)  \n *Return:* Converted value (double)  \n *Example:* JPT.ConvertValueToDocUnit(1, JPT.UnitType.Unit_Length)  \n ",
    },
    "JPT.ConvertFromMacroUnit": {
        prefix: "ConvertFromMacroUnit",
        text: "*Function:* JPT.ConvertFromMacroUnit  \n*Description:* Convert unit system from user input unit to macro SI unit  \n *Input1:* Conversion source value (double)  \n *Input2:* Unit system conversion type (JPT.UnitType)  \n *Input3:* Unit abbreviation (string)  \n *Return:* Converted value (double)  \n *Example:* JPT.ConvertFromMacroUnit(1, JPT.UnitType.Unit_Length, 'mm')  \n ",
    },
    "JPT.ConvertValueToMacroUnit": {
        prefix: "ConvertValueToMacroUnit",
        text: "*Function:* JPT.ConvertValueToMacroUnit  \n*Description:* Convert unit system from macro SI unit to user input unit  \n *Input1:* Conversion source value (double)  \n *Input2:* Unit system conversion type (JPT.UnitType)  \n *Input3:* Unit abbreviation (string)  \n *Return:* Converted value(double)  \n *Example:* convToMacr = JPT.ConvertValueToMacroUnit(1, JPT.UnitType.Unit_Length, 'mm')  \n ",
    },
    "JPT.GetJPTTempPath": {
        prefix: "GetJPTTempPath",
        text: "*Function:* JPT.GetJPTTempPath  \n*Description:* Get temp document path  \n *Input1:* None  \n *Return:* Temp Document Path(string)  \n *Example:* JPT.GetJPTTempPath()  \n ",
    },
    "JPT.GetProgramPath": {
        prefix: "GetProgramPath",
        text: "*Function:* JPT.GetProgramPath  \n*Description:* Get application installation directory  \n *Input1:* None  \n *Return:* Program Path(string)  \n *Example:* JPT.GetProgramPath()  \n ",
    },
    "JPT.GetCurrentDocumentPath": {
        prefix: "GetCurrentDocumentPath",
        text: "*Function:* JPT.GetCurrentDocumentPath  \n*Description:* Get current document path  \n *Input1:* None  \n *Return:* Current Document Path(string)  \n *Example:* JPT.GetCurrentDocumentPath()  \n ",
    },
    "JPT.QuitApplication": {
        prefix: "QuitApplication",
        text: "*Function:* JPT.QuitApplication  \n*Description:* quit jupiter  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.QuitApplication()  \n ",
    },
    "JPT.GetAppPathInfo": {
        prefix: "GetAppPathInfo",
        text: "*Function:* JPT.GetAppPathInfo  \n*Description:* get a JPT path string (Program, Temp, Appdata, Document)  \n *Input1:* Path type (JPT.PathType)  \n *Return:* path (string)  \n *Example:* JPT.GetAppPathInfo()  \n ",
    },
    "JPT.GetSelectedNodes": {
        prefix: "GetSelectedNodes",
        text: "*Function:* JPT.GetSelectedNodes  \n*Description:* Get selected node information  \n *Input1:* None  \n *Return:* list of DNode objects contain selected node information (NodeVector)  \n *Example:* JPT.GetSelectedNodes()  \n ",
    },
    "JPT.GetSelectedElems": {
        prefix: "GetSelectedElems",
        text: "*Function:* JPT.GetSelectedElems  \n*Description:* Get selected element information  \n *Input1:* None  \n *Return:* list of DElem objects contain selected element information (ElemVector)  \n *Example:* JPT.GetSelectedElems()  \n ",
    },
    "JPT.GetSelectedFaces": {
        prefix: "GetSelectedFaces",
        text: "*Function:* JPT.GetSelectedFaces  \n*Description:* Get selected face information  \n *Input1:* None  \n *Return:* list of DFace objects contain selected face information (FaceVector)  \n *Example:* JPT.GetSelectedFaces()  \n ",
    },
    "JPT.GetSelectedEdges": {
        prefix: "GetSelectedEdges",
        text: "*Function:* JPT.GetSelectedEdges  \n*Description:* Get all of selected edge information  \n *Input1:* None  \n *Return:* list of DEdge objects contain selected edge information (EdgeVector)  \n *Example:* JPT.GetSelectedEdges()  \n ",
    },
    "JPT.GetSelectedParts": {
        prefix: "GetSelectedParts",
        text: "*Function:* JPT.GetSelectedParts  \n*Description:* Get selected part information  \n *Input1:* None  \n *Return:* list of DBody objects contain selected part information (BodyVector)  \n *Example:* JPT.GetSelectedParts()  \n ",
    },
    "JPT.GetSelectedGroups": {
        prefix: "GetSelectedGroups",
        text: "*Function:* JPT.GetSelectedGroups  \n*Description:* Get selected group information   \n *Input1:* None  \n *Return:* list of DGroup objects contain selected group information (GroupVector)  \n *Example:* JPT.GetSelectedGroups()  \n ",
    },
    "JPT.GetAllParts": {
        prefix: "GetAllParts",
        text: "*Function:* JPT.GetAllParts  \n*Description:* Get information of all parts  \n *Input1:* None  \n *Return:* list of DBody objects contain part information (BodyVector)  \n *Example:* JPT.GetAllParts()  \n ",
    },
    "JPT.GetAllFaces": {
        prefix: "GetAllFaces",
        text: "*Function:* JPT.GetAllFaces  \n*Description:* Get information of faces  \n *Input1:* None  \n *Return:* list of DFace objects contain face information (FaceVector)  \n *Example:* JPT.GetAllFaces()  \n ",
    },
    "JPT.GetAllEdges": {
        prefix: "GetAllEdges",
        text: "*Function:* JPT.GetAllEdges  \n*Description:* Get information of edges  \n *Input1:* None  \n *Return:* list of DEdge objects contain edge information (EdgeVector)  \n *Example:* JPT.GetAllEdges()  \n ",
    },
    "JPT.GetAllElems": {
        prefix: "GetAllElems",
        text: "*Function:* JPT.GetAllElems  \n*Description:* Get information of elements  \n *Input1:* None  \n *Return:* list of DNode objects contain element information (NodeVector)  \n *Example:* JPT.GetAllElems()  \n ",
    },
    "JPT.GetAllNodes": {
        prefix: "GetAllNodes",
        text: "*Function:* JPT.GetAllNodes  \n*Description:* Get information of all nodes  \n *Input1:* None  \n *Return:* list of DNode objects contain node information (NodeVector)  \n *Example:* JPT.GetAllNodes()  \n ",
    },
    "JPT.GetAllGroups": {
        prefix: "GetAllGroups",
        text: "*Function:* JPT.GetAllGroups  \n*Description:* Get all entities' information inside groups  \n *Input1:* None  \n *Return:* list of DGroup objects contain group information (GroupVector)  \n *Example:* JPT.GetAllGroups()  \n ",
    },
    "JPT.GetAllByTableTypeID": {
        prefix: "GetAllByTableTypeID",
        text: "*Function:* JPT.GetAllByTableTypeID  \n*Description:* Get the information about indicated entity by type ID  \n *Input1:* DTable type ID input(JPT.DTableType)  \n *Return:* Type ID(DItem)   \n *Example:* JPT.GetAllByTableTypeID(3)  \n ",
    },
    "JPT.GetAllByType": {
        prefix: "GetAllByType",
        text: "*Function:* JPT.GetAllByType  \n*Description:* Get entities information by inputting their DItem type  \n *Input1:* DItem type input (JPT.EntityType)  \n *Return:* DItem information (DItem)   \n *Example:* JPT.GetAllByType(JPT.EntityType.INST)  \n ",
    },
    "JPT.GetCountByType": {
        prefix: "GetCountByType",
        text: "*Function:* JPT.GetCountByType  \n*Description:* Get count of entities by type  \n *Input1: DItem Type:* BODY, VERTEX, EDGE, FACE, SOLID, ELEM,...(JPT.EntityType)  \n *Return:* Number of entities(int)  \n *Example:* JPT.GetCountByType(JPT.EntityType.BODY)  \n ",
    },
    "JPT.GetAllSelected": {
        prefix: "GetAllSelected",
        text: "*Function:* JPT.GetAllSelected  \n*Description:* Get entity information from the selected entity (Connections, Contacts, Parts, ...)  \n *Input1:* None  \n *Return:* list of DItem objects contain selected entity information (DItem)   \n *Example:* JPT.GetAllSelected()  \n ",
    },
    "JPT.GetLastCreatedCursor": {
        prefix: "GetLastCreatedCursor",
        text: "*Function:* JPT.GetLastCreatedCursor  \n*Description:* Get the latest id of created entity  \n *Input1:* None  \n *Return:* Last created Object(DItem)   \n *Example:* JPT.GetLastCreatedCursor()  \n ",
    },
    "JPT.GetCenterOfEntities": {
        prefix: "GetCenterOfEntities",
        text: "*Function:* JPT.GetCenterOfEntities  \n*Description:* Get center coordinate of selected entities  \n *Input1:* list of DItem object (DItemVector)  \n *Return:* Coordinate[x,y,z] of selected entities(double)  \n *Example:* JPT.GetCenterOfEntities(entity)  \n ",
    },
    "JPT.GetSharedFaces": {
        prefix: "GetSharedFaces",
        text: "*Function:* JPT.GetSharedFaces  \n*Description:* Get shared face information  \n *Input1:* list of DItem object (DItemVector)  \n *Return:* Shared face information (typeID, id, key)(DItem)   \n *Example:* JPT.GetSharedFaces(shareFace)  \n ",
    },
    "JPT.GetSharedElements": {
        prefix: "GetSharedElements",
        text: "*Function:* JPT.GetSharedElements  \n*Description:* Get shared element information  \n *Input1:* ist of DItem object (DItemVector)  \n *Return:* Shared element information (type, typeID, id, info, key, masters, slave, targets, children, parent)(DItem)   \n *Example:* JPT.GetSharedElements(bodies)  \n ",
    },
    "JPT.GetSharedNodes": {
        prefix: "GetSharedNodes",
        text: "*Function:* JPT.GetSharedNodes  \n*Description:* Get shared node information  \n *Input1:* ist of DItem object (DItemVector)  \n *Return:* Shared node information (typeID, id, key)(DItem)   \n *Example:* JPT.GetSharedNodes(shareNodes)  \n ",
    },
    "JPT.GetAllLoadsBCs": {
        prefix: "GetAllLoadsBCs",
        text: "*Function:* JPT.GetAllLoadsBCs  \n*Description:* Get information of all loads and BCs  \n *Input1:* None  \n *Return:* Load information (type, type ID, id, key, name, info, targets, isValid, masters, slaves, parent, children)(DItem)   \n *Example:* JPT.GetAllLoadsBCs()  \n ",
    },
    "JPT.GetSelectedNodesCr": {
        prefix: "GetSelectedNodesCr",
        text: "*Function:* JPT.GetSelectedNodesCr  \n*Description:* get selected node as string output  \n *Input1:* None  \n *Return:* selected node (string)  \n *Example:* JPT.GetSelectedNodesCr()  \n ",
    },
    "JPT.GetSelectedElemsCr": {
        prefix: "GetSelectedElemsCr",
        text: "*Function:* JPT.GetSelectedElemsCr  \n*Description:* get selected element as string output  \n *Input1:* None  \n *Return:* selected element (string)  \n *Example:* JPT.GetSelectedElemsCr()  \n ",
    },
    "JPT.GetSelectedFacesCr": {
        prefix: "GetSelectedFacesCr",
        text: "*Function:* JPT.GetSelectedFacesCr  \n*Description:* get selected face as string output  \n *Input1:* None  \n *Return:* selected face (string)  \n *Example:* JPT.GetSelectedFacesCr()  \n ",
    },
    "JPT.GetSelectedEdgesCr": {
        prefix: "GetSelectedEdgesCr",
        text: "*Function:* JPT.GetSelectedEdgesCr  \n*Description:* get selected edge as string output  \n *Input1:* None  \n *Return:* selected edge (string)  \n *Example:* JPT.GetSelectedEdgesCr()  \n ",
    },
    "JPT.GetSelectedPartsCr": {
        prefix: "GetSelectedPartsCr",
        text: "*Function:* JPT.GetSelectedPartsCr  \n*Description:* get selected part as string output  \n *Input1:* None  \n *Return:* selected part (string)  \n *Example:* JPT.GetSelectedPartsCr()  \n ",
    },
    "JPT.GetSelectedGroupsCr": {
        prefix: "GetSelectedGroupsCr",
        text: "*Function:* JPT.GetSelectedGroupsCr  \n*Description:* get selected group as string output  \n *Input1:* None  \n *Return:* selected group (string)  \n *Example:* JPT.GetSelectedGroupsCr()  \n ",
    },
    "JPT.GetUndoCount": {
        prefix: "GetUndoCount",
        text: "*Function:* JPT.GetUndoCount  \n*Description:* Get number of undo action which is capable of running  \n *Input1:* None  \n *Return:* Number of undo action(int)  \n *Example:* JPT.GetUndoCount()  \n ",
    },
    "JPT.ClearUndo": {
        prefix: "ClearUndo",
        text: "*Function:* JPT.ClearUndo  \n*Description:* Clear Undo list  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.ClearUndo()  \n ",
    },
    "JPT.GetRedoCount": {
        prefix: "GetRedoCount",
        text: "*Function:* JPT.GetRedoCount  \n*Description:* Get number of redo action which is capable of running  \n *Input1:* None  \n *Return:* Number of redo action(int)  \n *Example:* JPT.GetRedoCount()  \n ",
    },
    "JPT.ClearRedo": {
        prefix: "ClearRedo",
        text: "*Function:* JPT.ClearRedo  \n*Description:* Clear Redo list  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.ClearRedo()  \n ",
    },
    "JPT.GetOpnList": {
        prefix: "GetOpnList",
        text: "*Function:* JPT.GetOpnList  \n*Description:* Get list of Launch Operation  \n *Input1:* None  \n *Return:* List of Launch Operation(string)  \n *Example:* JPT.GetOpnList()  \n ",
    },
    "JPT.GetMacroLog": {
        prefix: "GetMacroLog",
        text: "*Function:* JPT.GetMacroLog  \n*Description:* Get all of the macro in Macro Window  \n *Input1:* None  \n *Return:* List of previous Macro in Macro Window (list string)  \n *Example:* JPT.GetMacroLog()  \n ",
    },
    "JPT.GetPythonAPILog": {
        prefix: "GetPythonAPILog",
        text: "*Function:* JPT.GetPythonAPILog  \n*Description:* Get log string from python API window  \n *Input1:* None  \n *Return:* List of messages from python API window (list string)  \n *Example:* JPT.GetPythonAPILog()  \n ",
    },
    "JPT.ShowHideEntitiesByID": {
        prefix: "ShowHideEntitiesByID",
        text: "*Function:* JPT.ShowHideEntitiesByID  \n*Description:* show or hide an entity by id in view  \n *Input1:* DTable type (JPT.DTableType)  \n *Input2:* entity id (int)  \n *Input3:* show/hide option (1,0 or JPT.BoolType)  \n *Return:* None  \n *Example:*   \n // hide a part  \n JPT.ShowHideEntitiesByID(JPT.DTableType.DTABLE_BODY, 1, JPT.BoolType.TRUE_VAL)  \n // show a part  \n JPT.ShowHideEntitiesByID(JPT.DTableType.DTABLE_BODY, 1, JPT.BoolType.FALSE_VAL)  \n ",
    },
    "JPT.ShowHideAllParts": {
        prefix: "ShowHideAllParts",
        text: "*Function:* JPT.ShowHideAllParts  \n*Description:* show or hide all parts in view  \n *Input1:* show/hide option (1,0 or JPT.BoolType)  \n *Return:* None  \n *Example:*   \n // show all parts  \n JPT.ShowHideAllParts(JPT.BoolType.TRUE_VAL)  \n // hide all parts  \n JPT.ShowHideAllParts(JPT.BoolType.FALSE_VAL)  \n ",
    },
    "JPT.InverseHideBodies": {
        prefix: "InverseHideBodies",
        text: '*Function:* JPT.InverseHideBodies  \n*Description:* inverse hide parts in view  \n *Input1:* id of part (int)  \n *Return:* None  \n *Example:*   \n listbody = JPT.GetEntitiesByName(JPT.DTableType.DTABLE_BODY, "Cube1", 1)  \n idbody = listbody[0].id  \n JPT.InverseHideBodies(idbody)  \n ',
    },
    "JPT.ViewFitToModel": {
        prefix: "ViewFitToModel",
        text: "*Function:* JPT.ViewFitToModel  \n*Description:* fit models to current view  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.ViewFitToModel()  \n ",
    },
    "JPT.Exec": {
        prefix: "Exec",
        text: "*Function:* JPT.Exec  \n*Description:* Run Jupiter macro  \n *Input1:* Macro command (string)  \n *Return:* Refer each macro command(string)  \n *Example: JPT.Exec('CreateCube([0, 0, 0], [0.01, 0.01, 0.01], [10, 10, 10], \"Cube_1\", 7105764, 0:*0) ')  \n ",
    },
    "JPT.GetMaxIDEntity": {
        prefix: "GetMaxIDEntity",
        text: "*Function:* JPT.GetMaxIDEntity  \n*Description:* get max id entity from DItem type  \n *Input1:* DItem type (JPT.EntityType)  \n *Return:* max id entity (int)   \n *Example:* JPT.GetMaxIDEntity(JPT.EntityType.BODY)  \n ",
    },
    "JPT.GetMinIDEntity": {
        prefix: "GetMinIDEntity",
        text: "*Function:* JPT.GetMinIDEntity  \n*Description:* get min id entity from DItem type  \n *Input1:* DItem type (JPT.EntityType)  \n *Return:* min id entity (int)   \n *Example:* JPT.GetMinIDEntity(JPT.EntityType.BODY)  \n ",
    },
    "JPT.GetEntitiesByName": {
        prefix: "GetEntitiesByName",
        text: '*Function:* JPT.GetEntitiesByName  \n*Description:* get list of object entity by name  \n *Input1:* DTableType type (JPT.DTableType)  \n *Input2:* name of entity (string)  \n *Input3:* match with name option (1,0 or JPT.BoolType)  \n *Return:* list of object entity (DItemVector)  \n *Example:* listbody = JPT.GetEntitiesByName(JPT.DTableType.DTABLE_BODY, "Cube1", 1)  \n ',
    },
    "JPT.GetEntitiesByID": {
        prefix: "GetEntitiesByID",
        text: "*Function:* JPT.GetEntitiesByID  \n*Description:* get list of object entity by id  \n *Input1:* DItem type (JPT.EntityType)  \n *Input2:* id entity (int)   \n *Return:* list of object entity (DItemVector)  \n *Example:* listbody = JPT.GetEntitiesByID(JPT.EntityType.BODY, 1)  \n ",
    },
    "JPT.GetEntitiesByPosition": {
        prefix: "GetEntitiesByPosition",
        text: "*Function:* JPT.GetEntitiesByPosition  \n*Description:* get list of entity object by position  \n *Input1:* AssociateType type (JPT.AssociateType)  \n *Input2:* x (double)    \n *Input3:* y (double)   \n *Input4:* z (double)   \n *Return:* list of DItem object (DItemVector)  \n *Example:* JPT.GetEntitiesByPosition(JPT.AssociateType.AS_BODY, 1, 2, 3)  \n ",
    },
    "JPT.GetEntitiesByAssociation": {
        prefix: "GetEntitiesByAssociation",
        text: "*Function:* JPT.GetEntitiesByAssociation  \n*Description:* get list of entity object by association  \n *Input1:* DItem type of parent entity (JPT.EntityType)  \n *Input2:* AssociateType type (JPT.AssociateType)  \n *Input3:* id entity (int)   \n *Return:* list of DItem object (DItemVector)  \n *Example:* JPT.GetEntitiesByAssociation(JPT.EntityType.BODY, JPT.AssociateType.AS_FACE, 1)  \n ",
    },
    "JPT.GetEntitiesByAdjacent": {
        prefix: "GetEntitiesByAdjacent",
        text: "*Function:* JPT.GetEntitiesByAdjacent  \n*Description:* get list of entity object by adjacency  \n *Input1:* only DItem Face/Element type (JPT.EntityType)  \n *Input2:* id entity (int)    \n *Input3:* stop angle (int)  \n *Return:* list of DItem object (DItemVector)  \n *Example:* JPT.GetEntitiesByAdjacent(JPT.EntityType.FACE, 1, 30)  \n ",
    },
    "JPT.MsgOut": {
        prefix: "MsgOut",
        text: '*Function:* JPT.MsgOut  \n*Description:* print out message to Python API window (~ print())  \n *Input1:* message (string)  \n *Return:* None  \n *Example:* JPT.MsgOut("this is test message")  \n ',
    },
    "JPT.PrintAppPathInfo": {
        prefix: "PrintAppPathInfo",
        text: "*Function:* JPT.PrintAppPathInfo  \n*Description:* print all JPT path information (Program, Temp, Appdata, Document)  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.PrintAppPathInfo()  \n ",
    },
    "JPT.PrintPSJUtilityManual": {
        prefix: "PrintPSJUtilityManual",
        text: "*Function:* JPT.PrintPSJUtilityManual  \n*Description:* Print PSJ Utility Manual Information  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.PrintPSJUtilityManual()  \n ",
    },
    "JPT.Debugger": {
        prefix: "Debugger",
        text: '*Function:* JPT.Debugger  \n*Description:* console debugger for PSJ   \n *Input1:* any type, any argument number  \n *Return:* None  \n *Example:*   \n // debug enum type  \n JPT.Debugger(JPT.EntityType.values)   \n // debug python standard type  \n JPT.Debugger(1, "abcd", list, tuble, dict, ....)  \n // debug Jupiter data type  \n JPT.Debugger(JPT.GetAllNodes()[0].id)  \n JPT.Debugger(JPT.GetAllNodes()[0])  \n JPT.Debugger(JPT.GetAllNodes())  \n ',
    },
    "JPT.GetElemsByKind": {
        prefix: "GetElemsByKind",
        text: "*Function:* JPT.GetElemsByKind  \n*Description:* get list of element object by kind  \n *Input1:* element kind (JPT.ElemKind)  \n *Return:* list of Elem object (ElemVector)  \n *Example:* listElemObject = JPT.GetElemsByKind(JPT.ElemKind.ELEMKIND_2D)  \n ",
    },
    "JPT.GetRandomJPTColor": {
        prefix: "GetRandomJPTColor",
        text: "*Function:* JPT.GetRandomJPTColor  \n*Description:* get a random color   \n *Input1:* None  \n *Return:* random color number (int)  \n *Example:* color = JPT.GetRandomJPTColor()  \n ",
    },
    "JPT.ConvertJPTColorToRGB": {
        prefix: "ConvertJPTColorToRGB",
        text: "*Function:* JPT.ConvertJPTColorToRGB  \n*Description:* convert JPT color to string RGB (red, green, blue)  \n *Input1:* JPT color (int)  \n *Return:* string RGB (string)  \n *Example:* stringRGB = JPT.ConvertJPTColorToRGB(255)  \n ",
    },
    "JPT.ClearLog": {
        prefix: "ClearLog",
        text: "*Function:* JPT.ClearLog  \n*Description:* clear all log on Python API Window  \n *Input1:* None  \n *Return:* None  \n *Example:* JPT.ClearLog()  \n *Description:* return size of list  \n *Input1:* None  \n *Return:* None  \n *Example:* objectVector.sizeVec()  \n *Description:* clear all element in list, size reset to zero  \n *Input1:* None  \n *Return:* None  \n *Example:* objectVector.clearVec()  \n *Description:* append an entity to current list  \n *Input1:* entity object  \n *Return:* Node  \n *Example:* objectVector.addObj(entityObject)  \n *Description:* insert another list entity to current list  \n *Input1:* list of object  \n *Return:* None  \n *Example:* objectVector1.extendVec(objectVector2)  \n *Description:* delete a entity in list by index  \n *Input1:* None  \n *Return:* None  \n *Example:* objectVector.deleteObj(1)  \n *Description:* check if entityObject is exist in current list  \n *Input1:* None  \n *Return:* TRUE if existed/FALSE if not  \n *Example:* objectVector.isContainObj(entityObject)  \n ",
    },
    "JPT.SetSelectMethod": {
        prefix: "SetSelectMethod",
        text: "*Function:* JPT.SetSelectMethod  \n*Description:* set select method on view   \n *Input1:* select method type (JPT.SelectMethodType)  \n *Return:* None  \n *Example:* JPT.SetSelector(JPT.SelectMethodType.SELMTD_BODY)  \n ",
    },
    "JPT.MacroTCursorPairToDItemPair": {
        prefix: "MacroTCursorPairToDItemPair",
        text: "*Function:* JPT.MacroTCursorPairToDItemPair  \n*Description:* convert a macro cursor pair string to DItemPair objects  \n *Input1:* macro cursor pair string (string)  \n *Return:* DItemPair objects (DItemPair)  \n *Example: listEntityObject = JPT.MacroTCursorPairToDItemPair('10:210-10:*202')  \n ",
    },
    "JPT.MessageBoxPSJ": {
        prefix: "MessageBoxPSJ",
        text: '*Function:* JPT.MessageBoxPSJ  \n*Description:* display a message box  \n *Input1:* message (string)  \n *Input2:* message type (JPT.MsgBoxType)  \n *Return: anwser :* YES, NO, OK, CANCEL (string)  \n *Example:* anwser = JPT.MessageBoxPSJ("this is test message, JPT.MsgBoxType.MB_INFORMATION_OKCANCEL)  \n ',
    },
    "JPT.GetProgramVersion": {
        prefix: "GetProgramVersion",
        text: "*Function:* JPT.GetProgramVersion  \n*Description:* get jupiter version   \n *Input:* None  \n *Return:* VersionInfo object (VersionInfo)  \n *Example:* versionInfo = JPT.GetProgramVersion()  \n print(versionInfo.major)  \n print(versionInfo.minor)  \n print(versionInfo.sub)  \n print(versionInfo.build)  \n ",
    },
    "JPT.GetMaterialFromProperty": {
        prefix: "GetMaterialFromProperty",
        text: "*Function:* JPT.GetMaterialFromProperty  \n*Description:* get material from property ID  \n *Input:* property ID (init)  \n *Return:* DItem object (DItem)  \n *Example:* material = JPT.GetMaterialFromProperty(1)  \n ",
    },
    "JPT.GetAllCoordinates": {
        prefix: "GetAllCoordinates",
        text: "*Function:* JPT.GetAllCoordinates  \n*Description:* get jupiter version   \n *Input:* None  \n *Return:* list of DCoord object (CoordVector)  \n *Example:* coordinate = JPT.GetAllCoordinates()  \n ",
    },
    "JPT.GetAllConnections": {
        prefix: "GetAllConnections",
        text: "*Function:* JPT.GetAllConnections  \n*Description:* get jupiter version   \n *Input:* None  \n *Return:* list of DConnect object (ConnectVector)  \n *Example:* connection = JPT.GetAllConnections()  \n ",
    },
    "JPT.GetAllLoadBoundaryConditions": {
        prefix: "GetAllLoadBoundaryConditions",
        text: "*Function:* JPT.GetAllLoadBoundaryConditions  \n*Description:* get jupiter version   \n *Input:* None  \n *Return:* list of DLoadBC object (LoadBCVector)  \n *Example:* lbcs = JPT.GetAllLoadBoundaryConditions()  \n ",
    },
    "JPT.GetThicknessOfEntity": {
        prefix: "GetThicknessOfEntity",
        text: "*Function:* JPT.GetThicknessOfEntity  \n*Description:* get thickness of body or face or element   \n *Input1:* only DItem Body/Face/Element type (JPT.EntityType)  \n *Input2:* id entity (int)    \n *Return:* double thickness of entity  \n *Example:* dThickness = JPT.GetThicknessOfEntity(JPT.EntityType.FACE, 1)  \n ",
    },
};
//# sourceMappingURL=data.js.map